{"$schema": "https://docs.oasis-open.org/sarif/sarif/v2.1.0/errata01/os/schemas/sarif-schema-2.1.0.json",
 "version": "2.1.0",
 "runs": [{"tool": {"driver": {"name": "GNU C++26",
                               "fullName": "GNU C++26 (GCC) version 15.2.1 20260209 (x86_64-pc-linux-gnu)",
                               "version": "15.2.1 20260209",
                               "informationUri": "https://gcc.gnu.org/gcc-15/",
                               "rules": []}},
           "invocations": [{"arguments": ["/usr/lib/gcc/x86_64-pc-linux-gnu/15.2.1/cc1plus",
                                          "-quiet",
                                          "-D_GNU_SOURCE",
                                          "test/main.cpp",
                                          "-quiet",
                                          "-dumpdir",
                                          "a-",
                                          "-dumpbase",
                                          "main.cpp",
                                          "-dumpbase-ext",
                                          ".cpp",
                                          "-mtune=generic",
                                          "-march=x86-64",
                                          "-std=c++26",
                                          "-fdiagnostics-add-output=sarif:file=test/main.sarif",
                                          "-o",
                                          "/tmp/ccgU3xcR.s"],
                            "workingDirectory": {"uri": "/home/shyeyian/Code/vscode-cppsarif"},
                            "startTimeUtc": "2026-02-22T07:49:27Z",
                            "executionSuccessful": false,
                            "toolExecutionNotifications": [],
                            "endTimeUtc": "2026-02-22T07:49:27Z"}],
           "originalUriBaseIds": {"PWD": {"uri": "file:///home/shyeyian/Code/vscode-cppsarif/"}},
           "artifacts": [{"location": {"uri": "test/main.cpp",
                                       "uriBaseId": "PWD"},
                          "sourceLanguage": "cplusplus",
                          "roles": ["analysisTarget"]},
                         {"location": {"uri": "/usr/include/c++/15.2.1/ranges"},
                          "sourceLanguage": "cplusplus",
                          "contents": {"text": "// <ranges> -*- C++ -*-\n\n// Copyright (C) 2019-2025 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/ranges\n *  This is a Standard C++ Library header.\n *  @ingroup concepts\n */\n\n#ifndef _GLIBCXX_RANGES\n#define _GLIBCXX_RANGES 1\n\n#if __cplusplus > 201703L\n\n#ifdef _GLIBCXX_SYSHDR\n#pragma GCC system_header\n#endif\n\n#include <concepts>\n\n#if __cpp_lib_concepts\n\n#include <compare>\n#include <initializer_list>\n#include <iterator>\n#include <optional>\n#include <span>\n#include <string_view>\n#include <tuple>\n#if __cplusplus > 202002L\n#include <utility>\n#include <variant>\n#endif\n#include <bits/ranges_util.h>\n#include <bits/refwrap.h>\n\n#define __glibcxx_want_algorithm_default_value_type\n#define __glibcxx_want_ranges\n#define __glibcxx_want_ranges_as_const\n#define __glibcxx_want_ranges_as_rvalue\n#define __glibcxx_want_ranges_cache_latest\n#define __glibcxx_want_ranges_cartesian_product\n#define __glibcxx_want_ranges_concat\n#define __glibcxx_want_ranges_chunk\n#define __glibcxx_want_ranges_chunk_by\n#define __glibcxx_want_ranges_enumerate\n#define __glibcxx_want_ranges_join_with\n#define __glibcxx_want_ranges_repeat\n#define __glibcxx_want_ranges_slide\n#define __glibcxx_want_ranges_stride\n#define __glibcxx_want_ranges_to_container\n#define __glibcxx_want_ranges_to_input\n#define __glibcxx_want_ranges_zip\n#include <bits/version.h>\n\n#ifdef __glibcxx_generator  // C++ >= 23 && __glibcxx_coroutine\n# include <bits/elements_of.h>\n#endif\n\n/**\n * @defgroup ranges Ranges\n *\n * Components for dealing with ranges of elements.\n */\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\nnamespace ranges\n{\n  // [range.access] customization point objects\n  // [range.req] range and view concepts\n  // [range.dangling] dangling iterator handling\n  // Defined in <bits/ranges_base.h>\n\n  // [view.interface] View interface\n  // [range.subrange] Sub-ranges\n  // Defined in <bits/ranges_util.h>\n\n  // C++20 24.6 [range.factories] Range factories\n\n  /// A view that contains no elements.\n  template<typename _Tp> requires is_object_v<_Tp>\n    class empty_view\n    : public view_interface<empty_view<_Tp>>\n    {\n    public:\n      static constexpr _Tp* begin() noexcept { return nullptr; }\n      static constexpr _Tp* end() noexcept { return nullptr; }\n      static constexpr _Tp* data() noexcept { return nullptr; }\n      static constexpr size_t size() noexcept { return 0; }\n      static constexpr bool empty() noexcept { return true; }\n    };\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<empty_view<_Tp>> = true;\n\n  namespace __detail\n  {\n#if __cpp_lib_ranges >= 202207L // C++ >= 23\n    // P2494R2 Relaxing range adaptors to allow for move only types\n    template<typename _Tp>\n      concept __boxable = move_constructible<_Tp> && is_object_v<_Tp>;\n#else\n    template<typename _Tp>\n      concept __boxable = copy_constructible<_Tp> && is_object_v<_Tp>;\n#endif\n\n    template<__boxable _Tp>\n      struct __box : std::optional<_Tp>\n      {\n\tusing std::optional<_Tp>::optional;\n\n\tconstexpr\n\t__box()\n\tnoexcept(is_nothrow_default_constructible_v<_Tp>)\n\trequires default_initializable<_Tp>\n\t: std::optional<_Tp>{std::in_place}\n\t{ }\n\n\t__box(const __box&) = default;\n\t__box(__box&&) = default;\n\n\tusing std::optional<_Tp>::operator=;\n\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 3477. Simplify constraints for semiregular-box\n\t// 3572. copyable-box should be fully constexpr\n\tconstexpr __box&\n\toperator=(const __box& __that)\n\tnoexcept(is_nothrow_copy_constructible_v<_Tp>)\n\trequires (!copyable<_Tp>) && copy_constructible<_Tp>\n\t{\n\t  if (this != std::__addressof(__that))\n\t    {\n\t      if ((bool)__that)\n\t\tthis->emplace(*__that);\n\t      else\n\t\tthis->reset();\n\t    }\n\t  return *this;\n\t}\n\n\tconstexpr __box&\n\toperator=(__box&& __that)\n\tnoexcept(is_nothrow_move_constructible_v<_Tp>)\n\trequires (!movable<_Tp>)\n\t{\n\t  if (this != std::__addressof(__that))\n\t    {\n\t      if ((bool)__that)\n\t\tthis->emplace(std::move(*__that));\n\t      else\n\t\tthis->reset();\n\t    }\n\t  return *this;\n\t}\n      };\n\n    template<typename _Tp>\n      concept __boxable_copyable\n\t= copy_constructible<_Tp>\n\t    && (copyable<_Tp> || (is_nothrow_move_constructible_v<_Tp>\n\t\t\t\t    && is_nothrow_copy_constructible_v<_Tp>));\n    template<typename _Tp>\n      concept __boxable_movable\n\t= (!copy_constructible<_Tp>)\n\t    && (movable<_Tp> || is_nothrow_move_constructible_v<_Tp>);\n\n    // For types which are already copyable (or since C++23, movable)\n    // this specialization of the box wrapper stores the object directly\n    // without going through std::optional.  It provides just the subset of\n    // the primary template's API that we currently use.\n    template<__boxable _Tp>\n      requires __boxable_copyable<_Tp> || __boxable_movable<_Tp>\n      struct __box<_Tp>\n      {\n      private:\n\t[[no_unique_address]] _Tp _M_value = _Tp();\n\n      public:\n\t__box() requires default_initializable<_Tp> = default;\n\n\tconstexpr explicit\n\t__box(const _Tp& __t)\n\tnoexcept(is_nothrow_copy_constructible_v<_Tp>)\n\trequires copy_constructible<_Tp>\n\t: _M_value(__t)\n\t{ }\n\n\tconstexpr explicit\n\t__box(_Tp&& __t)\n\tnoexcept(is_nothrow_move_constructible_v<_Tp>)\n\t: _M_value(std::move(__t))\n\t{ }\n\n\ttemplate<typename... _Args>\n\t  requires constructible_from<_Tp, _Args...>\n\t  constexpr explicit\n\t  __box(in_place_t, _Args&&... __args)\n\t  noexcept(is_nothrow_constructible_v<_Tp, _Args...>)\n\t  : _M_value(std::forward<_Args>(__args)...)\n\t  { }\n\n\t__box(const __box&) = default;\n\t__box(__box&&) = default;\n\t__box& operator=(const __box&) requires copyable<_Tp> = default;\n\t__box& operator=(__box&&) requires movable<_Tp> = default;\n\n\t// When _Tp is nothrow_copy_constructible but not copy_assignable,\n\t// copy assignment is implemented via destroy-then-copy-construct.\n\tconstexpr __box&\n\toperator=(const __box& __that) noexcept\n\trequires (!copyable<_Tp>) && copy_constructible<_Tp>\n\t{\n\t  static_assert(is_nothrow_copy_constructible_v<_Tp>);\n\t  if (this != std::__addressof(__that))\n\t    {\n\t      _M_value.~_Tp();\n\t      std::construct_at(std::__addressof(_M_value), *__that);\n\t    }\n\t  return *this;\n\t}\n\n\t// Likewise for move assignment.\n\tconstexpr __box&\n\toperator=(__box&& __that) noexcept\n\trequires (!movable<_Tp>)\n\t{\n\t  static_assert(is_nothrow_move_constructible_v<_Tp>);\n\t  if (this != std::__addressof(__that))\n\t    {\n\t      _M_value.~_Tp();\n\t      std::construct_at(std::__addressof(_M_value), std::move(*__that));\n\t    }\n\t  return *this;\n\t}\n\n\tconstexpr bool\n\thas_value() const noexcept\n\t{ return true; };\n\n\tconstexpr _Tp&\n\toperator*() & noexcept\n\t{ return _M_value; }\n\n\tconstexpr const _Tp&\n\toperator*() const & noexcept\n\t{ return _M_value; }\n\n\tconstexpr _Tp&&\n\toperator*() && noexcept\n\t{ return std::move(_M_value); }\n\n\tconstexpr const _Tp&&\n\toperator*() const && noexcept\n\t{ return std::move(_M_value); }\n\n\tconstexpr _Tp*\n\toperator->() noexcept\n\t{ return std::__addressof(_M_value); }\n\n\tconstexpr const _Tp*\n\toperator->() const noexcept\n\t{ return std::__addressof(_M_value); }\n      };\n  } // namespace __detail\n\n  /// A view that contains exactly one element.\n#if __cpp_lib_ranges >= 202207L // C++ >= 23\n  template<move_constructible _Tp>\n#else\n  template<copy_constructible _Tp>\n#endif\n    requires is_object_v<_Tp>\n    class single_view : public view_interface<single_view<_Tp>>\n    {\n    public:\n      single_view() requires default_initializable<_Tp> = default;\n\n      constexpr explicit\n      single_view(const _Tp& __t)\n      noexcept(is_nothrow_copy_constructible_v<_Tp>)\n      requires copy_constructible<_Tp>\n      : _M_value(__t)\n      { }\n\n      constexpr explicit\n      single_view(_Tp&& __t)\n      noexcept(is_nothrow_move_constructible_v<_Tp>)\n      : _M_value(std::move(__t))\n      { }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3428. single_view's in place constructor should be explicit\n      template<typename... _Args>\n\trequires constructible_from<_Tp, _Args...>\n\tconstexpr explicit\n\tsingle_view(in_place_t, _Args&&... __args)\n\tnoexcept(is_nothrow_constructible_v<_Tp, _Args...>)\n\t: _M_value{in_place, std::forward<_Args>(__args)...}\n\t{ }\n\n      constexpr _Tp*\n      begin() noexcept\n      { return data(); }\n\n      constexpr const _Tp*\n      begin() const noexcept\n      { return data(); }\n\n      constexpr _Tp*\n      end() noexcept\n      { return data() + 1; }\n\n      constexpr const _Tp*\n      end() const noexcept\n      { return data() + 1; }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 4035. single_view should provide empty\n      static constexpr bool\n      empty() noexcept\n      { return false; }\n\n      static constexpr size_t\n      size() noexcept\n      { return 1; }\n\n      constexpr _Tp*\n      data() noexcept\n      { return _M_value.operator->(); }\n\n      constexpr const _Tp*\n      data() const noexcept\n      { return _M_value.operator->(); }\n\n    private:\n      [[no_unique_address]] __detail::__box<_Tp> _M_value;\n    };\n\n  template<typename _Tp>\n    single_view(_Tp) -> single_view<_Tp>;\n\n  namespace __detail\n  {\n    template<typename _Wp>\n      constexpr auto __to_signed_like(_Wp __w) noexcept\n      {\n\tif constexpr (!integral<_Wp>)\n\t  return iter_difference_t<_Wp>();\n\telse if constexpr (sizeof(iter_difference_t<_Wp>) > sizeof(_Wp))\n\t  return iter_difference_t<_Wp>(__w);\n\telse if constexpr (sizeof(ptrdiff_t) > sizeof(_Wp))\n\t  return ptrdiff_t(__w);\n\telse if constexpr (sizeof(long long) > sizeof(_Wp))\n\t  return (long long)(__w);\n#ifdef __SIZEOF_INT128__\n\telse if constexpr (__SIZEOF_INT128__ > sizeof(_Wp))\n\t  return __int128(__w);\n#endif\n\telse\n\t  return __max_diff_type(__w);\n      }\n\n    template<typename _Wp>\n      using __iota_diff_t = decltype(__to_signed_like(std::declval<_Wp>()));\n\n    template<typename _It>\n      concept __decrementable = incrementable<_It>\n\t&& requires(_It __i)\n\t{\n\t    { --__i } -> same_as<_It&>;\n\t    { __i-- } -> same_as<_It>;\n\t};\n\n    template<typename _It>\n      concept __advanceable = __decrementable<_It> && totally_ordered<_It>\n\t&& requires( _It __i, const _It __j, const __iota_diff_t<_It> __n)\n\t{\n\t  { __i += __n } -> same_as<_It&>;\n\t  { __i -= __n } -> same_as<_It&>;\n\t  _It(__j + __n);\n\t  _It(__n + __j);\n\t  _It(__j - __n);\n\t  { __j - __j } -> convertible_to<__iota_diff_t<_It>>;\n\t};\n\n    template<typename _Winc>\n      struct __iota_view_iter_cat\n      { };\n\n    template<incrementable _Winc>\n      struct __iota_view_iter_cat<_Winc>\n      { using iterator_category = input_iterator_tag; };\n  } // namespace __detail\n\n  template<weakly_incrementable _Winc,\n\t   semiregular _Bound = unreachable_sentinel_t>\n    requires std::__detail::__weakly_eq_cmp_with<_Winc, _Bound>\n      && copyable<_Winc>\n    class iota_view : public view_interface<iota_view<_Winc, _Bound>>\n    {\n    private:\n      struct _Sentinel;\n\n      struct _Iterator : __detail::__iota_view_iter_cat<_Winc>\n      {\n      private:\n\tstatic auto\n\t_S_iter_concept()\n\t{\n\t  using namespace __detail;\n\t  if constexpr (__advanceable<_Winc>)\n\t    return random_access_iterator_tag{};\n\t  else if constexpr (__decrementable<_Winc>)\n\t    return bidirectional_iterator_tag{};\n\t  else if constexpr (incrementable<_Winc>)\n\t    return forward_iterator_tag{};\n\t  else\n\t    return input_iterator_tag{};\n\t}\n\n      public:\n\tusing iterator_concept = decltype(_S_iter_concept());\n\t// iterator_category defined in __iota_view_iter_cat\n\tusing value_type = _Winc;\n\tusing difference_type = __detail::__iota_diff_t<_Winc>;\n\n\t_Iterator() requires default_initializable<_Winc> = default;\n\n\tconstexpr explicit\n\t_Iterator(_Winc __value)\n\t: _M_value(__value) { }\n\n\tconstexpr _Winc\n\toperator*() const noexcept(is_nothrow_copy_constructible_v<_Winc>)\n\t{ return _M_value; }\n\n\tconstexpr _Iterator&\n\toperator++()\n\t{\n\t  ++_M_value;\n\t  return *this;\n\t}\n\n\tconstexpr void\n\toperator++(int)\n\t{ ++*this; }\n\n\tconstexpr _Iterator\n\toperator++(int) requires incrementable<_Winc>\n\t{\n\t  auto __tmp = *this;\n\t  ++*this;\n\t  return __tmp;\n\t}\n\n\tconstexpr _Iterator&\n\toperator--() requires __detail::__decrementable<_Winc>\n\t{\n\t  --_M_value;\n\t  return *this;\n\t}\n\n\tconstexpr _Iterator\n\toperator--(int) requires __detail::__decrementable<_Winc>\n\t{\n\t  auto __tmp = *this;\n\t  --*this;\n\t  return __tmp;\n\t}\n\n\tconstexpr _Iterator&\n\toperator+=(difference_type __n) requires __detail::__advanceable<_Winc>\n\t{\n\t  using __detail::__is_integer_like;\n\t  using __detail::__is_signed_integer_like;\n\t  if constexpr (__is_integer_like<_Winc>\n\t      && !__is_signed_integer_like<_Winc>)\n\t    {\n\t      if (__n >= difference_type(0))\n\t\t_M_value += static_cast<_Winc>(__n);\n\t      else\n\t\t_M_value -= static_cast<_Winc>(-__n);\n\t    }\n\t  else\n\t    _M_value += __n;\n\t  return *this;\n\t}\n\n\tconstexpr _Iterator&\n\toperator-=(difference_type __n) requires __detail::__advanceable<_Winc>\n\t{\n\t  using __detail::__is_integer_like;\n\t  using __detail::__is_signed_integer_like;\n\t  if constexpr (__is_integer_like<_Winc>\n\t      && !__is_signed_integer_like<_Winc>)\n\t    {\n\t      if (__n >= difference_type(0))\n\t\t_M_value -= static_cast<_Winc>(__n);\n\t      else\n\t\t_M_value += static_cast<_Winc>(-__n);\n\t    }\n\t  else\n\t    _M_value -= __n;\n\t  return *this;\n\t}\n\n\tconstexpr _Winc\n\toperator[](difference_type __n) const\n\trequires __detail::__advanceable<_Winc>\n\t{ return _Winc(_M_value + __n); }\n\n\tfriend constexpr bool\n\toperator==(const _Iterator& __x, const _Iterator& __y)\n\trequires equality_comparable<_Winc>\n\t{ return __x._M_value == __y._M_value; }\n\n\tfriend constexpr bool\n\toperator<(const _Iterator& __x, const _Iterator& __y)\n\trequires totally_ordered<_Winc>\n\t{ return __x._M_value < __y._M_value; }\n\n\tfriend constexpr bool\n\toperator>(const _Iterator& __x, const _Iterator& __y)\n\t  requires totally_ordered<_Winc>\n\t{ return __y < __x; }\n\n\tfriend constexpr bool\n\toperator<=(const _Iterator& __x, const _Iterator& __y)\n\t  requires totally_ordered<_Winc>\n\t{ return !(__y < __x); }\n\n\tfriend constexpr bool\n\toperator>=(const _Iterator& __x, const _Iterator& __y)\n\t  requires totally_ordered<_Winc>\n\t{ return !(__x < __y); }\n\n#ifdef __cpp_lib_three_way_comparison\n\tfriend constexpr auto\n\toperator<=>(const _Iterator& __x, const _Iterator& __y)\n\t  requires totally_ordered<_Winc> && three_way_comparable<_Winc>\n\t{ return __x._M_value <=> __y._M_value; }\n#endif\n\n\tfriend constexpr _Iterator\n\toperator+(_Iterator __i, difference_type __n)\n\t  requires __detail::__advanceable<_Winc>\n\t{\n\t  __i += __n;\n\t  return __i;\n\t}\n\n\tfriend constexpr _Iterator\n\toperator+(difference_type __n, _Iterator __i)\n\t  requires __detail::__advanceable<_Winc>\n\t{ return __i += __n; }\n\n\tfriend constexpr _Iterator\n\toperator-(_Iterator __i, difference_type __n)\n\t  requires __detail::__advanceable<_Winc>\n\t{\n\t  __i -= __n;\n\t  return __i;\n\t}\n\n\tfriend constexpr difference_type\n\toperator-(const _Iterator& __x, const _Iterator& __y)\n\t  requires __detail::__advanceable<_Winc>\n\t{\n\t  using __detail::__is_integer_like;\n\t  using __detail::__is_signed_integer_like;\n\t  using _Dt = difference_type;\n\t  if constexpr (__is_integer_like<_Winc>)\n\t    {\n\t      if constexpr (__is_signed_integer_like<_Winc>)\n\t\treturn _Dt(_Dt(__x._M_value) - _Dt(__y._M_value));\n\t      else\n\t\treturn (__y._M_value > __x._M_value)\n\t\t  ? _Dt(-_Dt(__y._M_value - __x._M_value))\n\t\t  : _Dt(__x._M_value - __y._M_value);\n\t    }\n\t  else\n\t    return __x._M_value - __y._M_value;\n\t}\n\n      private:\n\t_Winc _M_value = _Winc();\n\n\tfriend iota_view;\n        friend _Sentinel;\n      };\n\n      struct _Sentinel\n      {\n      private:\n\tconstexpr bool\n\t_M_equal(const _Iterator& __x) const\n\t{ return __x._M_value == _M_bound; }\n\n\tconstexpr auto\n\t_M_distance_from(const _Iterator& __x) const\n\t{ return _M_bound - __x._M_value; }\n\n\t_Bound _M_bound = _Bound();\n\n      public:\n\t_Sentinel() = default;\n\n\tconstexpr explicit\n\t_Sentinel(_Bound __bound)\n\t: _M_bound(__bound) { }\n\n\tfriend constexpr bool\n\toperator==(const _Iterator& __x, const _Sentinel& __y)\n\t{ return __y._M_equal(__x); }\n\n\tfriend constexpr iter_difference_t<_Winc>\n\toperator-(const _Iterator& __x, const _Sentinel& __y)\n\t  requires sized_sentinel_for<_Bound, _Winc>\n\t{ return -__y._M_distance_from(__x); }\n\n\tfriend constexpr iter_difference_t<_Winc>\n\toperator-(const _Sentinel& __x, const _Iterator& __y)\n\t  requires sized_sentinel_for<_Bound, _Winc>\n\t{ return __x._M_distance_from(__y); }\n\n\tfriend iota_view;\n      };\n\n      _Winc _M_value = _Winc();\n      [[no_unique_address]] _Bound _M_bound = _Bound();\n\n    public:\n      iota_view() requires default_initializable<_Winc> = default;\n\n      constexpr explicit\n      iota_view(_Winc __value)\n      : _M_value(__value)\n      { }\n\n      constexpr\n      iota_view(type_identity_t<_Winc> __value,\n\t\ttype_identity_t<_Bound> __bound)\n      : _M_value(__value), _M_bound(__bound)\n      {\n\tif constexpr (totally_ordered_with<_Winc, _Bound>)\n\t  __glibcxx_assert( bool(__value <= __bound) );\n      }\n\n      constexpr\n      iota_view(_Iterator __first, _Iterator __last)\n\trequires same_as<_Winc, _Bound>\n\t: iota_view(__first._M_value, __last._M_value)\n      { }\n\n      constexpr\n      iota_view(_Iterator __first, unreachable_sentinel_t __last)\n\trequires same_as<_Bound, unreachable_sentinel_t>\n\t: iota_view(__first._M_value, __last)\n      { }\n\n      constexpr\n      iota_view(_Iterator __first, _Sentinel __last)\n\trequires (!same_as<_Winc, _Bound>) && (!same_as<_Bound, unreachable_sentinel_t>)\n\t: iota_view(__first._M_value, __last._M_bound)\n      { }\n\n      constexpr _Iterator\n      begin() const { return _Iterator{_M_value}; }\n\n      constexpr auto\n      end() const\n      {\n\tif constexpr (same_as<_Bound, unreachable_sentinel_t>)\n\t  return unreachable_sentinel;\n\telse\n\t  return _Sentinel{_M_bound};\n      }\n\n      constexpr _Iterator\n      end() const requires same_as<_Winc, _Bound>\n      { return _Iterator{_M_bound}; }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 4001. iota_view should provide empty\n      constexpr bool\n      empty() const\n      { return _M_value == _M_bound; }\n\n      constexpr auto\n      size() const\n      requires (same_as<_Winc, _Bound> && __detail::__advanceable<_Winc>)\n      || (integral<_Winc> && integral<_Bound>)\n      || sized_sentinel_for<_Bound, _Winc>\n      {\n\tusing __detail::__is_integer_like;\n\tusing __detail::__to_unsigned_like;\n\tif constexpr (integral<_Winc> && integral<_Bound>)\n\t  {\n\t    using _Up = make_unsigned_t<decltype(_M_bound - _M_value)>;\n\t    return _Up(_M_bound) - _Up(_M_value);\n\t  }\n\telse if constexpr (__is_integer_like<_Winc>)\n\t  return __to_unsigned_like(_M_bound) - __to_unsigned_like(_M_value);\n\telse\n\t  return __to_unsigned_like(_M_bound - _M_value);\n      }\n    };\n\n  template<typename _Winc, typename _Bound>\n    requires (!__detail::__is_integer_like<_Winc>\n\t|| !__detail::__is_integer_like<_Bound>\n\t|| (__detail::__is_signed_integer_like<_Winc>\n\t    == __detail::__is_signed_integer_like<_Bound>))\n    iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;\n\n  template<typename _Winc, typename _Bound>\n    inline constexpr bool\n      enable_borrowed_range<iota_view<_Winc, _Bound>> = true;\n\nnamespace views\n{\n  template<typename _Tp>\n    inline constexpr empty_view<_Tp> empty{};\n\n  namespace __detail\n  {\n    template<typename _Tp>\n      concept __can_single_view\n\t= requires { single_view<decay_t<_Tp>>(std::declval<_Tp>()); };\n  } // namespace __detail\n\n  struct _Single\n  {\n    template<__detail::__can_single_view _Tp>\n      constexpr auto\n      operator() [[nodiscard]] (_Tp&& __e) const\n      noexcept(noexcept(single_view<decay_t<_Tp>>(std::forward<_Tp>(__e))))\n      { return single_view<decay_t<_Tp>>(std::forward<_Tp>(__e)); }\n  };\n\n  inline constexpr _Single single{};\n\n  namespace __detail\n  {\n    template<typename... _Args>\n      concept __can_iota_view = requires { iota_view(std::declval<_Args>()...); };\n  } // namespace __detail\n\n  struct _Iota\n  {\n    template<__detail::__can_iota_view _Tp>\n      constexpr auto\n      operator() [[nodiscard]] (_Tp&& __e) const\n      { return iota_view(std::forward<_Tp>(__e)); }\n\n    template<typename _Tp, typename _Up>\n      requires __detail::__can_iota_view<_Tp, _Up>\n      constexpr auto\n      operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const\n      { return iota_view(std::forward<_Tp>(__e), std::forward<_Up>(__f)); }\n  };\n\n  inline constexpr _Iota iota{};\n} // namespace views\n\n#if _GLIBCXX_HOSTED\n  namespace __detail\n  {\n    template<typename _Val, typename _CharT, typename _Traits>\n      concept __stream_extractable\n\t= requires(basic_istream<_CharT, _Traits>& is, _Val& t) { is >> t; };\n  } // namespace __detail\n\n  template<movable _Val, typename _CharT,\n\t   typename _Traits = char_traits<_CharT>>\n    requires default_initializable<_Val>\n      && __detail::__stream_extractable<_Val, _CharT, _Traits>\n    class basic_istream_view\n    : public view_interface<basic_istream_view<_Val, _CharT, _Traits>>\n    {\n    public:\n      constexpr explicit\n      basic_istream_view(basic_istream<_CharT, _Traits>& __stream)\n\t: _M_stream(std::__addressof(__stream))\n      { }\n\n      constexpr auto\n      begin()\n      {\n\t*_M_stream >> _M_object;\n\treturn _Iterator{this};\n      }\n\n      constexpr default_sentinel_t\n      end() const noexcept\n      { return default_sentinel; }\n\n    private:\n      basic_istream<_CharT, _Traits>* _M_stream;\n      _Val _M_object = _Val();\n\n      struct _Iterator\n      {\n      public:\n\tusing iterator_concept = input_iterator_tag;\n\tusing difference_type = ptrdiff_t;\n\tusing value_type = _Val;\n\n\tconstexpr explicit\n\t_Iterator(basic_istream_view* __parent) noexcept\n\t  : _M_parent(__parent)\n\t{ }\n\n\t_Iterator(const _Iterator&) = delete;\n\t_Iterator(_Iterator&&) = default;\n\t_Iterator& operator=(const _Iterator&) = delete;\n\t_Iterator& operator=(_Iterator&&) = default;\n\n\t_Iterator&\n\toperator++()\n\t{\n\t  *_M_parent->_M_stream >> _M_parent->_M_object;\n\t  return *this;\n\t}\n\n\tvoid\n\toperator++(int)\n\t{ ++*this; }\n\n\t_Val&\n\toperator*() const\n\t{ return _M_parent->_M_object; }\n\n\tfriend bool\n\toperator==(const _Iterator& __x, default_sentinel_t)\n\t{ return __x._M_at_end(); }\n\n      private:\n\tbasic_istream_view* _M_parent;\n\n\tbool\n\t_M_at_end() const\n\t{ return !*_M_parent->_M_stream; }\n      };\n\n      friend _Iterator;\n    };\n\n  template<typename _Val>\n    using istream_view = basic_istream_view<_Val, char>;\n\n  template<typename _Val>\n    using wistream_view = basic_istream_view<_Val, wchar_t>;\n\nnamespace views\n{\n  namespace __detail\n  {\n    template<typename _Tp, typename _Up>\n    concept __can_istream_view = requires (_Up __e) {\n      basic_istream_view<_Tp, typename _Up::char_type, typename _Up::traits_type>(__e);\n    };\n  } // namespace __detail\n\n  template<typename _Tp>\n    struct _Istream\n    {\n      template<typename _CharT, typename _Traits>\n\tconstexpr auto\n\toperator() [[nodiscard]] (basic_istream<_CharT, _Traits>& __e) const\n\trequires __detail::__can_istream_view<_Tp, remove_reference_t<decltype(__e)>>\n\t{ return basic_istream_view<_Tp, _CharT, _Traits>(__e); }\n    };\n\n  template<typename _Tp>\n    inline constexpr _Istream<_Tp> istream;\n}\n#endif // HOSTED\n\n  // C++20 24.7 [range.adaptors] Range adaptors\n\nnamespace __detail\n{\n  template<typename _Tp, int _Disc>\n    struct _Absent { };\n\n  // Alias for a type that is conditionally present\n  // (and is an empty type otherwise).\n  // Data members using this alias should use [[no_unique_address]] so that\n  // they take no space when not needed.\n  // The optional template parameter _Disc is for discriminating two otherwise\n  // equivalent absent types so that even they can overlap.\n  template<bool _Present, typename _Tp, int _Disc = 0>\n    using __maybe_present_t = __conditional_t<_Present, _Tp, _Absent<_Tp, _Disc>>;\n\n  // Alias for a type that is conditionally const.\n  template<bool _Const, typename _Tp>\n    using __maybe_const_t = __conditional_t<_Const, const _Tp, _Tp>;\n\n} // namespace __detail\n\n// Shorthand for __detail::__maybe_const_t.\nusing __detail::__maybe_const_t;\n\nnamespace views::__adaptor\n{\n  // True if the range adaptor _Adaptor can be applied with _Args.\n  template<typename _Adaptor, typename... _Args>\n    concept __adaptor_invocable\n      = requires { std::declval<_Adaptor>()(declval<_Args>()...); };\n\n  // True if the range adaptor non-closure _Adaptor can be partially applied\n  // with _Args.\n  template<typename _Adaptor, typename... _Args>\n    concept __adaptor_partial_app_viable = (_Adaptor::_S_arity > 1)\n      && (sizeof...(_Args) == _Adaptor::_S_arity - 1)\n      && (constructible_from<decay_t<_Args>, _Args> && ...);\n\n  template<typename _Adaptor, typename... _Args>\n    struct _Partial;\n\n  template<typename _Lhs, typename _Rhs>\n    struct _Pipe;\n\n  // The base class of every range adaptor closure.\n  //\n  // The derived class should define the optional static data member\n  // _S_has_simple_call_op to true if the behavior of this adaptor is\n  // independent of the constness/value category of the adaptor object.\n  template<typename _Derived>\n    struct _RangeAdaptorClosure;\n\n  template<typename _Tp, typename _Up>\n    requires (!same_as<_Tp, _RangeAdaptorClosure<_Up>>)\n    void __is_range_adaptor_closure_fn\n      (const _Tp&, const _RangeAdaptorClosure<_Up>&); // not defined\n\n  template<typename _Tp>\n    concept __is_range_adaptor_closure\n      = requires (_Tp __t) { __adaptor::__is_range_adaptor_closure_fn(__t, __t); };\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdangling-reference\"\n  // range | adaptor is equivalent to adaptor(range).\n  template<typename _Self, typename _Range>\n    requires __is_range_adaptor_closure<_Self>\n      && __adaptor_invocable<_Self, _Range>\n    constexpr auto\n    operator|(_Range&& __r, _Self&& __self)\n    { return std::forward<_Self>(__self)(std::forward<_Range>(__r)); }\n\n  // Compose the adaptors __lhs and __rhs into a pipeline, returning\n  // another range adaptor closure object.\n  template<typename _Lhs, typename _Rhs>\n    requires __is_range_adaptor_closure<_Lhs>\n      && __is_range_adaptor_closure<_Rhs>\n    constexpr auto\n    operator|(_Lhs&& __lhs, _Rhs&& __rhs)\n    {\n      return _Pipe<decay_t<_Lhs>, decay_t<_Rhs>>{std::forward<_Lhs>(__lhs),\n\t\t\t\t\t\t std::forward<_Rhs>(__rhs)};\n    }\n#pragma GCC diagnostic pop\n\n  template<typename _Derived>\n    struct _RangeAdaptorClosure\n    {\n      // In non-modules compilation ADL finds these operators either way and\n      // the friend declarations are redundant.  But with the std module these\n      // friend declarations enable ADL to find these operators without having\n      // to export them.\n      template<typename _Self, typename _Range>\n\trequires __is_range_adaptor_closure<_Self>\n\t  && __adaptor_invocable<_Self, _Range>\n\tfriend constexpr auto\n\toperator|(_Range&& __r, _Self&& __self);\n\n      template<typename _Lhs, typename _Rhs>\n\trequires __is_range_adaptor_closure<_Lhs>\n\t  && __is_range_adaptor_closure<_Rhs>\n\tfriend constexpr auto\n\toperator|(_Lhs&& __lhs, _Rhs&& __rhs);\n    };\n\n  // The base class of every range adaptor non-closure.\n  //\n  // The static data member _Derived::_S_arity must contain the total number of\n  // arguments that the adaptor takes, and the class _Derived must introduce\n  // _RangeAdaptor::operator() into the class scope via a using-declaration.\n  //\n  // The optional static data member _Derived::_S_has_simple_extra_args should\n  // be defined to true if the behavior of this adaptor is independent of the\n  // constness/value category of the extra arguments.  This data member could\n  // also be defined as a variable template parameterized by the types of the\n  // extra arguments.\n  template<typename _Derived>\n    struct _RangeAdaptor\n    {\n      // Partially apply the arguments __args to the range adaptor _Derived,\n      // returning a range adaptor closure object.\n      template<typename... _Args>\n\trequires __adaptor_partial_app_viable<_Derived, _Args...>\n\tconstexpr auto\n\toperator()(_Args&&... __args) const\n\t{\n\t  return _Partial<_Derived, decay_t<_Args>...>{0, std::forward<_Args>(__args)...};\n\t}\n    };\n\n  // True if the range adaptor closure _Adaptor has a simple operator(), i.e.\n  // one that's not overloaded according to constness or value category of the\n  // _Adaptor object.\n  template<typename _Adaptor>\n    concept __closure_has_simple_call_op = _Adaptor::_S_has_simple_call_op;\n\n  // True if the behavior of the range adaptor non-closure _Adaptor is\n  // independent of the value category of its extra arguments _Args.\n  template<typename _Adaptor, typename... _Args>\n    concept __adaptor_has_simple_extra_args = _Adaptor::_S_has_simple_extra_args\n      || _Adaptor::template _S_has_simple_extra_args<_Args...>;\n\n  // A range adaptor closure that represents partial application of\n  // the range adaptor _Adaptor with arguments _Args.\n  template<typename _Adaptor, typename... _Args>\n    struct _Partial : _RangeAdaptorClosure<_Partial<_Adaptor, _Args...>>\n    {\n      tuple<_Args...> _M_args;\n\n      // First parameter is to ensure this constructor is never used\n      // instead of the copy/move constructor.\n      template<typename... _Ts>\n\tconstexpr\n\t_Partial(int, _Ts&&... __args)\n\t  : _M_args(std::forward<_Ts>(__args)...)\n\t{ }\n\n      // Invoke _Adaptor with arguments __r, _M_args... according to the\n      // value category of this _Partial object.\n#if __cpp_explicit_this_parameter\n      template<typename _Self, typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, __like_t<_Self, _Args>...>\n\tconstexpr auto\n\toperator()(this _Self&& __self, _Range&& __r)\n\t{\n\t  auto __forwarder = [&__r] (auto&&... __args) {\n\t    return _Adaptor{}(std::forward<_Range>(__r),\n\t\t\t      std::forward<decltype(__args)>(__args)...);\n\t  };\n\t  return std::apply(__forwarder, __like_t<_Self, _Partial>(__self)._M_args);\n\t}\n#else\n      template<typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, const _Args&...>\n\tconstexpr auto\n\toperator()(_Range&& __r) const &\n\t{\n\t  auto __forwarder = [&__r] (const auto&... __args) {\n\t    return _Adaptor{}(std::forward<_Range>(__r), __args...);\n\t  };\n\t  return std::apply(__forwarder, _M_args);\n\t}\n\n      template<typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, _Args...>\n\tconstexpr auto\n\toperator()(_Range&& __r) &&\n\t{\n\t  auto __forwarder = [&__r] (auto&... __args) {\n\t    return _Adaptor{}(std::forward<_Range>(__r), std::move(__args)...);\n\t  };\n\t  return std::apply(__forwarder, _M_args);\n\t}\n\n      template<typename _Range>\n\tconstexpr auto\n\toperator()(_Range&& __r) const && = delete;\n#endif\n    };\n\n  // A lightweight specialization of the above primary template for\n  // the common case where _Adaptor accepts a single extra argument.\n  template<typename _Adaptor, typename _Arg>\n    struct _Partial<_Adaptor, _Arg> : _RangeAdaptorClosure<_Partial<_Adaptor, _Arg>>\n    {\n      _Arg _M_arg;\n\n      template<typename _Tp>\n\tconstexpr\n\t_Partial(int, _Tp&& __arg)\n\t  : _M_arg(std::forward<_Tp>(__arg))\n\t{ }\n\n#if __cpp_explicit_this_parameter\n      template<typename _Self, typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, __like_t<_Self, _Arg>>\n\tconstexpr auto\n\toperator()(this _Self&& __self, _Range&& __r)\n\t{\n\t  return _Adaptor{}(std::forward<_Range>(__r),\n\t\t\t    __like_t<_Self, _Partial>(__self)._M_arg);\n\t}\n#else\n      template<typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, const _Arg&>\n\tconstexpr auto\n\toperator()(_Range&& __r) const &\n\t{ return _Adaptor{}(std::forward<_Range>(__r), _M_arg); }\n\n      template<typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, _Arg>\n\tconstexpr auto\n\toperator()(_Range&& __r) &&\n\t{ return _Adaptor{}(std::forward<_Range>(__r), std::move(_M_arg)); }\n\n      template<typename _Range>\n\tconstexpr auto\n\toperator()(_Range&& __r) const && = delete;\n#endif\n    };\n\n  // Partial specialization of the primary template for the case where the extra\n  // arguments of the adaptor can always be safely and efficiently forwarded by\n  // const reference.  This lets us get away with a single operator() overload,\n  // which makes overload resolution failure diagnostics more concise.\n  template<typename _Adaptor, typename... _Args>\n    requires __adaptor_has_simple_extra_args<_Adaptor, _Args...>\n      && (is_trivially_copy_constructible_v<_Args> && ...)\n    struct _Partial<_Adaptor, _Args...> : _RangeAdaptorClosure<_Partial<_Adaptor, _Args...>>\n    {\n      tuple<_Args...> _M_args;\n\n      template<typename... _Ts>\n\tconstexpr\n\t_Partial(int, _Ts&&... __args)\n\t  : _M_args(std::forward<_Ts>(__args)...)\n\t{ }\n\n      // Invoke _Adaptor with arguments __r, const _M_args&... regardless\n      // of the value category of this _Partial object.\n      template<typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, const _Args&...>\n\tconstexpr auto\n\toperator()(_Range&& __r) const\n\t{\n\t  auto __forwarder = [&__r] (const auto&... __args) {\n\t    return _Adaptor{}(std::forward<_Range>(__r), __args...);\n\t  };\n\t  return std::apply(__forwarder, _M_args);\n\t}\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n  // A lightweight specialization of the above template for the common case\n  // where _Adaptor accepts a single extra argument.\n  template<typename _Adaptor, typename _Arg>\n    requires __adaptor_has_simple_extra_args<_Adaptor, _Arg>\n      && is_trivially_copy_constructible_v<_Arg>\n    struct _Partial<_Adaptor, _Arg> : _RangeAdaptorClosure<_Partial<_Adaptor, _Arg>>\n    {\n      _Arg _M_arg;\n\n      template<typename _Tp>\n\tconstexpr\n\t_Partial(int, _Tp&& __arg)\n\t  : _M_arg(std::forward<_Tp>(__arg))\n\t{ }\n\n      template<typename _Range>\n\trequires __adaptor_invocable<_Adaptor, _Range, const _Arg&>\n\tconstexpr auto\n\toperator()(_Range&& __r) const\n\t{ return _Adaptor{}(std::forward<_Range>(__r), _M_arg); }\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n  template<typename _Lhs, typename _Rhs, typename _Range>\n    concept __pipe_invocable\n      = requires { std::declval<_Rhs>()(std::declval<_Lhs>()(std::declval<_Range>())); };\n\n  // A range adaptor closure that represents composition of the range\n  // adaptor closures _Lhs and _Rhs.\n  template<typename _Lhs, typename _Rhs>\n    struct _Pipe : _RangeAdaptorClosure<_Pipe<_Lhs, _Rhs>>\n    {\n      [[no_unique_address]] _Lhs _M_lhs;\n      [[no_unique_address]] _Rhs _M_rhs;\n\n      template<typename _Tp, typename _Up>\n\tconstexpr\n\t_Pipe(_Tp&& __lhs, _Up&& __rhs)\n\t  : _M_lhs(std::forward<_Tp>(__lhs)), _M_rhs(std::forward<_Up>(__rhs))\n\t{ }\n\n      // Invoke _M_rhs(_M_lhs(__r)) according to the value category of this\n      // range adaptor closure object.\n#if __cpp_explicit_this_parameter\n      template<typename _Self, typename _Range>\n\trequires __pipe_invocable<__like_t<_Self, _Lhs>, __like_t<_Self, _Rhs>, _Range>\n\tconstexpr auto\n\toperator()(this _Self&& __self, _Range&& __r)\n\t{\n\t  return (__like_t<_Self, _Pipe>(__self)._M_rhs\n\t\t  (__like_t<_Self, _Pipe>(__self)._M_lhs\n\t\t   (std::forward<_Range>(__r))));\n\t}\n#else\n      template<typename _Range>\n\trequires __pipe_invocable<const _Lhs&, const _Rhs&, _Range>\n\tconstexpr auto\n\toperator()(_Range&& __r) const &\n\t{ return _M_rhs(_M_lhs(std::forward<_Range>(__r))); }\n\n      template<typename _Range>\n\trequires __pipe_invocable<_Lhs, _Rhs, _Range>\n\tconstexpr auto\n\toperator()(_Range&& __r) &&\n\t{ return std::move(_M_rhs)(std::move(_M_lhs)(std::forward<_Range>(__r))); }\n\n      template<typename _Range>\n\tconstexpr auto\n\toperator()(_Range&& __r) const && = delete;\n#endif\n    };\n\n  // A partial specialization of the above primary template for the case where\n  // both adaptor operands have a simple operator().  This in turn lets us\n  // implement composition using a single simple operator(), which makes\n  // overload resolution failure diagnostics more concise.\n  template<typename _Lhs, typename _Rhs>\n    requires __closure_has_simple_call_op<_Lhs>\n      && __closure_has_simple_call_op<_Rhs>\n    struct _Pipe<_Lhs, _Rhs> : _RangeAdaptorClosure<_Pipe<_Lhs, _Rhs>>\n    {\n      [[no_unique_address]] _Lhs _M_lhs;\n      [[no_unique_address]] _Rhs _M_rhs;\n\n      template<typename _Tp, typename _Up>\n\tconstexpr\n\t_Pipe(_Tp&& __lhs, _Up&& __rhs)\n\t  : _M_lhs(std::forward<_Tp>(__lhs)), _M_rhs(std::forward<_Up>(__rhs))\n\t{ }\n\n      template<typename _Range>\n\trequires __pipe_invocable<const _Lhs&, const _Rhs&, _Range>\n\tconstexpr auto\n\toperator()(_Range&& __r) const\n\t{ return _M_rhs(_M_lhs(std::forward<_Range>(__r))); }\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n} // namespace views::__adaptor\n\n#if __cpp_lib_ranges >= 202202L\n  // P2387R3 Pipe support for user-defined range adaptors\n  template<typename _Derived>\n    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>\n    class range_adaptor_closure\n    : public views::__adaptor::_RangeAdaptorClosure<_Derived>\n    { };\n#endif\n\n  template<range _Range> requires is_object_v<_Range>\n    class ref_view : public view_interface<ref_view<_Range>>\n    {\n    private:\n      _Range* _M_r;\n\n      static void _S_fun(_Range&); // not defined\n      static void _S_fun(_Range&&) = delete;\n\n    public:\n      template<__detail::__different_from<ref_view> _Tp>\n\trequires convertible_to<_Tp, _Range&>\n\t  && requires { _S_fun(declval<_Tp>()); }\n\tconstexpr\n\tref_view(_Tp&& __t)\n\tnoexcept(noexcept(static_cast<_Range&>(std::declval<_Tp>())))\n\t  : _M_r(std::__addressof(static_cast<_Range&>(std::forward<_Tp>(__t))))\n\t{ }\n\n      constexpr _Range&\n      base() const\n      { return *_M_r; }\n\n      constexpr iterator_t<_Range>\n      begin() const\n      { return ranges::begin(*_M_r); }\n\n      constexpr sentinel_t<_Range>\n      end() const\n      { return ranges::end(*_M_r); }\n\n      constexpr bool\n      empty() const requires requires { ranges::empty(*_M_r); }\n      { return ranges::empty(*_M_r); }\n\n      constexpr auto\n      size() const requires sized_range<_Range>\n      { return ranges::size(*_M_r); }\n\n      constexpr auto\n      data() const requires contiguous_range<_Range>\n      { return ranges::data(*_M_r); }\n    };\n\n  template<typename _Range>\n    ref_view(_Range&) -> ref_view<_Range>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<ref_view<_Tp>> = true;\n\n  template<range _Range>\n    requires movable<_Range>\n      && (!__detail::__is_initializer_list<remove_cv_t<_Range>>)\n    class owning_view : public view_interface<owning_view<_Range>>\n    {\n    private:\n      _Range _M_r = _Range();\n\n    public:\n      owning_view() requires default_initializable<_Range> = default;\n\n      constexpr\n      owning_view(_Range&& __t)\n      noexcept(is_nothrow_move_constructible_v<_Range>)\n\t: _M_r(std::move(__t))\n      { }\n\n      owning_view(owning_view&&) = default;\n      owning_view& operator=(owning_view&&) = default;\n\n      constexpr _Range&\n      base() & noexcept\n      { return _M_r; }\n\n      constexpr const _Range&\n      base() const& noexcept\n      { return _M_r; }\n\n      constexpr _Range&&\n      base() && noexcept\n      { return std::move(_M_r); }\n\n      constexpr const _Range&&\n      base() const&& noexcept\n      { return std::move(_M_r); }\n\n      constexpr iterator_t<_Range>\n      begin()\n      { return ranges::begin(_M_r); }\n\n      constexpr sentinel_t<_Range>\n      end()\n      { return ranges::end(_M_r); }\n\n      constexpr auto\n      begin() const requires range<const _Range>\n      { return ranges::begin(_M_r); }\n\n      constexpr auto\n      end() const requires range<const _Range>\n      { return ranges::end(_M_r); }\n\n      constexpr bool\n      empty() requires requires { ranges::empty(_M_r); }\n      { return ranges::empty(_M_r); }\n\n      constexpr bool\n      empty() const requires requires { ranges::empty(_M_r); }\n      { return ranges::empty(_M_r); }\n\n      constexpr auto\n      size() requires sized_range<_Range>\n      { return ranges::size(_M_r); }\n\n      constexpr auto\n      size() const requires sized_range<const _Range>\n      { return ranges::size(_M_r); }\n\n      constexpr auto\n      data() requires contiguous_range<_Range>\n      { return ranges::data(_M_r); }\n\n      constexpr auto\n      data() const requires contiguous_range<const _Range>\n      { return ranges::data(_M_r); }\n    };\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<owning_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range>\n\tconcept __can_ref_view = requires { ref_view{std::declval<_Range>()}; };\n\n      template<typename _Range>\n\tconcept __can_owning_view = requires { owning_view{std::declval<_Range>()}; };\n    } // namespace __detail\n\n    struct _All : __adaptor::_RangeAdaptorClosure<_All>\n    {\n      template<typename _Range>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (view<decay_t<_Range>>)\n\t    return is_nothrow_constructible_v<decay_t<_Range>, _Range>;\n\t  else if constexpr (__detail::__can_ref_view<_Range>)\n\t    return true;\n\t  else\n\t    return noexcept(owning_view{std::declval<_Range>()});\n\t}\n\n      template<viewable_range _Range>\n\trequires view<decay_t<_Range>>\n\t  || __detail::__can_ref_view<_Range>\n\t  || __detail::__can_owning_view<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\tnoexcept(_S_noexcept<_Range>())\n\t{\n\t  if constexpr (view<decay_t<_Range>>)\n\t    return std::forward<_Range>(__r);\n\t  else if constexpr (__detail::__can_ref_view<_Range>)\n\t    return ref_view{std::forward<_Range>(__r)};\n\t  else\n\t    return owning_view{std::forward<_Range>(__r)};\n\t}\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n    inline constexpr _All all;\n\n    template<viewable_range _Range>\n      using all_t = decltype(all(std::declval<_Range>()));\n  } // namespace views\n\n  namespace __detail\n  {\n    template<typename _Tp>\n      struct __non_propagating_cache\n      {\n\t// When _Tp is not an object type (e.g. is a reference type), we make\n\t// __non_propagating_cache<_Tp> empty rather than ill-formed so that\n\t// users can easily conditionally declare data members with this type\n\t// (such as join_view::_M_inner).\n      };\n\n    template<typename _Tp>\n      requires is_object_v<_Tp>\n      struct __non_propagating_cache<_Tp>\n      : protected _Optional_base<_Tp>\n      {\n\t__non_propagating_cache() = default;\n\n\tconstexpr\n\t__non_propagating_cache(const __non_propagating_cache&) noexcept\n\t{ }\n\n\tconstexpr\n\t__non_propagating_cache(__non_propagating_cache&& __other) noexcept\n\t{ __other._M_reset(); }\n\n\tconstexpr __non_propagating_cache&\n\toperator=(const __non_propagating_cache& __other) noexcept\n\t{\n\t  if (std::__addressof(__other) != this)\n\t    this->_M_reset();\n\t  return *this;\n\t}\n\n\tconstexpr __non_propagating_cache&\n\toperator=(__non_propagating_cache&& __other) noexcept\n\t{\n\t  this->_M_reset();\n\t  __other._M_reset();\n\t  return *this;\n\t}\n\n\tconstexpr __non_propagating_cache&\n\toperator=(_Tp __val)\n\t{\n\t  this->_M_reset();\n\t  this->_M_payload._M_construct(std::move(__val));\n\t  return *this;\n\t}\n\n\tconstexpr explicit\n\toperator bool() const noexcept\n\t{ return this->_M_is_engaged(); }\n\n\tconstexpr _Tp&\n\toperator*() noexcept\n\t{ return this->_M_get(); }\n\n\tconstexpr const _Tp&\n\toperator*() const noexcept\n\t{ return this->_M_get(); }\n\n\ttemplate<typename _Iter>\n\t  constexpr _Tp&\n\t  _M_emplace_deref(const _Iter& __i)\n\t  {\n\t    this->_M_reset();\n\t    auto __f = [] (auto& __x) { return *__x; };\n\t    this->_M_payload._M_apply(_Optional_func{__f}, __i);\n\t    return this->_M_get();\n\t  }\n\n\tusing _Optional_base<_Tp>::_M_reset;\n      };\n\n    template<range _Range>\n      struct _CachedPosition\n      {\n\tconstexpr bool\n\t_M_has_value() const\n\t{ return false; }\n\n\tconstexpr iterator_t<_Range>\n\t_M_get(const _Range&) const\n\t{\n\t  __glibcxx_assert(false);\n\t  __builtin_unreachable();\n\t}\n\n\tconstexpr void\n\t_M_set(const _Range&, const iterator_t<_Range>&) const\n\t{ }\n      };\n\n    template<forward_range _Range>\n      struct _CachedPosition<_Range>\n\t: protected __non_propagating_cache<iterator_t<_Range>>\n      {\n\tconstexpr bool\n\t_M_has_value() const\n\t{ return this->_M_is_engaged(); }\n\n\tconstexpr iterator_t<_Range>\n\t_M_get(const _Range&) const\n\t{\n\t  __glibcxx_assert(_M_has_value());\n\t  return **this;\n\t}\n\n\tconstexpr void\n\t_M_set(const _Range&, const iterator_t<_Range>& __it)\n\t{\n\t  __glibcxx_assert(!_M_has_value());\n\t  std::construct_at(std::__addressof(this->_M_payload._M_payload),\n\t\t\t    in_place, __it);\n\t  this->_M_payload._M_engaged = true;\n\t}\n      };\n\n    template<random_access_range _Range>\n      requires (sizeof(range_difference_t<_Range>)\n\t\t<= sizeof(iterator_t<_Range>))\n      struct _CachedPosition<_Range>\n      {\n      private:\n\trange_difference_t<_Range> _M_offset = -1;\n\n      public:\n\t_CachedPosition() = default;\n\n\tconstexpr\n\t_CachedPosition(const _CachedPosition&) = default;\n\n\tconstexpr\n\t_CachedPosition(_CachedPosition&& __other) noexcept\n\t{ *this = std::move(__other); }\n\n\tconstexpr _CachedPosition&\n\toperator=(const _CachedPosition&) = default;\n\n\tconstexpr _CachedPosition&\n\toperator=(_CachedPosition&& __other) noexcept\n\t{\n\t  // Propagate the cached offset, but invalidate the source.\n\t  _M_offset = __other._M_offset;\n\t  __other._M_offset = -1;\n\t  return *this;\n\t}\n\n\tconstexpr bool\n\t_M_has_value() const\n\t{ return _M_offset >= 0; }\n\n\tconstexpr iterator_t<_Range>\n\t_M_get(_Range& __r) const\n\t{\n\t  __glibcxx_assert(_M_has_value());\n\t  return ranges::begin(__r) + _M_offset;\n\t}\n\n\tconstexpr void\n\t_M_set(_Range& __r, const iterator_t<_Range>& __it)\n\t{\n\t  __glibcxx_assert(!_M_has_value());\n\t  _M_offset = __it - ranges::begin(__r);\n\t}\n      };\n  } // namespace __detail\n\n  namespace __detail\n  {\n    template<typename _Base>\n      struct __filter_view_iter_cat\n      { };\n\n    template<forward_range _Base>\n      struct __filter_view_iter_cat<_Base>\n      {\n      private:\n\tstatic auto\n\t_S_iter_cat()\n\t{\n\t  using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n\t  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)\n\t    return bidirectional_iterator_tag{};\n\t  else if constexpr (derived_from<_Cat, forward_iterator_tag>)\n\t    return forward_iterator_tag{};\n\t  else\n\t    return _Cat{};\n\t}\n      public:\n\tusing iterator_category = decltype(_S_iter_cat());\n      };\n  } // namespace __detail\n\n  template<input_range _Vp,\n\t   indirect_unary_predicate<iterator_t<_Vp>> _Pred>\n    requires view<_Vp> && is_object_v<_Pred>\n    class filter_view : public view_interface<filter_view<_Vp, _Pred>>\n    {\n    private:\n      struct _Sentinel;\n\n      struct _Iterator : __detail::__filter_view_iter_cat<_Vp>\n      {\n      private:\n\tstatic constexpr auto\n\t_S_iter_concept()\n\t{\n\t  if constexpr (bidirectional_range<_Vp>)\n\t    return bidirectional_iterator_tag{};\n\t  else if constexpr (forward_range<_Vp>)\n\t    return forward_iterator_tag{};\n\t  else\n\t    return input_iterator_tag{};\n\t}\n\n\tfriend filter_view;\n\n\tusing _Vp_iter = iterator_t<_Vp>;\n\n\t_Vp_iter _M_current = _Vp_iter();\n\tfilter_view* _M_parent = nullptr;\n\n      public:\n\tusing iterator_concept = decltype(_S_iter_concept());\n\t// iterator_category defined in __filter_view_iter_cat\n\tusing value_type = range_value_t<_Vp>;\n\tusing difference_type = range_difference_t<_Vp>;\n\n\t_Iterator() requires default_initializable<_Vp_iter> = default;\n\n\tconstexpr\n\t_Iterator(filter_view* __parent, _Vp_iter __current)\n\t  : _M_current(std::move(__current)),\n\t    _M_parent(__parent)\n\t{ }\n\n\tconstexpr const _Vp_iter&\n\tbase() const & noexcept\n\t{ return _M_current; }\n\n\tconstexpr _Vp_iter\n\tbase() &&\n\t{ return std::move(_M_current); }\n\n\tconstexpr range_reference_t<_Vp>\n\toperator*() const\n\t{ return *_M_current; }\n\n\tconstexpr _Vp_iter\n\toperator->() const\n\t  requires __detail::__has_arrow<_Vp_iter>\n\t    && copyable<_Vp_iter>\n\t{ return _M_current; }\n\n\tconstexpr _Iterator&\n\toperator++()\n\t{\n\t  _M_current = ranges::find_if(std::move(++_M_current),\n\t\t\t\t       ranges::end(_M_parent->_M_base),\n\t\t\t\t       std::ref(*_M_parent->_M_pred));\n\t  return *this;\n\t}\n\n\tconstexpr void\n\toperator++(int)\n\t{ ++*this; }\n\n\tconstexpr _Iterator\n\toperator++(int) requires forward_range<_Vp>\n\t{\n\t  auto __tmp = *this;\n\t  ++*this;\n\t  return __tmp;\n\t}\n\n\tconstexpr _Iterator&\n\toperator--() requires bidirectional_range<_Vp>\n\t{\n\t  do\n\t    --_M_current;\n\t  while (!std::__invoke(*_M_parent->_M_pred, *_M_current));\n\t  return *this;\n\t}\n\n\tconstexpr _Iterator\n\toperator--(int) requires bidirectional_range<_Vp>\n\t{\n\t  auto __tmp = *this;\n\t  --*this;\n\t  return __tmp;\n\t}\n\n\tfriend constexpr bool\n\toperator==(const _Iterator& __x, const _Iterator& __y)\n\t  requires equality_comparable<_Vp_iter>\n\t{ return __x._M_current == __y._M_current; }\n\n\tfriend constexpr range_rvalue_reference_t<_Vp>\n\titer_move(const _Iterator& __i)\n\t  noexcept(noexcept(ranges::iter_move(__i._M_current)))\n\t{ return ranges::iter_move(__i._M_current); }\n\n\tfriend constexpr void\n\titer_swap(const _Iterator& __x, const _Iterator& __y)\n\t  noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n\t  requires indirectly_swappable<_Vp_iter>\n\t{ ranges::iter_swap(__x._M_current, __y._M_current); }\n      };\n\n      struct _Sentinel\n      {\n      private:\n\tsentinel_t<_Vp> _M_end = sentinel_t<_Vp>();\n\n\tconstexpr bool\n\t__equal(const _Iterator& __i) const\n\t{ return __i._M_current == _M_end; }\n\n      public:\n\t_Sentinel() = default;\n\n\tconstexpr explicit\n\t_Sentinel(filter_view* __parent)\n\t  : _M_end(ranges::end(__parent->_M_base))\n\t{ }\n\n\tconstexpr sentinel_t<_Vp>\n\tbase() const\n\t{ return _M_end; }\n\n\tfriend constexpr bool\n\toperator==(const _Iterator& __x, const _Sentinel& __y)\n\t{ return __y.__equal(__x); }\n      };\n\n      _Vp _M_base = _Vp();\n      [[no_unique_address]] __detail::__box<_Pred> _M_pred;\n      [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;\n\n    public:\n      filter_view() requires (default_initializable<_Vp>\n\t\t\t      && default_initializable<_Pred>)\n\t= default;\n\n      constexpr\n      filter_view(_Vp __base, _Pred __pred)\n\t: _M_base(std::move(__base)), _M_pred(std::move(__pred))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr const _Pred&\n      pred() const\n      { return *_M_pred; }\n\n      constexpr _Iterator\n      begin()\n      {\n\tif (_M_cached_begin._M_has_value())\n\t  return {this, _M_cached_begin._M_get(_M_base)};\n\n\t__glibcxx_assert(_M_pred.has_value());\n\tauto __it = ranges::find_if(ranges::begin(_M_base),\n\t\t\t\t    ranges::end(_M_base),\n\t\t\t\t    std::ref(*_M_pred));\n\t_M_cached_begin._M_set(_M_base, __it);\n\treturn {this, std::move(__it)};\n      }\n\n      constexpr auto\n      end()\n      {\n\tif constexpr (common_range<_Vp>)\n\t  return _Iterator{this, ranges::end(_M_base)};\n\telse\n\t  return _Sentinel{this};\n      }\n    };\n\n  template<typename _Range, typename _Pred>\n    filter_view(_Range&&, _Pred) -> filter_view<views::all_t<_Range>, _Pred>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Pred>\n\tconcept __can_filter_view\n\t  = requires { filter_view(std::declval<_Range>(), std::declval<_Pred>()); };\n    } // namespace __detail\n\n    struct _Filter : __adaptor::_RangeAdaptor<_Filter>\n    {\n      template<viewable_range _Range, typename _Pred>\n\trequires __detail::__can_filter_view<_Range, _Pred>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Pred&& __p) const\n\t{\n\t  return filter_view(std::forward<_Range>(__r), std::forward<_Pred>(__p));\n\t}\n\n      using _RangeAdaptor<_Filter>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _Filter filter;\n  } // namespace views\n\n#if __cpp_lib_ranges >= 202207L // C++ >= 23\n  template<input_range _Vp, move_constructible _Fp>\n#else\n  template<input_range _Vp, copy_constructible _Fp>\n#endif\n    requires view<_Vp> && is_object_v<_Fp>\n      && regular_invocable<_Fp&, range_reference_t<_Vp>>\n      && std::__detail::__can_reference<invoke_result_t<_Fp&,\n\t\t\t\t\t\t\trange_reference_t<_Vp>>>\n    class transform_view : public view_interface<transform_view<_Vp, _Fp>>\n    {\n    private:\n      template<bool _Const>\n\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n      template<bool _Const>\n\tstruct __iter_cat\n\t{ };\n\n      template<bool _Const>\n\trequires forward_range<_Base<_Const>>\n\tstruct __iter_cat<_Const>\n\t{\n\tprivate:\n\t  static auto\n\t  _S_iter_cat()\n\t  {\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3564. transform_view::iterator<true>::value_type and\n\t    // iterator_category should use const F&\n\t    using _Base = transform_view::_Base<_Const>;\n\t    using _Res = invoke_result_t<__maybe_const_t<_Const, _Fp>&,\n\t\t\t\t\t range_reference_t<_Base>>;\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3798. Rvalue reference and iterator_category\n\t    if constexpr (is_reference_v<_Res>)\n\t      {\n\t\tusing _Cat\n\t\t  = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n\t\tif constexpr (derived_from<_Cat, contiguous_iterator_tag>)\n\t\t  return random_access_iterator_tag{};\n\t\telse\n\t\t  return _Cat{};\n\t      }\n\t    else\n\t      return input_iterator_tag{};\n\t  }\n\tpublic:\n\t  using iterator_category = decltype(_S_iter_cat());\n\t};\n\n      template<bool _Const>\n\tstruct _Sentinel;\n\n      template<bool _Const>\n\tstruct _Iterator : __iter_cat<_Const>\n\t{\n\tprivate:\n\t  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;\n\t  using _Base = transform_view::_Base<_Const>;\n\n\t  static auto\n\t  _S_iter_concept()\n\t  {\n\t    if constexpr (random_access_range<_Base>)\n\t      return random_access_iterator_tag{};\n\t    else if constexpr (bidirectional_range<_Base>)\n\t      return bidirectional_iterator_tag{};\n\t    else if constexpr (forward_range<_Base>)\n\t      return forward_iterator_tag{};\n\t    else\n\t      return input_iterator_tag{};\n\t  }\n\n\t  using _Base_iter = iterator_t<_Base>;\n\n\t  _Base_iter _M_current = _Base_iter();\n\t  _Parent* _M_parent = nullptr;\n\n\tpublic:\n\t  using iterator_concept = decltype(_S_iter_concept());\n\t  // iterator_category defined in __transform_view_iter_cat\n\t  using value_type\n\t    = remove_cvref_t<invoke_result_t<__maybe_const_t<_Const, _Fp>&,\n\t\t\t\t\t     range_reference_t<_Base>>>;\n\t  using difference_type = range_difference_t<_Base>;\n\n\t  _Iterator() requires default_initializable<_Base_iter> = default;\n\n\t  constexpr\n\t  _Iterator(_Parent* __parent, _Base_iter __current)\n\t    : _M_current(std::move(__current)),\n\t      _M_parent(__parent)\n\t  { }\n\n\t  constexpr\n\t  _Iterator(_Iterator<!_Const> __i)\n\t    requires _Const\n\t      && convertible_to<iterator_t<_Vp>, _Base_iter>\n\t    : _M_current(std::move(__i._M_current)), _M_parent(__i._M_parent)\n\t  { }\n\n\t  constexpr const _Base_iter&\n\t  base() const & noexcept\n\t  { return _M_current; }\n\n\t  constexpr _Base_iter\n\t  base() &&\n\t  { return std::move(_M_current); }\n\n\t  constexpr decltype(auto)\n\t  operator*() const\n\t    noexcept(noexcept(std::__invoke(*_M_parent->_M_fun, *_M_current)))\n\t  { return std::__invoke(*_M_parent->_M_fun, *_M_current); }\n\n\t  constexpr _Iterator&\n\t  operator++()\n\t  {\n\t    ++_M_current;\n\t    return *this;\n\t  }\n\n\t  constexpr void\n\t  operator++(int)\n\t  { ++_M_current; }\n\n\t  constexpr _Iterator\n\t  operator++(int) requires forward_range<_Base>\n\t  {\n\t    auto __tmp = *this;\n\t    ++*this;\n\t    return __tmp;\n\t  }\n\n\t  constexpr _Iterator&\n\t  operator--() requires bidirectional_range<_Base>\n\t  {\n\t    --_M_current;\n\t    return *this;\n\t  }\n\n\t  constexpr _Iterator\n\t  operator--(int) requires bidirectional_range<_Base>\n\t  {\n\t    auto __tmp = *this;\n\t    --*this;\n\t    return __tmp;\n\t  }\n\n\t  constexpr _Iterator&\n\t  operator+=(difference_type __n) requires random_access_range<_Base>\n\t  {\n\t    _M_current += __n;\n\t    return *this;\n\t  }\n\n\t  constexpr _Iterator&\n\t  operator-=(difference_type __n) requires random_access_range<_Base>\n\t  {\n\t    _M_current -= __n;\n\t    return *this;\n\t  }\n\n\t  constexpr decltype(auto)\n\t  operator[](difference_type __n) const\n\t    requires random_access_range<_Base>\n\t  { return std::__invoke(*_M_parent->_M_fun, _M_current[__n]); }\n\n\t  friend constexpr bool\n\t  operator==(const _Iterator& __x, const _Iterator& __y)\n\t    requires equality_comparable<_Base_iter>\n\t  { return __x._M_current == __y._M_current; }\n\n\t  friend constexpr bool\n\t  operator<(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return __x._M_current < __y._M_current; }\n\n\t  friend constexpr bool\n\t  operator>(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return __y < __x; }\n\n\t  friend constexpr bool\n\t  operator<=(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return !(__y < __x); }\n\n\t  friend constexpr bool\n\t  operator>=(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return !(__x < __y); }\n\n#ifdef __cpp_lib_three_way_comparison\n\t  friend constexpr auto\n\t  operator<=>(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t      && three_way_comparable<_Base_iter>\n\t  { return __x._M_current <=> __y._M_current; }\n#endif\n\n\t  friend constexpr _Iterator\n\t  operator+(_Iterator __i, difference_type __n)\n\t    requires random_access_range<_Base>\n\t  { return {__i._M_parent, __i._M_current + __n}; }\n\n\t  friend constexpr _Iterator\n\t  operator+(difference_type __n, _Iterator __i)\n\t    requires random_access_range<_Base>\n\t  { return {__i._M_parent, __i._M_current + __n}; }\n\n\t  friend constexpr _Iterator\n\t  operator-(_Iterator __i, difference_type __n)\n\t    requires random_access_range<_Base>\n\t  { return {__i._M_parent, __i._M_current - __n}; }\n\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3483. transform_view::iterator's difference is overconstrained\n\t  friend constexpr difference_type\n\t  operator-(const _Iterator& __x, const _Iterator& __y)\n\t    requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n\t  { return __x._M_current - __y._M_current; }\n\n\t  friend constexpr decltype(auto)\n\t  iter_move(const _Iterator& __i) noexcept(noexcept(*__i))\n\t  {\n\t    if constexpr (is_lvalue_reference_v<decltype(*__i)>)\n\t      return std::move(*__i);\n\t    else\n\t      return *__i;\n\t  }\n\n\t  friend _Iterator<!_Const>;\n\t  template<bool> friend struct _Sentinel;\n\t};\n\n      template<bool _Const>\n\tstruct _Sentinel\n\t{\n\tprivate:\n\t  using _Parent = __detail::__maybe_const_t<_Const, transform_view>;\n\t  using _Base = transform_view::_Base<_Const>;\n\n\t  template<bool _Const2>\n\t    constexpr auto\n\t    __distance_from(const _Iterator<_Const2>& __i) const\n\t    { return _M_end - __i._M_current; }\n\n\t  template<bool _Const2>\n\t    constexpr bool\n\t    __equal(const _Iterator<_Const2>& __i) const\n\t    { return __i._M_current == _M_end; }\n\n\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\n\tpublic:\n\t  _Sentinel() = default;\n\n\t  constexpr explicit\n\t  _Sentinel(sentinel_t<_Base> __end)\n\t    : _M_end(__end)\n\t  { }\n\n\t  constexpr\n\t  _Sentinel(_Sentinel<!_Const> __i)\n\t    requires _Const\n\t      && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n\t    : _M_end(std::move(__i._M_end))\n\t  { }\n\n\t  constexpr sentinel_t<_Base>\n\t  base() const\n\t  { return _M_end; }\n\n\t  template<bool _Const2>\n\t    requires sentinel_for<sentinel_t<_Base>,\n\t\t       iterator_t<__detail::__maybe_const_t<_Const2, _Vp>>>\n\t    friend constexpr bool\n\t    operator==(const _Iterator<_Const2>& __x, const _Sentinel& __y)\n\t    { return __y.__equal(__x); }\n\n\t  template<bool _Const2,\n\t\t   typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>\n\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>\n\t    friend constexpr range_difference_t<_Base2>\n\t    operator-(const _Iterator<_Const2>& __x, const _Sentinel& __y)\n\t    { return -__y.__distance_from(__x); }\n\n\t  template<bool _Const2,\n\t\t   typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>\n\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>\n\t    friend constexpr range_difference_t<_Base2>\n\t    operator-(const _Sentinel& __y, const _Iterator<_Const2>& __x)\n\t    { return __y.__distance_from(__x); }\n\n\t  friend _Sentinel<!_Const>;\n\t};\n\n      _Vp _M_base = _Vp();\n      [[no_unique_address]] __detail::__box<_Fp> _M_fun;\n\n    public:\n      transform_view() requires (default_initializable<_Vp>\n\t\t\t\t && default_initializable<_Fp>)\n\t= default;\n\n      constexpr\n      transform_view(_Vp __base, _Fp __fun)\n\t: _M_base(std::move(__base)), _M_fun(std::move(__fun))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base ; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr _Iterator<false>\n      begin()\n      { return _Iterator<false>{this, ranges::begin(_M_base)}; }\n\n      constexpr _Iterator<true>\n      begin() const\n\trequires range<const _Vp>\n\t  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>\n      { return _Iterator<true>{this, ranges::begin(_M_base)}; }\n\n      constexpr _Sentinel<false>\n      end()\n      { return _Sentinel<false>{ranges::end(_M_base)}; }\n\n      constexpr _Iterator<false>\n      end() requires common_range<_Vp>\n      { return _Iterator<false>{this, ranges::end(_M_base)}; }\n\n      constexpr _Sentinel<true>\n      end() const\n\trequires range<const _Vp>\n\t  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>\n      { return _Sentinel<true>{ranges::end(_M_base)}; }\n\n      constexpr _Iterator<true>\n      end() const\n\trequires common_range<const _Vp>\n\t  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>\n      { return _Iterator<true>{this, ranges::end(_M_base)}; }\n\n      constexpr auto\n      size() requires sized_range<_Vp>\n      { return ranges::size(_M_base); }\n\n      constexpr auto\n      size() const requires sized_range<const _Vp>\n      { return ranges::size(_M_base); }\n    };\n\n  template<typename _Range, typename _Fp>\n    transform_view(_Range&&, _Fp) -> transform_view<views::all_t<_Range>, _Fp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Fp>\n\tconcept __can_transform_view\n\t  = requires { transform_view(std::declval<_Range>(), std::declval<_Fp>()); };\n    } // namespace __detail\n\n    struct _Transform : __adaptor::_RangeAdaptor<_Transform>\n    {\n      template<viewable_range _Range, typename _Fp>\n\trequires __detail::__can_transform_view<_Range, _Fp>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Fp&& __f) const\n\t{\n\t  return transform_view(std::forward<_Range>(__r), std::forward<_Fp>(__f));\n\t}\n\n      using _RangeAdaptor<_Transform>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _Transform transform;\n  } // namespace views\n\n  template<view _Vp>\n    class take_view : public view_interface<take_view<_Vp>>\n    {\n    private:\n      template<bool _Const>\n\tusing _CI = counted_iterator<\n\t  iterator_t<__detail::__maybe_const_t<_Const, _Vp>>>;\n\n      template<bool _Const>\n\tstruct _Sentinel\n\t{\n\tprivate:\n\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\n\tpublic:\n\t  _Sentinel() = default;\n\n\t  constexpr explicit\n\t  _Sentinel(sentinel_t<_Base> __end)\n\t    : _M_end(__end)\n\t  { }\n\n\t  constexpr\n\t  _Sentinel(_Sentinel<!_Const> __s)\n\t    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n\t    : _M_end(std::move(__s._M_end))\n\t  { }\n\n\t  constexpr sentinel_t<_Base>\n\t  base() const\n\t  { return _M_end; }\n\n\t  friend constexpr bool\n\t  operator==(const _CI<_Const>& __y, const _Sentinel& __x)\n\t  { return __y.count() == 0 || __y.base() == __x._M_end; }\n\n\t  template<bool _OtherConst = !_Const,\n\t\t   typename _Base2 = __detail::__maybe_const_t<_OtherConst, _Vp>>\n\t    requires sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>\n\t  friend constexpr bool\n\t  operator==(const _CI<_OtherConst>& __y, const _Sentinel& __x)\n\t  { return __y.count() == 0 || __y.base() == __x._M_end; }\n\n\t  friend _Sentinel<!_Const>;\n\t};\n\n      _Vp _M_base = _Vp();\n      range_difference_t<_Vp> _M_count = 0;\n\n    public:\n      take_view() requires default_initializable<_Vp> = default;\n\n      constexpr\n      take_view(_Vp __base, range_difference_t<_Vp> __count)\n\t: _M_base(std::move(__base)), _M_count(std::move(__count))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr auto\n      begin() requires (!__detail::__simple_view<_Vp>)\n      {\n\tif constexpr (sized_range<_Vp>)\n\t  {\n\t    if constexpr (random_access_range<_Vp>)\n\t      return ranges::begin(_M_base);\n\t    else\n\t      {\n\t\tauto __sz = size();\n\t\treturn counted_iterator(ranges::begin(_M_base), __sz);\n\t      }\n\t  }\n\telse\n\t  return counted_iterator(ranges::begin(_M_base), _M_count);\n      }\n\n      constexpr auto\n      begin() const requires range<const _Vp>\n      {\n\tif constexpr (sized_range<const _Vp>)\n\t  {\n\t    if constexpr (random_access_range<const _Vp>)\n\t      return ranges::begin(_M_base);\n\t    else\n\t      {\n\t\tauto __sz = size();\n\t\treturn counted_iterator(ranges::begin(_M_base), __sz);\n\t      }\n\t  }\n\telse\n\t  return counted_iterator(ranges::begin(_M_base), _M_count);\n      }\n\n      constexpr auto\n      end() requires (!__detail::__simple_view<_Vp>)\n      {\n\tif constexpr (sized_range<_Vp>)\n\t  {\n\t    if constexpr (random_access_range<_Vp>)\n\t      return ranges::begin(_M_base) + size();\n\t    else\n\t      return default_sentinel;\n\t  }\n\telse\n\t  return _Sentinel<false>{ranges::end(_M_base)};\n      }\n\n      constexpr auto\n      end() const requires range<const _Vp>\n      {\n\tif constexpr (sized_range<const _Vp>)\n\t  {\n\t    if constexpr (random_access_range<const _Vp>)\n\t      return ranges::begin(_M_base) + size();\n\t    else\n\t      return default_sentinel;\n\t  }\n\telse\n\t  return _Sentinel<true>{ranges::end(_M_base)};\n      }\n\n      constexpr auto\n      size() requires sized_range<_Vp>\n      {\n\tauto __n = ranges::size(_M_base);\n\treturn std::min(__n, static_cast<decltype(__n)>(_M_count));\n      }\n\n      constexpr auto\n      size() const requires sized_range<const _Vp>\n      {\n\tauto __n = ranges::size(_M_base);\n\treturn std::min(__n, static_cast<decltype(__n)>(_M_count));\n      }\n    };\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 3447. Deduction guides for take_view and drop_view have different\n  // constraints\n  template<typename _Range>\n    take_view(_Range&&, range_difference_t<_Range>)\n      -> take_view<views::all_t<_Range>>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<take_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range>\n\tinline constexpr bool __is_empty_view = false;\n\n      template<typename _Tp>\n\tinline constexpr bool __is_empty_view<empty_view<_Tp>> = true;\n\n      template<typename _Range>\n\tinline constexpr bool __is_basic_string_view = false;\n\n      template<typename _CharT, typename _Traits>\n\tinline constexpr bool __is_basic_string_view<basic_string_view<_CharT, _Traits>>\n\t  = true;\n\n      using ranges::__detail::__is_subrange;\n\n      template<typename _Range>\n\tinline constexpr bool __is_iota_view = false;\n\n      template<typename _Winc, typename _Bound>\n\tinline constexpr bool __is_iota_view<iota_view<_Winc, _Bound>> = true;\n\n      template<typename _Range>\n\tinline constexpr bool __is_repeat_view = false;\n\n      template<typename _Range>\n\tconstexpr auto\n\t__take_of_repeat_view(_Range&&, range_difference_t<_Range>); // defined later\n\n      template<typename _Range, typename _Dp>\n\tconcept __can_take_view\n\t  = requires { take_view(std::declval<_Range>(), std::declval<_Dp>()); };\n    } // namespace __detail\n\n    struct _Take : __adaptor::_RangeAdaptor<_Take>\n    {\n      template<viewable_range _Range, typename _Dp = range_difference_t<_Range>>\n\trequires __detail::__can_take_view<_Range, _Dp>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, type_identity_t<_Dp> __n) const\n\t{\n\t  using _Tp = remove_cvref_t<_Range>;\n\t  if constexpr (__detail::__is_empty_view<_Tp>)\n\t    return _Tp();\n\t  else if constexpr (random_access_range<_Tp>\n\t\t\t     && sized_range<_Tp>\n\t\t\t     && (std::__detail::__is_span<_Tp>\n\t\t\t\t || __detail::__is_basic_string_view<_Tp>\n\t\t\t\t || __detail::__is_subrange<_Tp>\n\t\t\t\t || __detail::__is_iota_view<_Tp>))\n\t    {\n\t      __n = std::min<_Dp>(ranges::distance(__r), __n);\n\t      auto __begin = ranges::begin(__r);\n\t      auto __end = __begin + __n;\n\t      if constexpr (std::__detail::__is_span<_Tp>)\n\t\treturn span<typename _Tp::element_type>(__begin, __end);\n\t      else if constexpr (__detail::__is_basic_string_view<_Tp>)\n\t\treturn _Tp(__begin, __end);\n\t      else if constexpr (__detail::__is_subrange<_Tp>)\n\t\treturn subrange<iterator_t<_Tp>>(__begin, __end);\n\t      else\n\t\treturn iota_view(*__begin, *__end);\n\t    }\n\t  else if constexpr (__detail::__is_repeat_view<_Tp>)\n\t    return __detail::__take_of_repeat_view(std::forward<_Range>(__r), __n);\n\t  else\n\t    return take_view(std::forward<_Range>(__r), __n);\n\t}\n\n      using _RangeAdaptor<_Take>::operator();\n      static constexpr int _S_arity = 2;\n      // The count argument of views::take is not always simple -- it can be\n      // e.g. a move-only class that's implicitly convertible to the difference\n      // type.  But an integer-like count argument is surely simple.\n      template<typename _Tp>\n\tstatic constexpr bool _S_has_simple_extra_args\n\t  = ranges::__detail::__is_integer_like<_Tp>;\n    };\n\n    inline constexpr _Take take;\n  } // namespace views\n\n  template<view _Vp, typename _Pred>\n    requires input_range<_Vp> && is_object_v<_Pred>\n      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>\n    class take_while_view : public view_interface<take_while_view<_Vp, _Pred>>\n    {\n      template<bool _Const>\n\tstruct _Sentinel\n\t{\n\tprivate:\n\t  using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\t  const _Pred* _M_pred = nullptr;\n\n\tpublic:\n\t  _Sentinel() = default;\n\n\t  constexpr explicit\n\t  _Sentinel(sentinel_t<_Base> __end, const _Pred* __pred)\n\t    : _M_end(__end), _M_pred(__pred)\n\t  { }\n\n\t  constexpr\n\t  _Sentinel(_Sentinel<!_Const> __s)\n\t    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n\t    : _M_end(__s._M_end), _M_pred(__s._M_pred)\n\t  { }\n\n\t  constexpr sentinel_t<_Base>\n\t  base() const { return _M_end; }\n\n\t  friend constexpr bool\n\t  operator==(const iterator_t<_Base>& __x, const _Sentinel& __y)\n\t  { return __y._M_end == __x || !std::__invoke(*__y._M_pred, *__x); }\n\n\t  template<bool _OtherConst = !_Const,\n\t\t   typename _Base2 = __detail::__maybe_const_t<_OtherConst, _Vp>>\n\t    requires sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>\n\t  friend constexpr bool\n\t  operator==(const iterator_t<_Base2>& __x, const _Sentinel& __y)\n\t  { return __y._M_end == __x || !std::__invoke(*__y._M_pred, *__x); }\n\n\t  friend _Sentinel<!_Const>;\n\t};\n\n      _Vp _M_base = _Vp();\n      [[no_unique_address]] __detail::__box<_Pred> _M_pred;\n\n    public:\n      take_while_view() requires (default_initializable<_Vp>\n\t\t\t\t  && default_initializable<_Pred>)\n\t= default;\n\n      constexpr\n      take_while_view(_Vp __base, _Pred __pred)\n\t: _M_base(std::move(__base)), _M_pred(std::move(__pred))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr const _Pred&\n      pred() const\n      { return *_M_pred; }\n\n      constexpr auto\n      begin() requires (!__detail::__simple_view<_Vp>)\n      { return ranges::begin(_M_base); }\n\n      constexpr auto\n      begin() const requires range<const _Vp>\n\t&& indirect_unary_predicate<const _Pred, iterator_t<const _Vp>>\n      { return ranges::begin(_M_base); }\n\n      constexpr auto\n      end() requires (!__detail::__simple_view<_Vp>)\n      { return _Sentinel<false>(ranges::end(_M_base),\n\t\t\t\tstd::__addressof(*_M_pred)); }\n\n      constexpr auto\n      end() const requires range<const _Vp>\n\t&& indirect_unary_predicate<const _Pred, iterator_t<const _Vp>>\n      { return _Sentinel<true>(ranges::end(_M_base),\n\t\t\t       std::__addressof(*_M_pred)); }\n    };\n\n  template<typename _Range, typename _Pred>\n    take_while_view(_Range&&, _Pred)\n      -> take_while_view<views::all_t<_Range>, _Pred>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Pred>\n\tconcept __can_take_while_view\n\t  = requires { take_while_view(std::declval<_Range>(), std::declval<_Pred>()); };\n    } // namespace __detail\n\n    struct _TakeWhile : __adaptor::_RangeAdaptor<_TakeWhile>\n    {\n      template<viewable_range _Range, typename _Pred>\n\trequires __detail::__can_take_while_view<_Range, _Pred>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Pred&& __p) const\n\t{\n\t  return take_while_view(std::forward<_Range>(__r), std::forward<_Pred>(__p));\n\t}\n\n      using _RangeAdaptor<_TakeWhile>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _TakeWhile take_while;\n  } // namespace views\n\n  template<view _Vp>\n    class drop_view : public view_interface<drop_view<_Vp>>\n    {\n    private:\n      _Vp _M_base = _Vp();\n      range_difference_t<_Vp> _M_count = 0;\n\n      // ranges::next(begin(base), count, end(base)) is O(1) if _Vp satisfies\n      // both random_access_range and sized_range. Otherwise, cache its result.\n      static constexpr bool _S_needs_cached_begin\n\t= !(random_access_range<const _Vp> && sized_range<const _Vp>);\n      [[no_unique_address]]\n\t__detail::__maybe_present_t<_S_needs_cached_begin,\n\t\t\t\t    __detail::_CachedPosition<_Vp>>\n\t\t\t\t      _M_cached_begin;\n\n    public:\n      drop_view() requires default_initializable<_Vp> = default;\n\n      constexpr\n      drop_view(_Vp __base, range_difference_t<_Vp> __count)\n\t: _M_base(std::move(__base)), _M_count(__count)\n      { __glibcxx_assert(__count >= 0); }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      // This overload is disabled for simple views with constant-time begin().\n      constexpr auto\n      begin()\n\trequires (!(__detail::__simple_view<_Vp>\n\t\t    && random_access_range<const _Vp>\n\t\t    && sized_range<const _Vp>))\n      {\n\tif constexpr (_S_needs_cached_begin)\n\t  if (_M_cached_begin._M_has_value())\n\t    return _M_cached_begin._M_get(_M_base);\n\n\tauto __it = ranges::next(ranges::begin(_M_base),\n\t\t\t\t _M_count, ranges::end(_M_base));\n\tif constexpr (_S_needs_cached_begin)\n\t  _M_cached_begin._M_set(_M_base, __it);\n\treturn __it;\n      }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3482. drop_view's const begin should additionally require sized_range\n      constexpr auto\n      begin() const\n\trequires random_access_range<const _Vp> && sized_range<const _Vp>\n      {\n\treturn ranges::begin(_M_base) + ranges::min(ranges::distance(_M_base),\n\t\t\t\t\t\t    _M_count);\n      }\n\n      constexpr auto\n      end() requires (!__detail::__simple_view<_Vp>)\n      { return ranges::end(_M_base); }\n\n      constexpr auto\n      end() const requires range<const _Vp>\n      { return ranges::end(_M_base); }\n\n      constexpr auto\n      size() requires sized_range<_Vp>\n      {\n\tconst auto __s = ranges::size(_M_base);\n\tconst auto __c = static_cast<decltype(__s)>(_M_count);\n\treturn __s < __c ? 0 : __s - __c;\n      }\n\n      constexpr auto\n      size() const requires sized_range<const _Vp>\n      {\n\tconst auto __s = ranges::size(_M_base);\n\tconst auto __c = static_cast<decltype(__s)>(_M_count);\n\treturn __s < __c ? 0 : __s - __c;\n      }\n    };\n\n  template<typename _Range>\n    drop_view(_Range&&, range_difference_t<_Range>)\n      -> drop_view<views::all_t<_Range>>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<drop_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range>\n\tconstexpr auto\n\t__drop_of_repeat_view(_Range&&, range_difference_t<_Range>); // defined later\n\n      template<typename _Range, typename _Dp>\n\tconcept __can_drop_view\n\t  = requires { drop_view(std::declval<_Range>(), std::declval<_Dp>()); };\n    } // namespace __detail\n\n    struct _Drop : __adaptor::_RangeAdaptor<_Drop>\n    {\n      template<viewable_range _Range, typename _Dp = range_difference_t<_Range>>\n\trequires __detail::__can_drop_view<_Range, _Dp>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, type_identity_t<_Dp> __n) const\n\t{\n\t  using _Tp = remove_cvref_t<_Range>;\n\t  if constexpr (__detail::__is_empty_view<_Tp>)\n\t    return _Tp();\n\t  else if constexpr (random_access_range<_Tp>\n\t\t\t     && sized_range<_Tp>\n\t\t\t     && (std::__detail::__is_span<_Tp>\n\t\t\t\t || __detail::__is_basic_string_view<_Tp>\n\t\t\t\t || __detail::__is_iota_view<_Tp>\n\t\t\t\t || __detail::__is_subrange<_Tp>))\n\t    {\n\t      __n = std::min<_Dp>(ranges::distance(__r), __n);\n\t      auto __begin = ranges::begin(__r) + __n;\n\t      auto __end = ranges::end(__r);\n\t      if constexpr (std::__detail::__is_span<_Tp>)\n\t\treturn span<typename _Tp::element_type>(__begin, __end);\n\t      else if constexpr (__detail::__is_subrange<_Tp>)\n\t\t{\n\t\t  if constexpr (_Tp::_S_store_size)\n\t\t    {\n\t\t      using ranges::__detail::__to_unsigned_like;\n\t\t      auto __m = ranges::distance(__r) - __n;\n\t\t      return _Tp(__begin, __end, __to_unsigned_like(__m));\n\t\t    }\n\t\t  else\n\t\t    return _Tp(__begin, __end);\n\t\t}\n\t      else\n\t\treturn _Tp(__begin, __end);\n\t    }\n\t  else if constexpr (__detail::__is_repeat_view<_Tp>)\n\t    return __detail::__drop_of_repeat_view(std::forward<_Range>(__r), __n);\n\t  else\n\t    return drop_view(std::forward<_Range>(__r), __n);\n\t}\n\n      using _RangeAdaptor<_Drop>::operator();\n      static constexpr int _S_arity = 2;\n      template<typename _Tp>\n\tstatic constexpr bool _S_has_simple_extra_args\n\t  = _Take::_S_has_simple_extra_args<_Tp>;\n    };\n\n    inline constexpr _Drop drop;\n  } // namespace views\n\n  template<view _Vp, typename _Pred>\n    requires input_range<_Vp> && is_object_v<_Pred>\n      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>\n    class drop_while_view : public view_interface<drop_while_view<_Vp, _Pred>>\n    {\n    private:\n      _Vp _M_base = _Vp();\n      [[no_unique_address]] __detail::__box<_Pred> _M_pred;\n      [[no_unique_address]] __detail::_CachedPosition<_Vp> _M_cached_begin;\n\n    public:\n      drop_while_view() requires (default_initializable<_Vp>\n\t\t\t\t  && default_initializable<_Pred>)\n\t= default;\n\n      constexpr\n      drop_while_view(_Vp __base, _Pred __pred)\n\t: _M_base(std::move(__base)), _M_pred(std::move(__pred))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr const _Pred&\n      pred() const\n      { return *_M_pred; }\n\n      constexpr auto\n      begin()\n      {\n\tif (_M_cached_begin._M_has_value())\n\t  return _M_cached_begin._M_get(_M_base);\n\n\t__glibcxx_assert(_M_pred.has_value());\n\tauto __it = ranges::find_if_not(ranges::begin(_M_base),\n\t\t\t\t\tranges::end(_M_base),\n\t\t\t\t\tstd::cref(*_M_pred));\n\t_M_cached_begin._M_set(_M_base, __it);\n\treturn __it;\n      }\n\n      constexpr auto\n      end()\n      { return ranges::end(_M_base); }\n    };\n\n  template<typename _Range, typename _Pred>\n    drop_while_view(_Range&&, _Pred)\n      -> drop_while_view<views::all_t<_Range>, _Pred>;\n\n  template<typename _Tp, typename _Pred>\n    inline constexpr bool enable_borrowed_range<drop_while_view<_Tp, _Pred>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Pred>\n\tconcept __can_drop_while_view\n\t  = requires { drop_while_view(std::declval<_Range>(), std::declval<_Pred>()); };\n    } // namespace __detail\n\n    struct _DropWhile : __adaptor::_RangeAdaptor<_DropWhile>\n    {\n      template<viewable_range _Range, typename _Pred>\n\trequires __detail::__can_drop_while_view<_Range, _Pred>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Pred&& __p) const\n\t{\n\t  return drop_while_view(std::forward<_Range>(__r),\n\t\t\t\t std::forward<_Pred>(__p));\n\t}\n\n      using _RangeAdaptor<_DropWhile>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _DropWhile drop_while;\n  } // namespace views\n\n  namespace __detail\n  {\n    template<typename _Tp>\n      constexpr _Tp&\n      __as_lvalue(_Tp&& __t)\n      { return static_cast<_Tp&>(__t); }\n  } // namespace __detail\n\n  template<input_range _Vp>\n    requires view<_Vp> && input_range<range_reference_t<_Vp>>\n    class join_view : public view_interface<join_view<_Vp>>\n    {\n    private:\n      using _InnerRange = range_reference_t<_Vp>;\n\n      template<bool _Const>\n\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n      template<bool _Const>\n\tusing _Outer_iter = iterator_t<_Base<_Const>>;\n\n      template<bool _Const>\n\tusing _Inner_iter = iterator_t<range_reference_t<_Base<_Const>>>;\n\n      template<bool _Const>\n\tstatic constexpr bool _S_ref_is_glvalue\n\t  = is_reference_v<range_reference_t<_Base<_Const>>>;\n\n      template<bool _Const>\n\tstruct __iter_cat\n\t{ };\n\n      template<bool _Const>\n\trequires _S_ref_is_glvalue<_Const>\n\t  && forward_range<_Base<_Const>>\n\t  && forward_range<range_reference_t<_Base<_Const>>>\n\tstruct __iter_cat<_Const>\n\t{\n\tprivate:\n\t  static constexpr auto\n\t  _S_iter_cat()\n\t  {\n\t    using _Outer_iter = join_view::_Outer_iter<_Const>;\n\t    using _Inner_iter = join_view::_Inner_iter<_Const>;\n\t    using _OuterCat = typename iterator_traits<_Outer_iter>::iterator_category;\n\t    using _InnerCat = typename iterator_traits<_Inner_iter>::iterator_category;\n\t    if constexpr (derived_from<_OuterCat, bidirectional_iterator_tag>\n\t\t\t  && derived_from<_InnerCat, bidirectional_iterator_tag>\n\t\t\t  && common_range<range_reference_t<_Base<_Const>>>)\n\t      return bidirectional_iterator_tag{};\n\t    else if constexpr (derived_from<_OuterCat, forward_iterator_tag>\n\t\t\t       && derived_from<_InnerCat, forward_iterator_tag>)\n\t      return forward_iterator_tag{};\n\t    else\n\t      return input_iterator_tag{};\n\t  }\n\tpublic:\n\t  using iterator_category = decltype(_S_iter_cat());\n\t};\n\n      template<bool _Const>\n\tstruct _Sentinel;\n\n      template<bool _Const>\n\tstruct _Iterator : __iter_cat<_Const>\n\t{\n\tprivate:\n\t  using _Parent = __detail::__maybe_const_t<_Const, join_view>;\n\t  using _Base = join_view::_Base<_Const>;\n\n\t  friend join_view;\n\n\t  static constexpr bool _S_ref_is_glvalue\n\t    = join_view::_S_ref_is_glvalue<_Const>;\n\n\t  constexpr void\n\t  _M_satisfy()\n\t  {\n\t    auto __update_inner = [this] (const iterator_t<_Base>& __x) -> auto&& {\n\t      if constexpr (_S_ref_is_glvalue)\n\t\treturn *__x;\n\t      else\n\t\treturn _M_parent->_M_inner._M_emplace_deref(__x);\n\t    };\n\n\t    _Outer_iter& __outer = _M_get_outer();\n\t    for (; __outer != ranges::end(_M_parent->_M_base); ++__outer)\n\t      {\n\t\tauto&& __inner = __update_inner(__outer);\n\t\t_M_inner = ranges::begin(__inner);\n\t\tif (_M_inner != ranges::end(__inner))\n\t\t  return;\n\t      }\n\n\t    if constexpr (_S_ref_is_glvalue)\n\t      _M_inner.reset();\n\t  }\n\n\t  static constexpr auto\n\t  _S_iter_concept()\n\t  {\n\t    if constexpr (_S_ref_is_glvalue\n\t\t\t  && bidirectional_range<_Base>\n\t\t\t  && bidirectional_range<range_reference_t<_Base>>\n\t\t\t  && common_range<range_reference_t<_Base>>)\n\t      return bidirectional_iterator_tag{};\n\t    else if constexpr (_S_ref_is_glvalue\n\t\t\t       && forward_range<_Base>\n\t\t\t       && forward_range<range_reference_t<_Base>>)\n\t      return forward_iterator_tag{};\n\t    else\n\t      return input_iterator_tag{};\n\t  }\n\n\t  using _Outer_iter = join_view::_Outer_iter<_Const>;\n\t  using _Inner_iter = join_view::_Inner_iter<_Const>;\n\n\t  constexpr _Outer_iter&\n\t  _M_get_outer()\n\t  {\n\t    if constexpr (forward_range<_Base>)\n\t      return _M_outer;\n\t    else\n\t      return *_M_parent->_M_outer;\n\t  }\n\n\t  constexpr const _Outer_iter&\n\t  _M_get_outer() const\n\t  {\n\t    if constexpr (forward_range<_Base>)\n\t      return _M_outer;\n\t    else\n\t      return *_M_parent->_M_outer;\n\t  }\n\n\t  constexpr\n\t  _Iterator(_Parent* __parent, _Outer_iter __outer) requires forward_range<_Base>\n\t    : _M_outer(std::move(__outer)), _M_parent(__parent)\n\t  { _M_satisfy(); }\n\n\t  constexpr explicit\n\t  _Iterator(_Parent* __parent) requires (!forward_range<_Base>)\n\t    : _M_parent(__parent)\n\t  { _M_satisfy(); }\n\n\t  [[no_unique_address]]\n\t    __detail::__maybe_present_t<forward_range<_Base>, _Outer_iter> _M_outer\n\t      = decltype(_M_outer)();\n\t  optional<_Inner_iter> _M_inner;\n\t  _Parent* _M_parent = nullptr;\n\n\tpublic:\n\t  using iterator_concept = decltype(_S_iter_concept());\n\t  // iterator_category defined in __join_view_iter_cat\n\t  using value_type = range_value_t<range_reference_t<_Base>>;\n\t  using difference_type\n\t    = common_type_t<range_difference_t<_Base>,\n\t\t\t    range_difference_t<range_reference_t<_Base>>>;\n\n\t  _Iterator() = default;\n\n\t  constexpr\n\t  _Iterator(_Iterator<!_Const> __i)\n\t    requires _Const\n\t      && convertible_to<iterator_t<_Vp>, _Outer_iter>\n\t      && convertible_to<iterator_t<_InnerRange>, _Inner_iter>\n\t    : _M_outer(std::move(__i._M_outer)), _M_inner(std::move(__i._M_inner)),\n\t      _M_parent(__i._M_parent)\n\t  { }\n\n\t  constexpr decltype(auto)\n\t  operator*() const\n\t  { return **_M_inner; }\n\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3500. join_view::iterator::operator->() is bogus\n\t  constexpr _Inner_iter\n\t  operator->() const\n\t    requires __detail::__has_arrow<_Inner_iter>\n\t      && copyable<_Inner_iter>\n\t  { return *_M_inner; }\n\n\t  constexpr _Iterator&\n\t  operator++()\n\t  {\n\t    auto&& __inner_range = [this] () -> auto&& {\n\t      if constexpr (_S_ref_is_glvalue)\n\t\treturn *_M_get_outer();\n\t      else\n\t\treturn *_M_parent->_M_inner;\n\t    }();\n\t    if (++*_M_inner == ranges::end(__inner_range))\n\t      {\n\t\t++_M_get_outer();\n\t\t_M_satisfy();\n\t      }\n\t    return *this;\n\t  }\n\n\t  constexpr void\n\t  operator++(int)\n\t  { ++*this; }\n\n\t  constexpr _Iterator\n\t  operator++(int)\n\t    requires _S_ref_is_glvalue && forward_range<_Base>\n\t      && forward_range<range_reference_t<_Base>>\n\t  {\n\t    auto __tmp = *this;\n\t    ++*this;\n\t    return __tmp;\n\t  }\n\n\t  constexpr _Iterator&\n\t  operator--()\n\t    requires _S_ref_is_glvalue && bidirectional_range<_Base>\n\t      && bidirectional_range<range_reference_t<_Base>>\n\t      && common_range<range_reference_t<_Base>>\n\t  {\n\t    if (_M_outer == ranges::end(_M_parent->_M_base))\n\t      _M_inner = ranges::end(__detail::__as_lvalue(*--_M_outer));\n\t    while (*_M_inner == ranges::begin(__detail::__as_lvalue(*_M_outer)))\n\t      *_M_inner = ranges::end(__detail::__as_lvalue(*--_M_outer));\n\t    --*_M_inner;\n\t    return *this;\n\t  }\n\n\t  constexpr _Iterator\n\t  operator--(int)\n\t    requires _S_ref_is_glvalue && bidirectional_range<_Base>\n\t      && bidirectional_range<range_reference_t<_Base>>\n\t      && common_range<range_reference_t<_Base>>\n\t  {\n\t    auto __tmp = *this;\n\t    --*this;\n\t    return __tmp;\n\t  }\n\n\t  friend constexpr bool\n\t  operator==(const _Iterator& __x, const _Iterator& __y)\n\t    requires _S_ref_is_glvalue\n\t      && forward_range<_Base>\n\t      && equality_comparable<_Inner_iter>\n\t  {\n\t    return (__x._M_outer == __y._M_outer\n\t\t    && __x._M_inner == __y._M_inner);\n\t  }\n\n\t  friend constexpr decltype(auto)\n\t  iter_move(const _Iterator& __i)\n\t  noexcept(noexcept(ranges::iter_move(*__i._M_inner)))\n\t  { return ranges::iter_move(*__i._M_inner); }\n\n\t  friend constexpr void\n\t  iter_swap(const _Iterator& __x, const _Iterator& __y)\n\t    noexcept(noexcept(ranges::iter_swap(*__x._M_inner, *__y._M_inner)))\n\t    requires indirectly_swappable<_Inner_iter>\n\t  { return ranges::iter_swap(*__x._M_inner, *__y._M_inner); }\n\n\t  friend _Iterator<!_Const>;\n\t  template<bool> friend struct _Sentinel;\n\t};\n\n      template<bool _Const>\n\tstruct _Sentinel\n\t{\n\tprivate:\n\t  using _Parent = __detail::__maybe_const_t<_Const, join_view>;\n\t  using _Base = join_view::_Base<_Const>;\n\n\t  template<bool _Const2>\n\t    constexpr bool\n\t    __equal(const _Iterator<_Const2>& __i) const\n\t    { return __i._M_get_outer() == _M_end; }\n\n\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\n\tpublic:\n\t  _Sentinel() = default;\n\n\t  constexpr explicit\n\t  _Sentinel(_Parent* __parent)\n\t    : _M_end(ranges::end(__parent->_M_base))\n\t  { }\n\n\t  constexpr\n\t  _Sentinel(_Sentinel<!_Const> __s)\n\t    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n\t    : _M_end(std::move(__s._M_end))\n\t  { }\n\n\t  template<bool _Const2>\n\t    requires sentinel_for<sentinel_t<_Base>,\n\t\t       iterator_t<__detail::__maybe_const_t<_Const2, _Vp>>>\n\t    friend constexpr bool\n\t    operator==(const _Iterator<_Const2>& __x, const _Sentinel& __y)\n\t    { return __y.__equal(__x); }\n\n\t  friend _Sentinel<!_Const>;\n\t};\n\n      _Vp _M_base = _Vp();\n      [[no_unique_address]]\n\t__detail::__maybe_present_t<!forward_range<_Vp>,\n\t  __detail::__non_propagating_cache<iterator_t<_Vp>>> _M_outer;\n      [[no_unique_address]]\n\t__detail::__non_propagating_cache<remove_cv_t<_InnerRange>> _M_inner;\n\n    public:\n      join_view() requires default_initializable<_Vp> = default;\n\n      constexpr explicit\n      join_view(_Vp __base)\n\t: _M_base(std::move(__base))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr auto\n      begin()\n      {\n\tif constexpr (forward_range<_Vp>)\n\t  {\n\t    constexpr bool __use_const\n\t      = (__detail::__simple_view<_Vp>\n\t\t && is_reference_v<range_reference_t<_Vp>>);\n\t    return _Iterator<__use_const>{this, ranges::begin(_M_base)};\n\t  }\n\telse\n\t  {\n\t    _M_outer = ranges::begin(_M_base);\n\t    return _Iterator<false>{this};\n\t  }\n      }\n\n      constexpr auto\n      begin() const\n\trequires forward_range<const _Vp>\n\t  && is_reference_v<range_reference_t<const _Vp>>\n\t  && input_range<range_reference_t<const _Vp>>\n      {\n\treturn _Iterator<true>{this, ranges::begin(_M_base)};\n      }\n\n      constexpr auto\n      end()\n      {\n\tif constexpr (forward_range<_Vp> && is_reference_v<_InnerRange>\n\t\t      && forward_range<_InnerRange>\n\t\t      && common_range<_Vp> && common_range<_InnerRange>)\n\t  return _Iterator<__detail::__simple_view<_Vp>>{this,\n\t\t\t\t\t\t\t ranges::end(_M_base)};\n\telse\n\t  return _Sentinel<__detail::__simple_view<_Vp>>{this};\n      }\n\n      constexpr auto\n      end() const\n\trequires forward_range<const _Vp>\n\t  && is_reference_v<range_reference_t<const _Vp>>\n\t  && input_range<range_reference_t<const _Vp>>\n      {\n\tif constexpr (is_reference_v<range_reference_t<const _Vp>>\n\t\t      && forward_range<range_reference_t<const _Vp>>\n\t\t      && common_range<const _Vp>\n\t\t      && common_range<range_reference_t<const _Vp>>)\n\t  return _Iterator<true>{this, ranges::end(_M_base)};\n\telse\n\t  return _Sentinel<true>{this};\n      }\n    };\n\n  template<typename _Range>\n    explicit join_view(_Range&&) -> join_view<views::all_t<_Range>>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range>\n\tconcept __can_join_view\n\t  = requires { join_view<all_t<_Range>>{std::declval<_Range>()}; };\n    } // namespace __detail\n\n    struct _Join : __adaptor::_RangeAdaptorClosure<_Join>\n    {\n      template<viewable_range _Range>\n\trequires __detail::__can_join_view<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3474. Nesting join_views is broken because of CTAD\n\t  return join_view<all_t<_Range>>{std::forward<_Range>(__r)};\n\t}\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n    inline constexpr _Join join;\n  } // namespace views\n\n  namespace __detail\n  {\n    template<auto>\n      struct __require_constant;\n\n    template<typename _Range>\n      concept __tiny_range = sized_range<_Range>\n\t&& requires\n\t   { typename __require_constant<remove_reference_t<_Range>::size()>; }\n\t&& (remove_reference_t<_Range>::size() <= 1);\n\n    template<typename _Base>\n      struct __lazy_split_view_outer_iter_cat\n      { };\n\n    template<forward_range _Base>\n      struct __lazy_split_view_outer_iter_cat<_Base>\n      { using iterator_category = input_iterator_tag; };\n\n    template<typename _Base>\n      struct __lazy_split_view_inner_iter_cat\n      { };\n\n    template<forward_range _Base>\n      struct __lazy_split_view_inner_iter_cat<_Base>\n      {\n      private:\n\tstatic constexpr auto\n\t_S_iter_cat()\n\t{\n\t  using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n\t  if constexpr (derived_from<_Cat, forward_iterator_tag>)\n\t    return forward_iterator_tag{};\n\t  else\n\t    return _Cat{};\n\t}\n      public:\n\tusing iterator_category = decltype(_S_iter_cat());\n      };\n  }\n\n  template<input_range _Vp, forward_range _Pattern>\n    requires view<_Vp> && view<_Pattern>\n      && indirectly_comparable<iterator_t<_Vp>, iterator_t<_Pattern>,\n\t\t\t       ranges::equal_to>\n      && (forward_range<_Vp> || __detail::__tiny_range<_Pattern>)\n    class lazy_split_view : public view_interface<lazy_split_view<_Vp, _Pattern>>\n    {\n    private:\n      template<bool _Const>\n\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n      template<bool _Const>\n\tstruct _InnerIter;\n\n      template<bool _Const>\n\tstruct _OuterIter\n\t  : __detail::__lazy_split_view_outer_iter_cat<_Base<_Const>>\n\t{\n\tprivate:\n\t  using _Parent = __detail::__maybe_const_t<_Const, lazy_split_view>;\n\t  using _Base = lazy_split_view::_Base<_Const>;\n\n\t  constexpr bool\n\t  __at_end() const\n\t  { return __current() == ranges::end(_M_parent->_M_base) && !_M_trailing_empty; }\n\n\t  // [range.lazy.split.outer] p1\n\t  //  Many of the following specifications refer to the notional member\n\t  //  current of outer-iterator.  current is equivalent to current_ if\n\t  //  V models forward_range, and parent_->current_ otherwise.\n\t  constexpr auto&\n\t  __current() noexcept\n\t  {\n\t    if constexpr (forward_range<_Vp>)\n\t      return _M_current;\n\t    else\n\t      return *_M_parent->_M_current;\n\t  }\n\n\t  constexpr auto&\n\t  __current() const noexcept\n\t  {\n\t    if constexpr (forward_range<_Vp>)\n\t      return _M_current;\n\t    else\n\t      return *_M_parent->_M_current;\n\t  }\n\n\t  _Parent* _M_parent = nullptr;\n\n\t  [[no_unique_address]]\n\t    __detail::__maybe_present_t<forward_range<_Vp>,\n\t\t\t\t\titerator_t<_Base>> _M_current\n\t      = decltype(_M_current)();\n\t  bool _M_trailing_empty = false;\n\n\tpublic:\n\t  using iterator_concept = __conditional_t<forward_range<_Base>,\n\t\t\t\t\t\t   forward_iterator_tag,\n\t\t\t\t\t\t   input_iterator_tag>;\n\t  // iterator_category defined in __lazy_split_view_outer_iter_cat\n\t  using difference_type = range_difference_t<_Base>;\n\n\t  struct value_type : view_interface<value_type>\n\t  {\n\t  private:\n\t    _OuterIter _M_i = _OuterIter();\n\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 4013. lazy_split_view::outer-iterator::value_type should not\n\t    // provide default constructor\n\t    constexpr explicit\n\t    value_type(_OuterIter __i)\n\t      : _M_i(std::move(__i))\n\t    { }\n\n\t    friend _OuterIter;\n\n\t  public:\n\t    constexpr _InnerIter<_Const>\n\t    begin() const\n\t    { return _InnerIter<_Const>{_M_i}; }\n\n\t    constexpr default_sentinel_t\n\t    end() const noexcept\n\t    { return default_sentinel; }\n\t  };\n\n\t  _OuterIter() = default;\n\n\t  constexpr explicit\n\t  _OuterIter(_Parent* __parent) requires (!forward_range<_Base>)\n\t    : _M_parent(__parent)\n\t  { }\n\n\t  constexpr\n\t  _OuterIter(_Parent* __parent, iterator_t<_Base> __current)\n\t    requires forward_range<_Base>\n\t    : _M_parent(__parent),\n\t      _M_current(std::move(__current))\n\t  { }\n\n\t  constexpr\n\t  _OuterIter(_OuterIter<!_Const> __i)\n\t    requires _Const\n\t      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n\t    : _M_parent(__i._M_parent), _M_current(std::move(__i._M_current)),\n\t      _M_trailing_empty(__i._M_trailing_empty)\n\t  { }\n\n\t  constexpr value_type\n\t  operator*() const\n\t  { return value_type{*this}; }\n\n\t  constexpr _OuterIter&\n\t  operator++()\n\t  {\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3505. lazy_split_view::outer-iterator::operator++ misspecified\n\t    const auto __end = ranges::end(_M_parent->_M_base);\n\t    if (__current() == __end)\n\t      {\n\t\t_M_trailing_empty = false;\n\t\treturn *this;\n\t      }\n\t    const auto [__pbegin, __pend] = subrange{_M_parent->_M_pattern};\n\t    if (__pbegin == __pend)\n\t      ++__current();\n\t    else if constexpr (__detail::__tiny_range<_Pattern>)\n\t      {\n\t\t__current() = ranges::find(std::move(__current()), __end,\n\t\t\t\t\t   *__pbegin);\n\t\tif (__current() != __end)\n\t\t  {\n\t\t    ++__current();\n\t\t    if (__current() == __end)\n\t\t      _M_trailing_empty = true;\n\t\t  }\n\t      }\n\t    else\n\t      do\n\t\t{\n\t\t  auto [__b, __p]\n\t\t    = ranges::mismatch(__current(), __end, __pbegin, __pend);\n\t\t  if (__p == __pend)\n\t\t    {\n\t\t      __current() = __b;\n\t\t      if (__current() == __end)\n\t\t\t_M_trailing_empty = true;\n\t\t      break;\n\t\t    }\n\t\t} while (++__current() != __end);\n\t    return *this;\n\t  }\n\n\t  constexpr decltype(auto)\n\t  operator++(int)\n\t  {\n\t    if constexpr (forward_range<_Base>)\n\t      {\n\t\tauto __tmp = *this;\n\t\t++*this;\n\t\treturn __tmp;\n\t      }\n\t    else\n\t      ++*this;\n\t  }\n\n\t  friend constexpr bool\n\t  operator==(const _OuterIter& __x, const _OuterIter& __y)\n\t    requires forward_range<_Base>\n\t  {\n\t    return __x._M_current == __y._M_current\n\t      && __x._M_trailing_empty == __y._M_trailing_empty;\n\t  }\n\n\t  friend constexpr bool\n\t  operator==(const _OuterIter& __x, default_sentinel_t)\n\t  { return __x.__at_end(); };\n\n\t  friend _OuterIter<!_Const>;\n\t  friend _InnerIter<_Const>;\n\t};\n\n      template<bool _Const>\n\tstruct _InnerIter\n\t  : __detail::__lazy_split_view_inner_iter_cat<_Base<_Const>>\n\t{\n\tprivate:\n\t  using _Base = lazy_split_view::_Base<_Const>;\n\n\t  constexpr bool\n\t  __at_end() const\n\t  {\n\t    auto [__pcur, __pend] = subrange{_M_i._M_parent->_M_pattern};\n\t    auto __end = ranges::end(_M_i._M_parent->_M_base);\n\t    if constexpr (__detail::__tiny_range<_Pattern>)\n\t      {\n\t\tconst auto& __cur = _M_i_current();\n\t\tif (__cur == __end)\n\t\t  return true;\n\t\tif (__pcur == __pend)\n\t\t  return _M_incremented;\n\t\treturn *__cur == *__pcur;\n\t      }\n\t    else\n\t      {\n\t\tauto __cur = _M_i_current();\n\t\tif (__cur == __end)\n\t\t  return true;\n\t\tif (__pcur == __pend)\n\t\t  return _M_incremented;\n\t\tdo\n\t\t  {\n\t\t    if (*__cur != *__pcur)\n\t\t      return false;\n\t\t    if (++__pcur == __pend)\n\t\t      return true;\n\t\t  } while (++__cur != __end);\n\t\treturn false;\n\t      }\n\t  }\n\n\t  constexpr auto&\n\t  _M_i_current() noexcept\n\t  { return _M_i.__current(); }\n\n\t  constexpr auto&\n\t  _M_i_current() const noexcept\n\t  { return _M_i.__current(); }\n\n\t  _OuterIter<_Const> _M_i = _OuterIter<_Const>();\n\t  bool _M_incremented = false;\n\n\tpublic:\n\t  using iterator_concept\n\t    = typename _OuterIter<_Const>::iterator_concept;\n\t  // iterator_category defined in __lazy_split_view_inner_iter_cat\n\t  using value_type = range_value_t<_Base>;\n\t  using difference_type = range_difference_t<_Base>;\n\n\t  _InnerIter() = default;\n\n\t  constexpr explicit\n\t  _InnerIter(_OuterIter<_Const> __i)\n\t    : _M_i(std::move(__i))\n\t  { }\n\n\t  constexpr const iterator_t<_Base>&\n\t  base() const& noexcept\n\t  { return _M_i_current(); }\n\n\t  constexpr iterator_t<_Base>\n\t  base() && requires forward_range<_Vp>\n\t  { return std::move(_M_i_current()); }\n\n\t  constexpr decltype(auto)\n\t  operator*() const\n\t  { return *_M_i_current(); }\n\n\t  constexpr _InnerIter&\n\t  operator++()\n\t  {\n\t    _M_incremented = true;\n\t    if constexpr (!forward_range<_Base>)\n\t      if constexpr (_Pattern::size() == 0)\n\t\treturn *this;\n\t    ++_M_i_current();\n\t    return *this;\n\t  }\n\n\t  constexpr decltype(auto)\n\t  operator++(int)\n\t  {\n\t    if constexpr (forward_range<_Base>)\n\t      {\n\t\tauto __tmp = *this;\n\t\t++*this;\n\t\treturn __tmp;\n\t      }\n\t    else\n\t      ++*this;\n\t  }\n\n\t  friend constexpr bool\n\t  operator==(const _InnerIter& __x, const _InnerIter& __y)\n\t    requires forward_range<_Base>\n\t  { return __x._M_i == __y._M_i; }\n\n\t  friend constexpr bool\n\t  operator==(const _InnerIter& __x, default_sentinel_t)\n\t  { return __x.__at_end(); }\n\n\t  friend constexpr decltype(auto)\n\t  iter_move(const _InnerIter& __i)\n\t    noexcept(noexcept(ranges::iter_move(__i._M_i_current())))\n\t  { return ranges::iter_move(__i._M_i_current()); }\n\n\t  friend constexpr void\n\t  iter_swap(const _InnerIter& __x, const _InnerIter& __y)\n\t    noexcept(noexcept(ranges::iter_swap(__x._M_i_current(),\n\t\t\t\t\t\t__y._M_i_current())))\n\t    requires indirectly_swappable<iterator_t<_Base>>\n\t  { ranges::iter_swap(__x._M_i_current(), __y._M_i_current()); }\n\t};\n\n      _Vp _M_base = _Vp();\n      _Pattern _M_pattern = _Pattern();\n      [[no_unique_address]]\n\t__detail::__maybe_present_t<!forward_range<_Vp>,\n\t  __detail::__non_propagating_cache<iterator_t<_Vp>>> _M_current;\n\n\n    public:\n      lazy_split_view() requires (default_initializable<_Vp>\n\t\t\t\t  && default_initializable<_Pattern>)\n\t= default;\n\n      constexpr\n      lazy_split_view(_Vp __base, _Pattern __pattern)\n\t: _M_base(std::move(__base)), _M_pattern(std::move(__pattern))\n      { }\n\n      template<input_range _Range>\n\trequires constructible_from<_Vp, views::all_t<_Range>>\n\t  && constructible_from<_Pattern, single_view<range_value_t<_Range>>>\n\tconstexpr\n\tlazy_split_view(_Range&& __r, range_value_t<_Range> __e)\n\t  : _M_base(views::all(std::forward<_Range>(__r))),\n\t    _M_pattern(views::single(std::move(__e)))\n\t{ }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr auto\n      begin()\n      {\n\tif constexpr (forward_range<_Vp>)\n\t  {\n\t    constexpr bool __simple\n\t      = __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;\n\t    return _OuterIter<__simple>{this, ranges::begin(_M_base)};\n\t  }\n\telse\n\t  {\n\t    _M_current = ranges::begin(_M_base);\n\t    return _OuterIter<false>{this};\n\t  }\n      }\n\n      constexpr auto\n      begin() const requires forward_range<_Vp> && forward_range<const _Vp>\n      {\n\treturn _OuterIter<true>{this, ranges::begin(_M_base)};\n      }\n\n      constexpr auto\n      end() requires forward_range<_Vp> && common_range<_Vp>\n      {\n\tconstexpr bool __simple\n\t  = __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;\n\treturn _OuterIter<__simple>{this, ranges::end(_M_base)};\n      }\n\n      constexpr auto\n      end() const\n      {\n\tif constexpr (forward_range<_Vp>\n\t\t      && forward_range<const _Vp>\n\t\t      && common_range<const _Vp>)\n\t  return _OuterIter<true>{this, ranges::end(_M_base)};\n\telse\n\t  return default_sentinel;\n      }\n    };\n\n  template<typename _Range, typename _Pattern>\n    lazy_split_view(_Range&&, _Pattern&&)\n      -> lazy_split_view<views::all_t<_Range>, views::all_t<_Pattern>>;\n\n  template<input_range _Range>\n    lazy_split_view(_Range&&, range_value_t<_Range>)\n      -> lazy_split_view<views::all_t<_Range>, single_view<range_value_t<_Range>>>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Pattern>\n\tconcept __can_lazy_split_view\n\t  = requires { lazy_split_view(std::declval<_Range>(), std::declval<_Pattern>()); };\n    } // namespace __detail\n\n    struct _LazySplit : __adaptor::_RangeAdaptor<_LazySplit>\n    {\n      template<viewable_range _Range, typename _Pattern>\n\trequires __detail::__can_lazy_split_view<_Range, _Pattern>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Pattern&& __f) const\n\t{\n\t  return lazy_split_view(std::forward<_Range>(__r), std::forward<_Pattern>(__f));\n\t}\n\n      using _RangeAdaptor<_LazySplit>::operator();\n      static constexpr int _S_arity = 2;\n      // The pattern argument of views::lazy_split is not always simple -- it can be\n      // a non-view range, the value category of which affects whether the call\n      // is well-formed.  But a scalar or a view pattern argument is surely\n      // simple.\n      template<typename _Pattern>\n\tstatic constexpr bool _S_has_simple_extra_args\n\t  = is_scalar_v<_Pattern> || (view<_Pattern>\n\t\t\t\t      && copy_constructible<_Pattern>);\n    };\n\n    inline constexpr _LazySplit lazy_split;\n  } // namespace views\n\n  template<forward_range _Vp, forward_range _Pattern>\n    requires view<_Vp> && view<_Pattern>\n      && indirectly_comparable<iterator_t<_Vp>, iterator_t<_Pattern>,\n\t\t\t       ranges::equal_to>\n  class split_view : public view_interface<split_view<_Vp, _Pattern>>\n  {\n  private:\n    _Vp _M_base = _Vp();\n    _Pattern _M_pattern = _Pattern();\n    __detail::__non_propagating_cache<subrange<iterator_t<_Vp>>> _M_cached_begin;\n\n    struct _Iterator;\n    struct _Sentinel;\n\n  public:\n    split_view() requires (default_initializable<_Vp>\n\t\t\t   && default_initializable<_Pattern>)\n      = default;\n\n    constexpr\n    split_view(_Vp __base, _Pattern __pattern)\n      : _M_base(std::move(__base)), _M_pattern(std::move(__pattern))\n    { }\n\n    template<forward_range _Range>\n      requires constructible_from<_Vp, views::all_t<_Range>>\n\t&& constructible_from<_Pattern, single_view<range_value_t<_Range>>>\n    constexpr\n    split_view(_Range&& __r, range_value_t<_Range> __e)\n      : _M_base(views::all(std::forward<_Range>(__r))),\n\t_M_pattern(views::single(std::move(__e)))\n    { }\n\n    constexpr _Vp\n    base() const& requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr _Iterator\n    begin()\n    {\n      if (!_M_cached_begin)\n\t_M_cached_begin = _M_find_next(ranges::begin(_M_base));\n      return {this, ranges::begin(_M_base), *_M_cached_begin};\n    }\n\n    constexpr auto\n    end()\n    {\n      if constexpr (common_range<_Vp>)\n\treturn _Iterator{this, ranges::end(_M_base), {}};\n      else\n\treturn _Sentinel{this};\n    }\n\n    constexpr subrange<iterator_t<_Vp>>\n    _M_find_next(iterator_t<_Vp> __it)\n    {\n      auto [__b, __e] = ranges::search(subrange(__it, ranges::end(_M_base)), _M_pattern);\n      if (__b != ranges::end(_M_base) && ranges::empty(_M_pattern))\n\t{\n\t  ++__b;\n\t  ++__e;\n\t}\n      return {__b, __e};\n    }\n\n  private:\n    struct _Iterator\n    {\n    private:\n      split_view* _M_parent = nullptr;\n      iterator_t<_Vp> _M_cur = iterator_t<_Vp>();\n      subrange<iterator_t<_Vp>> _M_next = subrange<iterator_t<_Vp>>();\n      bool _M_trailing_empty = false;\n\n      friend struct _Sentinel;\n\n    public:\n      using iterator_concept = forward_iterator_tag;\n      using iterator_category = input_iterator_tag;\n      using value_type = subrange<iterator_t<_Vp>>;\n      using difference_type = range_difference_t<_Vp>;\n\n      _Iterator() = default;\n\n      constexpr\n      _Iterator(split_view* __parent,\n\t\titerator_t<_Vp> __current,\n\t\tsubrange<iterator_t<_Vp>> __next)\n\t: _M_parent(__parent),\n\t  _M_cur(std::move(__current)),\n\t  _M_next(std::move(__next))\n      { }\n\n      constexpr iterator_t<_Vp>\n      base() const\n      { return _M_cur; }\n\n      constexpr value_type\n      operator*() const\n      { return {_M_cur, _M_next.begin()}; }\n\n      constexpr _Iterator&\n      operator++()\n      {\n\t_M_cur = _M_next.begin();\n\tif (_M_cur != ranges::end(_M_parent->_M_base))\n\t  {\n\t    _M_cur = _M_next.end();\n\t    if (_M_cur == ranges::end(_M_parent->_M_base))\n\t      {\n\t\t_M_trailing_empty = true;\n\t\t_M_next = {_M_cur, _M_cur};\n\t      }\n\t    else\n\t      _M_next = _M_parent->_M_find_next(_M_cur);\n\t  }\n\telse\n\t  _M_trailing_empty = false;\n\treturn *this;\n      }\n\n      constexpr _Iterator\n      operator++(int)\n      {\n\tauto __tmp = *this;\n\t++*this;\n\treturn __tmp;\n      }\n\n      friend constexpr bool\n      operator==(const _Iterator& __x, const _Iterator& __y)\n      {\n\treturn __x._M_cur == __y._M_cur\n\t  && __x._M_trailing_empty == __y._M_trailing_empty;\n      }\n    };\n\n    struct _Sentinel\n    {\n    private:\n      sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();\n\n      constexpr bool\n      _M_equal(const _Iterator& __x) const\n      { return __x._M_cur == _M_end && !__x._M_trailing_empty; }\n\n    public:\n      _Sentinel() = default;\n\n      constexpr explicit\n      _Sentinel(split_view* __parent)\n\t: _M_end(ranges::end(__parent->_M_base))\n      { }\n\n      friend constexpr bool\n      operator==(const _Iterator& __x, const _Sentinel& __y)\n      { return __y._M_equal(__x); }\n    };\n  };\n\n  template<typename _Range, typename _Pattern>\n    split_view(_Range&&, _Pattern&&)\n      -> split_view<views::all_t<_Range>, views::all_t<_Pattern>>;\n\n  template<forward_range _Range>\n    split_view(_Range&&, range_value_t<_Range>)\n      -> split_view<views::all_t<_Range>, single_view<range_value_t<_Range>>>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Pattern>\n\tconcept __can_split_view\n\t  = requires { split_view(std::declval<_Range>(), std::declval<_Pattern>()); };\n    } // namespace __detail\n\n    struct _Split : __adaptor::_RangeAdaptor<_Split>\n    {\n      template<viewable_range _Range, typename _Pattern>\n\trequires __detail::__can_split_view<_Range, _Pattern>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Pattern&& __f) const\n\t{\n\t  return split_view(std::forward<_Range>(__r), std::forward<_Pattern>(__f));\n\t}\n\n      using _RangeAdaptor<_Split>::operator();\n      static constexpr int _S_arity = 2;\n      template<typename _Pattern>\n\tstatic constexpr bool _S_has_simple_extra_args\n\t  = _LazySplit::_S_has_simple_extra_args<_Pattern>;\n    };\n\n    inline constexpr _Split split;\n  } // namespace views\n\n  namespace views\n  {\n    struct _Counted\n    {\n      template<input_or_output_iterator _Iter>\n      constexpr auto\n      operator() [[nodiscard]] (_Iter __i, iter_difference_t<_Iter> __n) const\n      {\n\tif constexpr (contiguous_iterator<_Iter>)\n\t  return span(std::to_address(__i), __n);\n\telse if constexpr (random_access_iterator<_Iter>)\n\t  return subrange(__i, __i + __n);\n\telse\n\t  return subrange(counted_iterator(std::move(__i), __n),\n\t\t\t  default_sentinel);\n      }\n    };\n\n    inline constexpr _Counted counted{};\n  } // namespace views\n\n  template<view _Vp>\n    requires (!common_range<_Vp>) && copyable<iterator_t<_Vp>>\n    class common_view : public view_interface<common_view<_Vp>>\n    {\n    private:\n      _Vp _M_base = _Vp();\n\n    public:\n      common_view() requires default_initializable<_Vp> = default;\n\n      constexpr explicit\n      common_view(_Vp __r)\n\t: _M_base(std::move(__r))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 4012. common_view::begin/end are missing the simple-view check\n      constexpr auto\n      begin() requires (!__detail::__simple_view<_Vp>)\n      {\n\tif constexpr (random_access_range<_Vp> && sized_range<_Vp>)\n\t  return ranges::begin(_M_base);\n\telse\n\t  return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>\n\t\t  (ranges::begin(_M_base));\n      }\n\n      constexpr auto\n      begin() const requires range<const _Vp>\n      {\n\tif constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)\n\t  return ranges::begin(_M_base);\n\telse\n\t  return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>\n\t\t  (ranges::begin(_M_base));\n      }\n\n      constexpr auto\n      end() requires (!__detail::__simple_view<_Vp>)\n      {\n\tif constexpr (random_access_range<_Vp> && sized_range<_Vp>)\n\t  return ranges::begin(_M_base) + ranges::size(_M_base);\n\telse\n\t  return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>\n\t\t  (ranges::end(_M_base));\n      }\n\n      constexpr auto\n      end() const requires range<const _Vp>\n      {\n\tif constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)\n\t  return ranges::begin(_M_base) + ranges::size(_M_base);\n\telse\n\t  return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>\n\t\t  (ranges::end(_M_base));\n      }\n\n      constexpr auto\n      size() requires sized_range<_Vp>\n      { return ranges::size(_M_base); }\n\n      constexpr auto\n      size() const requires sized_range<const _Vp>\n      { return ranges::size(_M_base); }\n    };\n\n  template<typename _Range>\n    common_view(_Range&&) -> common_view<views::all_t<_Range>>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<common_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range>\n\tconcept __already_common = common_range<_Range>\n\t  && requires { views::all(std::declval<_Range>()); };\n\n      template<typename _Range>\n\tconcept __can_common_view\n\t  = requires { common_view{std::declval<_Range>()}; };\n    } // namespace __detail\n\n    struct _Common : __adaptor::_RangeAdaptorClosure<_Common>\n    {\n      template<viewable_range _Range>\n\trequires __detail::__already_common<_Range>\n\t  || __detail::__can_common_view<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\t{\n\t  if constexpr (__detail::__already_common<_Range>)\n\t    return views::all(std::forward<_Range>(__r));\n\t  else\n\t    return common_view{std::forward<_Range>(__r)};\n\t}\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n    inline constexpr _Common common;\n  } // namespace views\n\n  template<view _Vp>\n    requires bidirectional_range<_Vp>\n    class reverse_view : public view_interface<reverse_view<_Vp>>\n    {\n    private:\n      static constexpr bool _S_needs_cached_begin\n\t= !common_range<_Vp> && !(random_access_range<_Vp>\n\t\t\t\t  && sized_sentinel_for<sentinel_t<_Vp>,\n\t\t\t\t\t\t\titerator_t<_Vp>>);\n\n      _Vp _M_base = _Vp();\n      [[no_unique_address]]\n\t__detail::__maybe_present_t<_S_needs_cached_begin,\n\t\t\t\t    __detail::_CachedPosition<_Vp>>\n\t\t\t\t      _M_cached_begin;\n\n    public:\n      reverse_view() requires default_initializable<_Vp> = default;\n\n      constexpr explicit\n      reverse_view(_Vp __r)\n\t: _M_base(std::move(__r))\n\t{ }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr reverse_iterator<iterator_t<_Vp>>\n      begin()\n      {\n\tif constexpr (_S_needs_cached_begin)\n\t  if (_M_cached_begin._M_has_value())\n\t    return std::make_reverse_iterator(_M_cached_begin._M_get(_M_base));\n\n\tauto __it = ranges::next(ranges::begin(_M_base), ranges::end(_M_base));\n\tif constexpr (_S_needs_cached_begin)\n\t  _M_cached_begin._M_set(_M_base, __it);\n\treturn std::make_reverse_iterator(std::move(__it));\n      }\n\n      constexpr auto\n      begin() requires common_range<_Vp>\n      { return std::make_reverse_iterator(ranges::end(_M_base)); }\n\n      constexpr auto\n      begin() const requires common_range<const _Vp>\n      { return std::make_reverse_iterator(ranges::end(_M_base)); }\n\n      constexpr reverse_iterator<iterator_t<_Vp>>\n      end()\n      { return std::make_reverse_iterator(ranges::begin(_M_base)); }\n\n      constexpr auto\n      end() const requires common_range<const _Vp>\n      { return std::make_reverse_iterator(ranges::begin(_M_base)); }\n\n      constexpr auto\n      size() requires sized_range<_Vp>\n      { return ranges::size(_M_base); }\n\n      constexpr auto\n      size() const requires sized_range<const _Vp>\n      { return ranges::size(_M_base); }\n    };\n\n  template<typename _Range>\n    reverse_view(_Range&&) -> reverse_view<views::all_t<_Range>>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<reverse_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename>\n\tinline constexpr bool __is_reversible_subrange = false;\n\n      template<typename _Iter, subrange_kind _Kind>\n\tinline constexpr bool\n\t  __is_reversible_subrange<subrange<reverse_iterator<_Iter>,\n\t\t\t\t\t    reverse_iterator<_Iter>,\n\t\t\t\t\t    _Kind>> = true;\n\n      template<typename>\n\tinline constexpr bool __is_reverse_view = false;\n\n      template<typename _Vp>\n\tinline constexpr bool __is_reverse_view<reverse_view<_Vp>> = true;\n\n      template<typename _Range>\n\tconcept __can_reverse_view\n\t  = requires { reverse_view{std::declval<_Range>()}; };\n    } // namespace __detail\n\n    struct _Reverse : __adaptor::_RangeAdaptorClosure<_Reverse>\n    {\n      template<viewable_range _Range>\n\trequires __detail::__is_reverse_view<remove_cvref_t<_Range>>\n\t  || __detail::__is_reversible_subrange<remove_cvref_t<_Range>>\n\t  || __detail::__can_reverse_view<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\t{\n\t  using _Tp = remove_cvref_t<_Range>;\n\t  if constexpr (__detail::__is_reverse_view<_Tp>)\n\t    return std::forward<_Range>(__r).base();\n\t  else if constexpr (__detail::__is_reversible_subrange<_Tp>)\n\t    {\n\t      using _Iter = decltype(ranges::begin(__r).base());\n\t      if constexpr (sized_range<_Tp>)\n\t\treturn subrange<_Iter, _Iter, subrange_kind::sized>\n\t\t\t{__r.end().base(), __r.begin().base(), __r.size()};\n\t      else\n\t\treturn subrange<_Iter, _Iter, subrange_kind::unsized>\n\t\t\t{__r.end().base(), __r.begin().base()};\n\t    }\n\t  else\n\t    return reverse_view{std::forward<_Range>(__r)};\n\t}\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n    inline constexpr _Reverse reverse;\n  } // namespace views\n\n  namespace __detail\n  {\n#if __cpp_lib_tuple_like // >= C++23\n    template<typename _Tp, size_t _Nm>\n    concept __has_tuple_element = __tuple_like<_Tp> && _Nm < tuple_size_v<_Tp>;\n#else\n    template<typename _Tp, size_t _Nm>\n    concept __has_tuple_element = requires(_Tp __t)\n      {\n\ttypename tuple_size<_Tp>::type;\n\trequires _Nm < tuple_size_v<_Tp>;\n\ttypename tuple_element_t<_Nm, _Tp>;\n\t{ std::get<_Nm>(__t) }\n\t  -> convertible_to<const tuple_element_t<_Nm, _Tp>&>;\n      };\n#endif\n\n    template<typename _Tp, size_t _Nm>\n      concept __returnable_element\n\t= is_reference_v<_Tp> || move_constructible<tuple_element_t<_Nm, _Tp>>;\n  }\n\n  template<input_range _Vp, size_t _Nm>\n    requires view<_Vp>\n      && __detail::__has_tuple_element<range_value_t<_Vp>, _Nm>\n      && __detail::__has_tuple_element<remove_reference_t<range_reference_t<_Vp>>,\n\t\t\t\t       _Nm>\n      && __detail::__returnable_element<range_reference_t<_Vp>, _Nm>\n    class elements_view : public view_interface<elements_view<_Vp, _Nm>>\n    {\n    public:\n      elements_view() requires default_initializable<_Vp> = default;\n\n      constexpr explicit\n      elements_view(_Vp __base)\n\t: _M_base(std::move(__base))\n      { }\n\n      constexpr _Vp\n      base() const& requires copy_constructible<_Vp>\n      { return _M_base; }\n\n      constexpr _Vp\n      base() &&\n      { return std::move(_M_base); }\n\n      constexpr auto\n      begin() requires (!__detail::__simple_view<_Vp>)\n      { return _Iterator<false>(ranges::begin(_M_base)); }\n\n      constexpr auto\n      begin() const requires range<const _Vp>\n      { return _Iterator<true>(ranges::begin(_M_base)); }\n\n      constexpr auto\n      end() requires (!__detail::__simple_view<_Vp> && !common_range<_Vp>)\n      { return _Sentinel<false>{ranges::end(_M_base)}; }\n\n      constexpr auto\n      end() requires (!__detail::__simple_view<_Vp> && common_range<_Vp>)\n      { return _Iterator<false>{ranges::end(_M_base)}; }\n\n      constexpr auto\n      end() const requires range<const _Vp>\n      { return _Sentinel<true>{ranges::end(_M_base)}; }\n\n      constexpr auto\n      end() const requires common_range<const _Vp>\n      { return _Iterator<true>{ranges::end(_M_base)}; }\n\n      constexpr auto\n      size() requires sized_range<_Vp>\n      { return ranges::size(_M_base); }\n\n      constexpr auto\n      size() const requires sized_range<const _Vp>\n      { return ranges::size(_M_base); }\n\n    private:\n      template<bool _Const>\n\tusing _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n      template<bool _Const>\n\tstruct __iter_cat\n\t{ };\n\n      template<bool _Const>\n\trequires forward_range<_Base<_Const>>\n\tstruct __iter_cat<_Const>\n\t{\n\tprivate:\n\t  static auto _S_iter_cat()\n\t  {\n\t    using _Base = elements_view::_Base<_Const>;\n\t    using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n\t    using _Res = decltype((std::get<_Nm>(*std::declval<iterator_t<_Base>>())));\n\t    if constexpr (!is_lvalue_reference_v<_Res>)\n\t      return input_iterator_tag{};\n\t    else if constexpr (derived_from<_Cat, random_access_iterator_tag>)\n\t      return random_access_iterator_tag{};\n\t    else\n\t      return _Cat{};\n\t  }\n\tpublic:\n\t  using iterator_category = decltype(_S_iter_cat());\n\t};\n\n      template<bool _Const>\n\tstruct _Sentinel;\n\n      template<bool _Const>\n\tstruct _Iterator : __iter_cat<_Const>\n\t{\n\tprivate:\n\t  using _Base = elements_view::_Base<_Const>;\n\n\t  iterator_t<_Base> _M_current = iterator_t<_Base>();\n\n\t  static constexpr decltype(auto)\n\t  _S_get_element(const iterator_t<_Base>& __i)\n\t  {\n\t    if constexpr (is_reference_v<range_reference_t<_Base>>)\n\t      return std::get<_Nm>(*__i);\n\t    else\n\t      {\n\t\tusing _Et = remove_cv_t<tuple_element_t<_Nm, range_reference_t<_Base>>>;\n\t\treturn static_cast<_Et>(std::get<_Nm>(*__i));\n\t      }\n\t  }\n\n\t  static auto\n\t  _S_iter_concept()\n\t  {\n\t    if constexpr (random_access_range<_Base>)\n\t      return random_access_iterator_tag{};\n\t    else if constexpr (bidirectional_range<_Base>)\n\t      return bidirectional_iterator_tag{};\n\t    else if constexpr (forward_range<_Base>)\n\t      return forward_iterator_tag{};\n\t    else\n\t      return input_iterator_tag{};\n\t  }\n\n\t  friend _Iterator<!_Const>;\n\n\tpublic:\n\t  using iterator_concept = decltype(_S_iter_concept());\n\t  // iterator_category defined in elements_view::__iter_cat\n\t  using value_type\n\t    = remove_cvref_t<tuple_element_t<_Nm, range_value_t<_Base>>>;\n\t  using difference_type = range_difference_t<_Base>;\n\n\t  _Iterator() requires default_initializable<iterator_t<_Base>> = default;\n\n\t  constexpr explicit\n\t  _Iterator(iterator_t<_Base> __current)\n\t    : _M_current(std::move(__current))\n\t  { }\n\n\t  constexpr\n\t  _Iterator(_Iterator<!_Const> __i)\n\t    requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n\t    : _M_current(std::move(__i._M_current))\n\t  { }\n\n\t  constexpr const iterator_t<_Base>&\n\t  base() const& noexcept\n\t  { return _M_current; }\n\n\t  constexpr iterator_t<_Base>\n\t  base() &&\n\t  { return std::move(_M_current); }\n\n\t  constexpr decltype(auto)\n\t  operator*() const\n\t  { return _S_get_element(_M_current); }\n\n\t  constexpr _Iterator&\n\t  operator++()\n\t  {\n\t    ++_M_current;\n\t    return *this;\n\t  }\n\n\t  constexpr void\n\t  operator++(int)\n\t  { ++_M_current; }\n\n\t  constexpr _Iterator\n\t  operator++(int) requires forward_range<_Base>\n\t  {\n\t    auto __tmp = *this;\n\t    ++_M_current;\n\t    return __tmp;\n\t  }\n\n\t  constexpr _Iterator&\n\t  operator--() requires bidirectional_range<_Base>\n\t  {\n\t    --_M_current;\n\t    return *this;\n\t  }\n\n\t  constexpr _Iterator\n\t  operator--(int) requires bidirectional_range<_Base>\n\t  {\n\t    auto __tmp = *this;\n\t    --_M_current;\n\t    return __tmp;\n\t  }\n\n\t  constexpr _Iterator&\n\t  operator+=(difference_type __n)\n\t    requires random_access_range<_Base>\n\t  {\n\t    _M_current += __n;\n\t    return *this;\n\t  }\n\n\t  constexpr _Iterator&\n\t  operator-=(difference_type __n)\n\t    requires random_access_range<_Base>\n\t  {\n\t    _M_current -= __n;\n\t    return *this;\n\t  }\n\n\t  constexpr decltype(auto)\n\t  operator[](difference_type __n) const\n\t    requires random_access_range<_Base>\n\t  { return _S_get_element(_M_current + __n); }\n\n\t  friend constexpr bool\n\t  operator==(const _Iterator& __x, const _Iterator& __y)\n\t    requires equality_comparable<iterator_t<_Base>>\n\t  { return __x._M_current == __y._M_current; }\n\n\t  friend constexpr bool\n\t  operator<(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return __x._M_current < __y._M_current; }\n\n\t  friend constexpr bool\n\t  operator>(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return __y._M_current < __x._M_current; }\n\n\t  friend constexpr bool\n\t  operator<=(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return !(__y._M_current > __x._M_current); }\n\n\t  friend constexpr bool\n\t  operator>=(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return !(__x._M_current > __y._M_current); }\n\n#ifdef __cpp_lib_three_way_comparison\n\t  friend constexpr auto\n\t  operator<=>(const _Iterator& __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t      && three_way_comparable<iterator_t<_Base>>\n\t  { return __x._M_current <=> __y._M_current; }\n#endif\n\n\t  friend constexpr _Iterator\n\t  operator+(const _Iterator& __x, difference_type __y)\n\t    requires random_access_range<_Base>\n\t  { return _Iterator{__x} += __y; }\n\n\t  friend constexpr _Iterator\n\t  operator+(difference_type __x, const _Iterator& __y)\n\t    requires random_access_range<_Base>\n\t  { return __y + __x; }\n\n\t  friend constexpr _Iterator\n\t  operator-(const _Iterator& __x, difference_type __y)\n\t    requires random_access_range<_Base>\n\t  { return _Iterator{__x} -= __y; }\n\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3483. transform_view::iterator's difference is overconstrained\n\t  friend constexpr difference_type\n\t  operator-(const _Iterator& __x, const _Iterator& __y)\n\t    requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n\t  { return __x._M_current - __y._M_current; }\n\n\t  template <bool> friend struct _Sentinel;\n\t};\n\n      template<bool _Const>\n\tstruct _Sentinel\n\t{\n\tprivate:\n\t  template<bool _Const2>\n\t    constexpr bool\n\t    _M_equal(const _Iterator<_Const2>& __x) const\n\t    { return __x._M_current == _M_end; }\n\n\t  template<bool _Const2>\n\t    constexpr auto\n\t    _M_distance_from(const _Iterator<_Const2>& __i) const\n\t    { return _M_end - __i._M_current; }\n\n\t  using _Base = elements_view::_Base<_Const>;\n\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\n\tpublic:\n\t  _Sentinel() = default;\n\n\t  constexpr explicit\n\t  _Sentinel(sentinel_t<_Base> __end)\n\t    : _M_end(std::move(__end))\n\t  { }\n\n\t  constexpr\n\t  _Sentinel(_Sentinel<!_Const> __other)\n\t    requires _Const\n\t      && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n\t    : _M_end(std::move(__other._M_end))\n\t  { }\n\n\t  constexpr sentinel_t<_Base>\n\t  base() const\n\t  { return _M_end; }\n\n\t  template<bool _Const2>\n\t    requires sentinel_for<sentinel_t<_Base>,\n\t\t       iterator_t<__detail::__maybe_const_t<_Const2, _Vp>>>\n\t    friend constexpr bool\n\t    operator==(const _Iterator<_Const2>& __x, const _Sentinel& __y)\n\t    { return __y._M_equal(__x); }\n\n\t  template<bool _Const2,\n\t\t   typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>\n\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>\n\t    friend constexpr range_difference_t<_Base2>\n\t    operator-(const _Iterator<_Const2>& __x, const _Sentinel& __y)\n\t    { return -__y._M_distance_from(__x); }\n\n\t  template<bool _Const2,\n\t\t   typename _Base2 = __detail::__maybe_const_t<_Const2, _Vp>>\n\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base2>>\n\t    friend constexpr range_difference_t<_Base2>\n\t    operator-(const _Sentinel& __x, const _Iterator<_Const2>& __y)\n\t    { return __x._M_distance_from(__y); }\n\n\t  friend _Sentinel<!_Const>;\n\t};\n\n      _Vp _M_base = _Vp();\n    };\n\n  template<typename _Tp, size_t _Nm>\n    inline constexpr bool enable_borrowed_range<elements_view<_Tp, _Nm>>\n      = enable_borrowed_range<_Tp>;\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 3563. keys_view example is broken\n  template<typename _Range>\n    using keys_view = elements_view<_Range, 0>;\n\n  template<typename _Range>\n    using values_view = elements_view<_Range, 1>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<size_t _Nm, typename _Range>\n\tconcept __can_elements_view\n\t  = requires { elements_view<all_t<_Range>, _Nm>{std::declval<_Range>()}; };\n    } // namespace __detail\n\n    template<size_t _Nm>\n      struct _Elements : __adaptor::_RangeAdaptorClosure<_Elements<_Nm>>\n      {\n\ttemplate<viewable_range _Range>\n\t  requires __detail::__can_elements_view<_Nm, _Range>\n\t  constexpr auto\n\t  operator() [[nodiscard]] (_Range&& __r) const\n\t  {\n\t    return elements_view<all_t<_Range>, _Nm>{std::forward<_Range>(__r)};\n\t  }\n\n\tstatic constexpr bool _S_has_simple_call_op = true;\n      };\n\n    template<size_t _Nm>\n      inline constexpr _Elements<_Nm> elements;\n    inline constexpr auto keys = elements<0>;\n    inline constexpr auto values = elements<1>;\n  } // namespace views\n\n#ifdef __cpp_lib_ranges_zip // C++ >= 23\n  namespace __detail\n  {\n    template<typename... _Rs>\n      concept __zip_is_common = (sizeof...(_Rs) == 1 && (common_range<_Rs> && ...))\n\t|| (!(bidirectional_range<_Rs> && ...) && (common_range<_Rs> && ...))\n\t|| ((random_access_range<_Rs> && ...) && (sized_range<_Rs> && ...));\n\n    template<typename _Fp, typename _Tuple>\n      constexpr auto\n      __tuple_transform(_Fp&& __f, _Tuple&& __tuple)\n      {\n\treturn std::apply([&]<typename... _Ts>(_Ts&&... __elts) {\n\t  return tuple<invoke_result_t<_Fp&, _Ts>...>\n\t    (std::__invoke(__f, std::forward<_Ts>(__elts))...);\n\t}, std::forward<_Tuple>(__tuple));\n      }\n\n    template<typename _Fp, typename _Tuple>\n      constexpr void\n      __tuple_for_each(_Fp&& __f, _Tuple&& __tuple)\n      {\n\tstd::apply([&]<typename... _Ts>(_Ts&&... __elts) {\n\t  (std::__invoke(__f, std::forward<_Ts>(__elts)), ...);\n\t}, std::forward<_Tuple>(__tuple));\n      }\n  } // namespace __detail\n\n  template<input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0)\n  class zip_view : public view_interface<zip_view<_Vs...>>\n  {\n    tuple<_Vs...> _M_views;\n\n    template<bool> class _Iterator;\n    template<bool> class _Sentinel;\n\n  public:\n    zip_view() = default;\n\n    constexpr explicit\n    zip_view(_Vs... __views)\n      : _M_views(std::move(__views)...)\n    { }\n\n    constexpr auto\n    begin() requires (!(__detail::__simple_view<_Vs> && ...))\n    { return _Iterator<false>(__detail::__tuple_transform(ranges::begin, _M_views)); }\n\n    constexpr auto\n    begin() const requires (range<const _Vs> && ...)\n    { return _Iterator<true>(__detail::__tuple_transform(ranges::begin, _M_views)); }\n\n    constexpr auto\n    end() requires (!(__detail::__simple_view<_Vs> && ...))\n    {\n      if constexpr (!__detail::__zip_is_common<_Vs...>)\n        return _Sentinel<false>(__detail::__tuple_transform(ranges::end, _M_views));\n      else if constexpr ((random_access_range<_Vs> && ...))\n        return begin() + iter_difference_t<_Iterator<false>>(size());\n      else\n        return _Iterator<false>(__detail::__tuple_transform(ranges::end, _M_views));\n    }\n\n    constexpr auto\n    end() const requires (range<const _Vs> && ...)\n    {\n      if constexpr (!__detail::__zip_is_common<const _Vs...>)\n        return _Sentinel<true>(__detail::__tuple_transform(ranges::end, _M_views));\n      else if constexpr ((random_access_range<const _Vs> && ...))\n        return begin() + iter_difference_t<_Iterator<true>>(size());\n      else\n        return _Iterator<true>(__detail::__tuple_transform(ranges::end, _M_views));\n    }\n\n    constexpr auto\n    size() requires (sized_range<_Vs> && ...)\n    {\n      return std::apply([](auto... sizes) {\n\tusing _CT = __detail::__make_unsigned_like_t<common_type_t<decltype(sizes)...>>;\n\treturn ranges::min({_CT(sizes)...});\n      }, __detail::__tuple_transform(ranges::size, _M_views));\n    }\n\n    constexpr auto\n    size() const requires (sized_range<const _Vs> && ...)\n    {\n      return std::apply([](auto... sizes) {\n\tusing _CT = __detail::__make_unsigned_like_t<common_type_t<decltype(sizes)...>>;\n\treturn ranges::min({_CT(sizes)...});\n      }, __detail::__tuple_transform(ranges::size, _M_views));\n    }\n  };\n\n  template<typename... _Rs>\n    zip_view(_Rs&&...) -> zip_view<views::all_t<_Rs>...>;\n\n  template<typename... _Views>\n    inline constexpr bool enable_borrowed_range<zip_view<_Views...>>\n      = (enable_borrowed_range<_Views> && ...);\n\n  namespace __detail\n  {\n    template<bool _Const, typename... _Vs>\n      concept __all_random_access\n\t= (random_access_range<__maybe_const_t<_Const, _Vs>> && ...);\n\n    template<bool _Const, typename... _Vs>\n      concept __all_bidirectional\n\t= (bidirectional_range<__maybe_const_t<_Const, _Vs>> && ...);\n\n    template<bool _Const, typename... _Vs>\n      concept __all_forward\n\t= (forward_range<__maybe_const_t<_Const, _Vs>> && ...);\n\n    template<bool _Const, typename... _Views>\n      struct __zip_view_iter_cat\n      { };\n\n    template<bool _Const, typename... _Views>\n      requires __all_forward<_Const, _Views...>\n      struct __zip_view_iter_cat<_Const, _Views...>\n      { using iterator_category = input_iterator_tag; };\n  } // namespace __detail\n\n  template<input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0)\n  template<bool _Const>\n  class zip_view<_Vs...>::_Iterator\n    : public __detail::__zip_view_iter_cat<_Const, _Vs...>\n  {\n#ifdef _GLIBCXX_CLANG // LLVM-61763 workaround\n  public:\n#endif\n    tuple<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>...> _M_current;\n\n    constexpr explicit\n    _Iterator(decltype(_M_current) __current)\n      : _M_current(std::move(__current))\n    { }\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (__detail::__all_random_access<_Const, _Vs...>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (__detail::__all_bidirectional<_Const, _Vs...>)\n\treturn bidirectional_iterator_tag{};\n      else if constexpr (__detail::__all_forward<_Const, _Vs...>)\n\treturn forward_iterator_tag{};\n      else\n\treturn input_iterator_tag{};\n    }\n\n#ifndef _GLIBCXX_CLANG // LLVM-61763 workaround\n    template<move_constructible _Fp, input_range... _Ws>\n      requires (view<_Ws> && ...) && (sizeof...(_Ws) > 0) && is_object_v<_Fp>\n\t&& regular_invocable<_Fp&, range_reference_t<_Ws>...>\n\t&& std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Ws>...>>\n      friend class zip_transform_view;\n#endif\n\n  public:\n    // iterator_category defined in __zip_view_iter_cat\n    using iterator_concept = decltype(_S_iter_concept());\n    using value_type\n      = tuple<range_value_t<__detail::__maybe_const_t<_Const, _Vs>>...>;\n    using difference_type\n      = common_type_t<range_difference_t<__detail::__maybe_const_t<_Const, _Vs>>...>;\n\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const\n\t&& (convertible_to<iterator_t<_Vs>,\n\t\t\t   iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n      : _M_current(std::move(__i._M_current))\n    { }\n\n    constexpr auto\n    operator*() const\n    {\n      auto __f = [](auto& __i) -> decltype(auto) {\n\treturn *__i;\n      };\n      return __detail::__tuple_transform(__f, _M_current);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      __detail::__tuple_for_each([](auto& __i) { ++__i; }, _M_current);\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    constexpr _Iterator\n    operator++(int)\n      requires __detail::__all_forward<_Const, _Vs...>\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--()\n      requires __detail::__all_bidirectional<_Const, _Vs...>\n    {\n      __detail::__tuple_for_each([](auto& __i) { --__i; }, _M_current);\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int)\n      requires __detail::__all_bidirectional<_Const, _Vs...>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __x)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    {\n      auto __f = [&]<typename _It>(_It& __i) {\n\t__i += iter_difference_t<_It>(__x);\n      };\n      __detail::__tuple_for_each(__f, _M_current);\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __x)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    {\n      auto __f = [&]<typename _It>(_It& __i) {\n\t__i -= iter_difference_t<_It>(__x);\n      };\n      __detail::__tuple_for_each(__f, _M_current);\n      return *this;\n    }\n\n    constexpr auto\n    operator[](difference_type __n) const\n      requires __detail::__all_random_access<_Const, _Vs...>\n    {\n      auto __f = [&]<typename _It>(_It& __i) -> decltype(auto) {\n\treturn __i[iter_difference_t<_It>(__n)];\n      };\n      return __detail::__tuple_transform(__f, _M_current);\n    }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n      requires (equality_comparable<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n    {\n      if constexpr (__detail::__all_bidirectional<_Const, _Vs...>)\n\treturn __x._M_current == __y._M_current;\n      else\n\treturn [&]<size_t... _Is>(index_sequence<_Is...>) {\n\t  return ((std::get<_Is>(__x._M_current) == std::get<_Is>(__y._M_current)) || ...);\n\t}(make_index_sequence<sizeof...(_Vs)>{});\n    }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    { return __x._M_current <=> __y._M_current; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __i, difference_type __n)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    {\n      auto __r = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __i)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    {\n      auto __r = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __i, difference_type __n)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    {\n      auto __r = __i;\n      __r -= __n;\n      return __r;\n    }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires (sized_sentinel_for<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>,\n\t\t\t\t   iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n    {\n      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n\treturn ranges::min({difference_type(std::get<_Is>(__x._M_current)\n\t\t\t\t\t    - std::get<_Is>(__y._M_current))...},\n\t\t\t   ranges::less{},\n\t\t\t   [](difference_type __i) {\n\t\t\t     return __detail::__to_unsigned_like(__i < 0 ? -__i : __i);\n\t\t\t   });\n      }(make_index_sequence<sizeof...(_Vs)>{});\n    }\n\n    friend constexpr auto\n    iter_move(const _Iterator& __i)\n    { return __detail::__tuple_transform(ranges::iter_move, __i._M_current); }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __l, const _Iterator& __r)\n      requires (indirectly_swappable<iterator_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n    {\n      [&]<size_t... _Is>(index_sequence<_Is...>) {\n\t(ranges::iter_swap(std::get<_Is>(__l._M_current), std::get<_Is>(__r._M_current)), ...);\n      }(make_index_sequence<sizeof...(_Vs)>{});\n    }\n\n    friend class zip_view;\n  };\n\n  template<input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0)\n  template<bool _Const>\n  class zip_view<_Vs...>::_Sentinel\n  {\n    tuple<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>...> _M_end;\n\n    constexpr explicit\n    _Sentinel(decltype(_M_end) __end)\n      : _M_end(__end)\n    { }\n\n    friend class zip_view;\n\n  public:\n    _Sentinel() = default;\n\n    constexpr\n    _Sentinel(_Sentinel<!_Const> __i)\n      requires _Const\n\t&& (convertible_to<sentinel_t<_Vs>,\n\t\t\t   sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>> && ...)\n      : _M_end(std::move(__i._M_end))\n    { }\n\n    template<bool _OtherConst>\n      requires (sentinel_for<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>,\n\t\t\t     iterator_t<__detail::__maybe_const_t<_OtherConst, _Vs>>> && ...)\n    friend constexpr bool\n    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    {\n      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n\treturn ((std::get<_Is>(__x._M_current) == std::get<_Is>(__y._M_end)) || ...);\n      }(make_index_sequence<sizeof...(_Vs)>{});\n    }\n\n    template<bool _OtherConst>\n      requires (sized_sentinel_for<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>,\n\t\t\t\t   iterator_t<__detail::__maybe_const_t<_OtherConst, _Vs>>> && ...)\n    friend constexpr auto\n    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    {\n      using _Ret\n\t= common_type_t<range_difference_t<__detail::__maybe_const_t<_OtherConst, _Vs>>...>;\n      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n\treturn ranges::min({_Ret(std::get<_Is>(__x._M_current) - std::get<_Is>(__y._M_end))...},\n\t\t\t   ranges::less{},\n\t\t\t   [](_Ret __i) {\n\t\t\t     return __detail::__to_unsigned_like(__i < 0 ? -__i : __i);\n\t\t\t   });\n      }(make_index_sequence<sizeof...(_Vs)>{});\n    }\n\n    template<bool _OtherConst>\n      requires (sized_sentinel_for<sentinel_t<__detail::__maybe_const_t<_Const, _Vs>>,\n\t\t\t\t   iterator_t<__detail::__maybe_const_t<_OtherConst, _Vs>>> && ...)\n    friend constexpr auto\n    operator-(const _Sentinel& __y, const _Iterator<_OtherConst>& __x)\n    { return -(__x - __y); }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename... _Ts>\n\tconcept __can_zip_view\n\t  = requires { zip_view<all_t<_Ts>...>(std::declval<_Ts>()...); };\n    }\n\n    struct _Zip\n    {\n      template<typename... _Ts>\n\trequires (sizeof...(_Ts) == 0 || __detail::__can_zip_view<_Ts...>)\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Ts&&... __ts) const\n\t{\n\t  if constexpr (sizeof...(_Ts) == 0)\n\t    return views::empty<tuple<>>;\n\t  else\n\t    return zip_view<all_t<_Ts>...>(std::forward<_Ts>(__ts)...);\n\t}\n    };\n\n    inline constexpr _Zip zip;\n  }\n\n  namespace __detail\n  {\n    template<typename _Range, bool _Const>\n      using __range_iter_cat\n\t= typename iterator_traits<iterator_t<__maybe_const_t<_Const, _Range>>>::iterator_category;\n  }\n\n  template<move_constructible _Fp, input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && is_object_v<_Fp>\n      && regular_invocable<_Fp&, range_reference_t<_Vs>...>\n      && std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Vs>...>>\n  class zip_transform_view : public view_interface<zip_transform_view<_Fp, _Vs...>>\n  {\n    [[no_unique_address]] __detail::__box<_Fp> _M_fun;\n    zip_view<_Vs...> _M_zip;\n\n    using _InnerView = zip_view<_Vs...>;\n\n    template<bool _Const>\n      using __ziperator = iterator_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n\n    template<bool _Const>\n      using __zentinel = sentinel_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n\n    template<bool _Const>\n      using _Base = __detail::__maybe_const_t<_Const, _InnerView>;\n\n    template<bool _Const>\n      struct __iter_cat\n      { };\n\n    template<bool _Const>\n      requires forward_range<_Base<_Const>>\n      struct __iter_cat<_Const>\n      {\n      private:\n\tstatic auto\n\t_S_iter_cat()\n\t{\n\t  using __detail::__maybe_const_t;\n\t  using __detail::__range_iter_cat;\n\t  using _Res = invoke_result_t<__maybe_const_t<_Const, _Fp>&,\n\t\t\t\t       range_reference_t<__maybe_const_t<_Const, _Vs>>...>;\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3798. Rvalue reference and iterator_category\n\t  if constexpr (!is_reference_v<_Res>)\n\t    return input_iterator_tag{};\n\t  else if constexpr ((derived_from<__range_iter_cat<_Vs, _Const>,\n\t\t\t\t\t   random_access_iterator_tag> && ...))\n\t    return random_access_iterator_tag{};\n\t  else if constexpr ((derived_from<__range_iter_cat<_Vs, _Const>,\n\t\t\t\t\t   bidirectional_iterator_tag> && ...))\n\t    return bidirectional_iterator_tag{};\n\t  else if constexpr ((derived_from<__range_iter_cat<_Vs, _Const>,\n\t\t\t\t\t   forward_iterator_tag> && ...))\n\t    return forward_iterator_tag{};\n\t  else\n\t    return input_iterator_tag{};\n\t}\n      public:\n\tusing iterator_category = decltype(_S_iter_cat());\n      };\n\n    template<bool> class _Iterator;\n    template<bool> class _Sentinel;\n\n  public:\n    zip_transform_view() = default;\n\n    constexpr explicit\n    zip_transform_view(_Fp __fun, _Vs... __views)\n      : _M_fun(std::move(__fun)), _M_zip(std::move(__views)...)\n    { }\n\n    constexpr auto\n    begin()\n    { return _Iterator<false>(*this, _M_zip.begin()); }\n\n    constexpr auto\n    begin() const\n      requires range<const _InnerView>\n\t&& regular_invocable<const _Fp&, range_reference_t<const _Vs>...>\n    { return _Iterator<true>(*this, _M_zip.begin()); }\n\n    constexpr auto\n    end()\n    {\n      if constexpr (common_range<_InnerView>)\n\treturn _Iterator<false>(*this, _M_zip.end());\n      else\n\treturn _Sentinel<false>(_M_zip.end());\n    }\n\n    constexpr auto\n    end() const\n      requires range<const _InnerView>\n\t&& regular_invocable<const _Fp&, range_reference_t<const _Vs>...>\n    {\n      if constexpr (common_range<const _InnerView>)\n\treturn _Iterator<true>(*this, _M_zip.end());\n      else\n\treturn _Sentinel<true>(_M_zip.end());\n    }\n\n    constexpr auto\n    size() requires sized_range<_InnerView>\n    { return _M_zip.size(); }\n\n    constexpr auto\n    size() const requires sized_range<const _InnerView>\n    { return _M_zip.size(); }\n  };\n\n  template<class _Fp, class... Rs>\n    zip_transform_view(_Fp, Rs&&...) -> zip_transform_view<_Fp, views::all_t<Rs>...>;\n\n  template<move_constructible _Fp, input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && is_object_v<_Fp>\n      && regular_invocable<_Fp&, range_reference_t<_Vs>...>\n      && std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Vs>...>>\n  template<bool _Const>\n  class zip_transform_view<_Fp, _Vs...>::_Iterator : public __iter_cat<_Const>\n  {\n    using _Parent = __detail::__maybe_const_t<_Const, zip_transform_view>;\n\n    _Parent* _M_parent = nullptr;\n    __ziperator<_Const> _M_inner;\n\n    constexpr\n    _Iterator(_Parent& __parent, __ziperator<_Const> __inner)\n      : _M_parent(std::__addressof(__parent)), _M_inner(std::move(__inner))\n    { }\n\n    friend class zip_transform_view;\n\n  public:\n    // iterator_category defined in zip_transform_view::__iter_cat\n    using iterator_concept = typename __ziperator<_Const>::iterator_concept;\n    using value_type\n      = remove_cvref_t<invoke_result_t<__detail::__maybe_const_t<_Const, _Fp>&,\n\t\t\t\t       range_reference_t<__detail::__maybe_const_t<_Const, _Vs>>...>>;\n    using difference_type = range_difference_t<_Base<_Const>>;\n\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const && convertible_to<__ziperator<false>, __ziperator<_Const>>\n      : _M_parent(__i._M_parent), _M_inner(std::move(__i._M_inner))\n    { }\n\n    constexpr decltype(auto)\n    operator*() const\n    {\n      return std::apply([&](const auto&... __iters) -> decltype(auto) {\n        return std::__invoke(*_M_parent->_M_fun, *__iters...);\n      }, _M_inner._M_current);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      ++_M_inner;\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    constexpr _Iterator\n    operator++(int) requires forward_range<_Base<_Const>>\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Base<_Const>>\n    {\n      --_M_inner;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Base<_Const>>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __x) requires random_access_range<_Base<_Const>>\n    {\n      _M_inner += __x;\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __x) requires random_access_range<_Base<_Const>>\n    {\n      _M_inner -= __x;\n      return *this;\n    }\n\n    constexpr decltype(auto)\n    operator[](difference_type __n) const requires random_access_range<_Base<_Const>>\n    {\n      return std::apply([&]<typename... _Is>(const _Is&... __iters) -> decltype(auto) {\n        return std::__invoke(*_M_parent->_M_fun, __iters[iter_difference_t<_Is>(__n)]...);\n      }, _M_inner._M_current);\n    }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n      requires equality_comparable<__ziperator<_Const>>\n    { return __x._M_inner == __y._M_inner; }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base<_Const>>\n    { return __x._M_inner <=> __y._M_inner; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base<_Const>>\n    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __i)\n      requires random_access_range<_Base<_Const>>\n    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base<_Const>>\n    { return _Iterator(*__i._M_parent, __i._M_inner - __n); }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires sized_sentinel_for<__ziperator<_Const>, __ziperator<_Const>>\n    { return __x._M_inner - __y._M_inner; }\n  };\n\n  template<move_constructible _Fp, input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && is_object_v<_Fp>\n      && regular_invocable<_Fp&, range_reference_t<_Vs>...>\n      && std::__detail::__can_reference<invoke_result_t<_Fp&, range_reference_t<_Vs>...>>\n  template<bool _Const>\n  class zip_transform_view<_Fp, _Vs...>::_Sentinel\n  {\n    __zentinel<_Const> _M_inner;\n\n    constexpr explicit\n    _Sentinel(__zentinel<_Const> __inner)\n      : _M_inner(__inner)\n    { }\n\n    friend class zip_transform_view;\n\n  public:\n    _Sentinel() = default;\n\n    constexpr\n    _Sentinel(_Sentinel<!_Const> __i)\n      requires _Const && convertible_to<__zentinel<false>, __zentinel<_Const>>\n      : _M_inner(std::move(__i._M_inner))\n    { }\n\n    template<bool _OtherConst>\n      requires sentinel_for<__zentinel<_Const>, __ziperator<_OtherConst>>\n    friend constexpr bool\n    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_inner == __y._M_inner; }\n\n    template<bool _OtherConst>\n      requires sized_sentinel_for<__zentinel<_Const>, __ziperator<_OtherConst>>\n    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _InnerView>>\n    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_inner - __y._M_inner; }\n\n    template<bool _OtherConst>\n      requires sized_sentinel_for<__zentinel<_Const>, __ziperator<_OtherConst>>\n    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _InnerView>>\n    operator-(const _Sentinel& __x, const _Iterator<_OtherConst>& __y)\n    { return __x._M_inner - __y._M_inner; }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Fp, typename... _Ts>\n\tconcept __can_zip_transform_view\n\t  = requires { zip_transform_view(std::declval<_Fp>(), std::declval<_Ts>()...); };\n    }\n\n    struct _ZipTransform\n    {\n      template<typename _Fp>\n\trequires move_constructible<decay_t<_Fp>> && regular_invocable<decay_t<_Fp>&>\n\t  && is_object_v<decay_t<invoke_result_t<decay_t<_Fp>&>>>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Fp&&) const\n\t{\n\t  return views::empty<decay_t<invoke_result_t<decay_t<_Fp>&>>>;\n\t}\n\n      template<typename _Fp, typename... _Ts>\n\trequires (sizeof...(_Ts) != 0) && __detail::__can_zip_transform_view<_Fp, _Ts...>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Fp&& __f, _Ts&&... __ts) const\n\t{\n          return zip_transform_view(std::forward<_Fp>(__f), std::forward<_Ts>(__ts)...);\n\t}\n    };\n\n    inline constexpr _ZipTransform zip_transform;\n  }\n\n  template<forward_range _Vp, size_t _Nm>\n    requires view<_Vp> && (_Nm > 0)\n  class adjacent_view : public view_interface<adjacent_view<_Vp, _Nm>>\n  {\n    _Vp _M_base = _Vp();\n\n    template<bool> class _Iterator;\n    template<bool> class _Sentinel;\n\n    struct __as_sentinel\n    { };\n\n  public:\n    adjacent_view() requires default_initializable<_Vp> = default;\n\n    constexpr explicit\n    adjacent_view(_Vp __base)\n      : _M_base(std::move(__base))\n    { }\n\n    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n    // 3848. adjacent_view, adjacent_transform_view and slide_view missing base accessor\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin() requires (!__detail::__simple_view<_Vp>)\n    { return _Iterator<false>(ranges::begin(_M_base), ranges::end(_M_base)); }\n\n    constexpr auto\n    begin() const requires range<const _Vp>\n    { return _Iterator<true>(ranges::begin(_M_base), ranges::end(_M_base)); }\n\n    constexpr auto\n    end() requires (!__detail::__simple_view<_Vp>)\n    {\n      if constexpr (common_range<_Vp>)\n\treturn _Iterator<false>(__as_sentinel{}, ranges::begin(_M_base), ranges::end(_M_base));\n      else\n\treturn _Sentinel<false>(ranges::end(_M_base));\n    }\n\n    constexpr auto\n    end() const requires range<const _Vp>\n    {\n      if constexpr (common_range<const _Vp>)\n\treturn _Iterator<true>(__as_sentinel{}, ranges::begin(_M_base), ranges::end(_M_base));\n      else\n\treturn _Sentinel<true>(ranges::end(_M_base));\n    }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    {\n      using _ST = decltype(ranges::size(_M_base));\n      using _CT = common_type_t<_ST, size_t>;\n      auto __sz = static_cast<_CT>(ranges::size(_M_base));\n      __sz -= std::min<_CT>(__sz, _Nm - 1);\n      return static_cast<_ST>(__sz);\n    }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    {\n      using _ST = decltype(ranges::size(_M_base));\n      using _CT = common_type_t<_ST, size_t>;\n      auto __sz = static_cast<_CT>(ranges::size(_M_base));\n      __sz -= std::min<_CT>(__sz, _Nm - 1);\n      return static_cast<_ST>(__sz);\n    }\n  };\n\n  template<typename _Vp, size_t _Nm>\n    inline constexpr bool enable_borrowed_range<adjacent_view<_Vp, _Nm>>\n      = enable_borrowed_range<_Vp>;\n\n  namespace __detail\n  {\n    // Yields tuple<_Tp, ..., _Tp> with _Nm elements.\n    template<typename _Tp, size_t _Nm>\n      using __repeated_tuple = decltype(std::tuple_cat(std::declval<array<_Tp, _Nm>>()));\n\n    // For a functor F that is callable with N arguments, the expression\n    // declval<__unarize<F, N>>(x) is equivalent to declval<F>(x, ..., x).\n    template<typename _Fp, size_t _Nm>\n      struct __unarize\n      {\n\ttemplate<typename... _Ts>\n\t  static invoke_result_t<_Fp, _Ts...>\n\t  __tuple_apply(const tuple<_Ts...>&); // not defined\n\n\ttemplate<typename _Tp>\n\t  decltype(__tuple_apply(std::declval<__repeated_tuple<_Tp, _Nm>>()))\n\t  operator()(_Tp&&); // not defined\n      };\n  }\n\n  template<forward_range _Vp, size_t _Nm>\n    requires view<_Vp> && (_Nm > 0)\n  template<bool _Const>\n  class adjacent_view<_Vp, _Nm>::_Iterator\n  {\n#ifdef _GLIBCXX_CLANG // LLVM-61763 workaround\n  public:\n#endif\n    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n    array<iterator_t<_Base>, _Nm> _M_current = array<iterator_t<_Base>, _Nm>();\n\n    constexpr\n    _Iterator(iterator_t<_Base> __first, sentinel_t<_Base> __last)\n    {\n      for (auto& __i : _M_current)\n\t{\n\t  __i = __first;\n\t  ranges::advance(__first, 1, __last);\n\t}\n    }\n\n    constexpr\n    _Iterator(__as_sentinel, iterator_t<_Base> __first, iterator_t<_Base> __last)\n    {\n      if constexpr (!bidirectional_range<_Base>)\n\tfor (auto& __it : _M_current)\n\t  __it = __last;\n      else\n\tfor (size_t __i = 0; __i < _Nm; ++__i)\n\t  {\n\t    _M_current[_Nm - 1 - __i] = __last;\n\t    ranges::advance(__last, -1, __first);\n\t  }\n    }\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (random_access_range<_Base>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (bidirectional_range<_Base>)\n\treturn bidirectional_iterator_tag{};\n      else\n\treturn forward_iterator_tag{};\n    }\n\n    friend class adjacent_view;\n\n#ifndef _GLIBCXX_CLANG // LLVM-61763 workaround\n    template<forward_range _Wp, move_constructible _Fp, size_t _Mm>\n      requires view<_Wp> && (_Mm > 0) && is_object_v<_Fp>\n        && regular_invocable<__detail::__unarize<_Fp&, _Mm>, range_reference_t<_Wp>>\n        && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Mm>,\n\t\t\t\t\t\t\t range_reference_t<_Wp>>>\n      friend class adjacent_transform_view;\n#endif\n\n  public:\n    using iterator_category = input_iterator_tag;\n    using iterator_concept = decltype(_S_iter_concept());\n    using value_type = conditional_t<_Nm == 2,\n\t\t\t\t     pair<range_value_t<_Base>, range_value_t<_Base>>,\n\t\t\t\t     __detail::__repeated_tuple<range_value_t<_Base>, _Nm>>;\n    using difference_type = range_difference_t<_Base>;\n\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n    {\n      for (size_t __j = 0; __j < _Nm; ++__j)\n\t_M_current[__j] = std::move(__i._M_current[__j]);\n    }\n\n    constexpr auto\n    operator*() const\n    {\n      auto __f = [](auto& __i) -> decltype(auto) { return *__i; };\n      return __detail::__tuple_transform(__f, _M_current);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      for (auto& __i : _M_current)\n\t++__i;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator++(int)\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Base>\n    {\n      for (auto& __i : _M_current)\n\t--__i;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Base>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __x)\n      requires random_access_range<_Base>\n    {\n      for (auto& __i : _M_current)\n\t__i += __x;\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __x)\n      requires random_access_range<_Base>\n    {\n      for (auto& __i : _M_current)\n\t__i -= __x;\n      return *this;\n    }\n\n    constexpr auto\n    operator[](difference_type __n) const\n      requires random_access_range<_Base>\n    {\n      auto __f = [&](auto& __i) -> decltype(auto) { return __i[__n]; };\n      return __detail::__tuple_transform(__f, _M_current);\n    }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n    { return __x._M_current.back() == __y._M_current.back(); }\n\n    friend constexpr bool\n    operator<(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_current.back() < __y._M_current.back(); }\n\n    friend constexpr bool\n    operator>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __y < __x; }\n\n    friend constexpr bool\n    operator<=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__y < __x); }\n\n    friend constexpr bool\n    operator>=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__x < __y); }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n\t&& three_way_comparable<iterator_t<_Base>>\n    { return __x._M_current.back() <=> __y._M_current.back(); }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __i)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r -= __n;\n      return __r;\n    }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n    { return __x._M_current.back() - __y._M_current.back(); }\n\n    friend constexpr auto\n    iter_move(const _Iterator& __i)\n    { return __detail::__tuple_transform(ranges::iter_move, __i._M_current); }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __l, const _Iterator& __r)\n      requires indirectly_swappable<iterator_t<_Base>>\n    {\n      for (size_t __i = 0; __i < _Nm; __i++)\n\tranges::iter_swap(__l._M_current[__i], __r._M_current[__i]);\n    }\n  };\n\n  template<forward_range _Vp, size_t _Nm>\n    requires view<_Vp> && (_Nm > 0)\n  template<bool _Const>\n  class adjacent_view<_Vp, _Nm>::_Sentinel\n  {\n    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\n    constexpr explicit\n    _Sentinel(sentinel_t<_Base> __end)\n      : _M_end(__end)\n    { }\n\n    friend class adjacent_view;\n\n  public:\n    _Sentinel() = default;\n\n    constexpr\n    _Sentinel(_Sentinel<!_Const> __i)\n      requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n      : _M_end(std::move(__i._M_end))\n    { }\n\n    template<bool _OtherConst>\n      requires sentinel_for<sentinel_t<_Base>,\n\t\t\t    iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n    friend constexpr bool\n    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_current.back() == __y._M_end; }\n\n    template<bool _OtherConst>\n      requires sized_sentinel_for<sentinel_t<_Base>,\n\t\t\t\t  iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _Vp>>\n    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_current.back() - __y._M_end; }\n\n    template<bool _OtherConst>\n      requires sized_sentinel_for<sentinel_t<_Base>,\n\t\t\t\t  iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _Vp>>\n    operator-(const _Sentinel& __y, const _Iterator<_OtherConst>& __x)\n    { return __y._M_end - __x._M_current.back(); }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<size_t _Nm, typename _Range>\n\tconcept __can_adjacent_view\n\t  = requires { adjacent_view<all_t<_Range>, _Nm>(std::declval<_Range>()); };\n    }\n\n    template<size_t _Nm>\n      struct _Adjacent : __adaptor::_RangeAdaptorClosure<_Adjacent<_Nm>>\n      {\n\ttemplate<viewable_range _Range>\n\t  requires (_Nm == 0) || __detail::__can_adjacent_view<_Nm, _Range>\n\t  constexpr auto\n\t  operator() [[nodiscard]] (_Range&& __r) const\n\t  {\n\t    if constexpr (_Nm == 0)\n\t      return views::empty<tuple<>>;\n\t    else\n\t      return adjacent_view<all_t<_Range>, _Nm>(std::forward<_Range>(__r));\n\t  }\n      };\n\n    template<size_t _Nm>\n      inline constexpr _Adjacent<_Nm> adjacent;\n\n    inline constexpr auto pairwise = adjacent<2>;\n  }\n\n  template<forward_range _Vp, move_constructible _Fp, size_t _Nm>\n   requires view<_Vp> && (_Nm > 0) && is_object_v<_Fp>\n     && regular_invocable<__detail::__unarize<_Fp&, _Nm>, range_reference_t<_Vp>>\n     && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Nm>,\n\t\t\t\t\t\t       range_reference_t<_Vp>>>\n  class adjacent_transform_view : public view_interface<adjacent_transform_view<_Vp, _Fp, _Nm>>\n  {\n    [[no_unique_address]] __detail::__box<_Fp> _M_fun;\n    adjacent_view<_Vp, _Nm> _M_inner;\n\n    using _InnerView = adjacent_view<_Vp, _Nm>;\n\n    template<bool _Const>\n      using _InnerIter = iterator_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n\n    template<bool _Const>\n      using _InnerSent = sentinel_t<__detail::__maybe_const_t<_Const, _InnerView>>;\n\n    template<bool> class _Iterator;\n    template<bool> class _Sentinel;\n\n  public:\n    adjacent_transform_view() = default;\n\n    constexpr explicit\n    adjacent_transform_view(_Vp __base, _Fp __fun)\n      : _M_fun(std::move(__fun)), _M_inner(std::move(__base))\n    { }\n\n    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n    // 3848. adjacent_view, adjacent_transform_view and slide_view missing base accessor\n    // 3947. Unexpected constraints on adjacent_transform_view::base()\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_inner.base(); }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_inner.base()); }\n\n    constexpr auto\n    begin()\n    { return _Iterator<false>(*this, _M_inner.begin()); }\n\n    constexpr auto\n    begin() const\n      requires range<const _InnerView>\n\t&& regular_invocable<__detail::__unarize<const _Fp&, _Nm>,\n\t\t\t     range_reference_t<const _Vp>>\n    { return _Iterator<true>(*this, _M_inner.begin()); }\n\n    constexpr auto\n    end()\n    {\n      if constexpr (common_range<_InnerView>)\n        return _Iterator<false>(*this, _M_inner.end());\n      else\n        return _Sentinel<false>(_M_inner.end());\n    }\n\n    constexpr auto\n    end() const\n      requires range<const _InnerView>\n\t&& regular_invocable<__detail::__unarize<const _Fp&, _Nm>,\n\t\t\t     range_reference_t<const _Vp>>\n    {\n      if constexpr (common_range<const _InnerView>)\n        return _Iterator<true>(*this, _M_inner.end());\n      else\n        return _Sentinel<true>(_M_inner.end());\n    }\n\n    constexpr auto\n    size() requires sized_range<_InnerView>\n    { return _M_inner.size(); }\n\n    constexpr auto\n    size() const requires sized_range<const _InnerView>\n    { return _M_inner.size(); }\n  };\n\n  template<forward_range _Vp, move_constructible _Fp, size_t _Nm>\n   requires view<_Vp> && (_Nm > 0) && is_object_v<_Fp>\n     && regular_invocable<__detail::__unarize<_Fp&, _Nm>, range_reference_t<_Vp>>\n     && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Nm>,\n\t\t\t\t\t\t       range_reference_t<_Vp>>>\n  template<bool _Const>\n  class adjacent_transform_view<_Vp, _Fp, _Nm>::_Iterator\n  {\n    using _Parent = __detail::__maybe_const_t<_Const, adjacent_transform_view>;\n    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n    _Parent* _M_parent = nullptr;\n    _InnerIter<_Const> _M_inner;\n\n    constexpr\n    _Iterator(_Parent& __parent, _InnerIter<_Const> __inner)\n      : _M_parent(std::__addressof(__parent)), _M_inner(std::move(__inner))\n    { }\n\n    static auto\n    _S_iter_cat()\n    {\n      using __detail::__maybe_const_t;\n      using __detail::__unarize;\n      using _Res = invoke_result_t<__unarize<__maybe_const_t<_Const, _Fp>&, _Nm>,\n\t\t\t\t   range_reference_t<_Base>>;\n      using _Cat = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3798. Rvalue reference and iterator_category\n      if constexpr (!is_reference_v<_Res>)\n\treturn input_iterator_tag{};\n      else if constexpr (derived_from<_Cat, random_access_iterator_tag>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)\n\treturn bidirectional_iterator_tag{};\n      else if constexpr (derived_from<_Cat, forward_iterator_tag>)\n\treturn forward_iterator_tag{};\n      else\n\treturn input_iterator_tag{};\n    }\n\n    friend class adjacent_transform_view;\n\n  public:\n    using iterator_category = decltype(_S_iter_cat());\n    using iterator_concept = typename _InnerIter<_Const>::iterator_concept;\n    using value_type\n      = remove_cvref_t<invoke_result_t\n\t\t       <__detail::__unarize<__detail::__maybe_const_t<_Const, _Fp>&, _Nm>,\n\t\t\trange_reference_t<_Base>>>;\n    using difference_type = range_difference_t<_Base>;\n\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const && convertible_to<_InnerIter<false>, _InnerIter<_Const>>\n      : _M_parent(__i._M_parent), _M_inner(std::move(__i._M_inner))\n    { }\n\n    constexpr decltype(auto)\n    operator*() const\n    {\n      return std::apply([&](const auto&... __iters) -> decltype(auto) {\n        return std::__invoke(*_M_parent->_M_fun, *__iters...);\n      }, _M_inner._M_current);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      ++_M_inner;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator++(int)\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Base>\n    {\n      --_M_inner;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Base>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __x) requires random_access_range<_Base>\n    {\n      _M_inner += __x;\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __x) requires random_access_range<_Base>\n    {\n      _M_inner -= __x;\n      return *this;\n    }\n\n    constexpr decltype(auto)\n    operator[](difference_type __n) const requires random_access_range<_Base>\n    {\n      return std::apply([&](const auto&... __iters) -> decltype(auto) {\n        return std::__invoke(*_M_parent->_M_fun, __iters[__n]...);\n      }, _M_inner._M_current);\n    }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n    { return __x._M_inner == __y._M_inner; }\n\n    friend constexpr bool\n    operator<(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_inner < __y._M_inner; }\n\n    friend constexpr bool\n    operator>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_inner > __y._M_inner; }\n\n    friend constexpr bool\n    operator<=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_inner <= __y._M_inner; }\n\n    friend constexpr bool\n    operator>=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_inner >= __y._M_inner; }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base> &&\n      three_way_comparable<_InnerIter<_Const>>\n    { return __x._M_inner <=> __y._M_inner; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __i)\n      requires random_access_range<_Base>\n    { return _Iterator(*__i._M_parent, __i._M_inner + __n); }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    { return _Iterator(*__i._M_parent, __i._M_inner - __n); }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires sized_sentinel_for<_InnerIter<_Const>, _InnerIter<_Const>>\n    { return __x._M_inner - __y._M_inner; }\n  };\n\n  template<forward_range _Vp, move_constructible _Fp, size_t _Nm>\n   requires view<_Vp> && (_Nm > 0) && is_object_v<_Fp>\n     && regular_invocable<__detail::__unarize<_Fp&, _Nm>, range_reference_t<_Vp>>\n     && std::__detail::__can_reference<invoke_result_t<__detail::__unarize<_Fp&, _Nm>,\n\t\t\t\t\t\t       range_reference_t<_Vp>>>\n  template<bool _Const>\n  class adjacent_transform_view<_Vp, _Fp, _Nm>::_Sentinel\n  {\n    _InnerSent<_Const> _M_inner;\n\n    constexpr explicit\n    _Sentinel(_InnerSent<_Const> __inner)\n      : _M_inner(__inner)\n    { }\n\n    friend class adjacent_transform_view;\n\n  public:\n    _Sentinel() = default;\n\n    constexpr\n    _Sentinel(_Sentinel<!_Const> __i)\n      requires _Const && convertible_to<_InnerSent<false>, _InnerSent<_Const>>\n      : _M_inner(std::move(__i._M_inner))\n    { }\n\n    template<bool _OtherConst>\n      requires sentinel_for<_InnerSent<_Const>, _InnerIter<_OtherConst>>\n    friend constexpr bool\n    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_inner == __y._M_inner; }\n\n    template<bool _OtherConst>\n      requires sized_sentinel_for<_InnerSent<_Const>, _InnerIter<_OtherConst>>\n    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _InnerView>>\n    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_inner - __y._M_inner; }\n\n    template<bool _OtherConst>\n      requires sized_sentinel_for<_InnerSent<_Const>, _InnerIter<_OtherConst>>\n    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _InnerView>>\n    operator-(const _Sentinel& __x, const _Iterator<_OtherConst>& __y)\n    { return __x._M_inner - __y._M_inner; }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<size_t _Nm, typename _Range, typename _Fp>\n\tconcept __can_adjacent_transform_view\n\t  = requires { adjacent_transform_view<all_t<_Range>, decay_t<_Fp>, _Nm>\n\t\t         (std::declval<_Range>(), std::declval<_Fp>()); };\n    }\n\n    template<size_t _Nm>\n      struct _AdjacentTransform : __adaptor::_RangeAdaptor<_AdjacentTransform<_Nm>>\n      {\n\ttemplate<viewable_range _Range, typename _Fp>\n\t  requires (_Nm == 0) || __detail::__can_adjacent_transform_view<_Nm, _Range, _Fp>\n\t  constexpr auto\n\t  operator() [[nodiscard]] (_Range&& __r, _Fp&& __f) const\n\t  {\n\t    if constexpr (_Nm == 0)\n\t      return zip_transform(std::forward<_Fp>(__f));\n\t    else\n\t      return adjacent_transform_view<all_t<_Range>, decay_t<_Fp>, _Nm>\n\t\t(std::forward<_Range>(__r), std::forward<_Fp>(__f));\n\t  }\n\n\tusing __adaptor::_RangeAdaptor<_AdjacentTransform>::operator();\n\tstatic constexpr int _S_arity = 2;\n\tstatic constexpr bool _S_has_simple_extra_args = true;\n      };\n\n    template<size_t _Nm>\n      inline constexpr _AdjacentTransform<_Nm> adjacent_transform;\n\n    inline constexpr auto pairwise_transform = adjacent_transform<2>;\n  }\n#endif // __cpp_lib_ranges_zip\n\n#ifdef __cpp_lib_ranges_chunk // C++ >= 23\n  namespace __detail\n  {\n    template<typename _Tp>\n    constexpr _Tp __div_ceil(_Tp __num, _Tp __denom)\n    {\n      _Tp __r = __num / __denom;\n      if (__num % __denom)\n\t++__r;\n      return __r;\n    }\n  }\n\n  template<view _Vp>\n    requires input_range<_Vp>\n  class chunk_view : public view_interface<chunk_view<_Vp>>\n  {\n    _Vp _M_base;\n    range_difference_t<_Vp> _M_n;\n    range_difference_t<_Vp> _M_remainder = 0;\n    __detail::__non_propagating_cache<iterator_t<_Vp>> _M_current;\n\n    class _OuterIter;\n    class _InnerIter;\n\n  public:\n    constexpr explicit\n    chunk_view(_Vp __base, range_difference_t<_Vp> __n)\n      : _M_base(std::move(__base)), _M_n(__n)\n    { __glibcxx_assert(__n >= 0); }\n\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr _OuterIter\n    begin()\n    {\n      _M_current = ranges::begin(_M_base);\n      _M_remainder = _M_n;\n      return _OuterIter(*this);\n    }\n\n    constexpr default_sentinel_t\n    end() const noexcept\n    { return default_sentinel; }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    {\n      return __detail::__to_unsigned_like(__detail::__div_ceil\n\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n    }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    {\n      return __detail::__to_unsigned_like(__detail::__div_ceil\n\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n    }\n  };\n\n  template<typename _Range>\n    chunk_view(_Range&&, range_difference_t<_Range>) -> chunk_view<views::all_t<_Range>>;\n\n  template<view _Vp>\n    requires input_range<_Vp>\n  class chunk_view<_Vp>::_OuterIter\n  {\n    chunk_view* _M_parent;\n\n    constexpr explicit\n    _OuterIter(chunk_view& __parent) noexcept\n      : _M_parent(std::__addressof(__parent))\n    { }\n\n    friend chunk_view;\n\n  public:\n    using iterator_concept = input_iterator_tag;\n    using difference_type = range_difference_t<_Vp>;\n\n    struct value_type;\n\n    _OuterIter(_OuterIter&&) = default;\n    _OuterIter& operator=(_OuterIter&&) = default;\n\n    constexpr value_type\n    operator*() const\n    {\n      __glibcxx_assert(*this != default_sentinel);\n      return value_type(*_M_parent);\n    }\n\n    constexpr _OuterIter&\n    operator++()\n    {\n      __glibcxx_assert(*this != default_sentinel);\n      ranges::advance(*_M_parent->_M_current, _M_parent->_M_remainder,\n\t\t      ranges::end(_M_parent->_M_base));\n      _M_parent->_M_remainder = _M_parent->_M_n;\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    friend constexpr bool\n    operator==(const _OuterIter& __x, default_sentinel_t)\n    {\n      return *__x._M_parent->_M_current == ranges::end(__x._M_parent->_M_base)\n\t&& __x._M_parent->_M_remainder != 0;\n    }\n\n    friend constexpr difference_type\n    operator-(default_sentinel_t, const _OuterIter& __x)\n    requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    {\n      const auto __dist = ranges::end(__x._M_parent->_M_base) - *__x._M_parent->_M_current;\n\n      if (__dist < __x._M_parent->_M_remainder)\n\treturn __dist == 0 ? 0 : 1;\n\n      return 1 + __detail::__div_ceil(__dist - __x._M_parent->_M_remainder,\n\t\t\t\t      __x._M_parent->_M_n);\n    }\n\n    friend constexpr difference_type\n    operator-(const _OuterIter& __x, default_sentinel_t __y)\n    requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    { return -(__y - __x); }\n  };\n\n  template<view _Vp>\n    requires input_range<_Vp>\n  struct chunk_view<_Vp>::_OuterIter::value_type : view_interface<value_type>\n  {\n  private:\n    chunk_view* _M_parent;\n\n    constexpr explicit\n    value_type(chunk_view& __parent) noexcept\n    : _M_parent(std::__addressof(__parent))\n    { }\n\n    friend _OuterIter;\n\n  public:\n    constexpr _InnerIter\n    begin() const noexcept\n    { return _InnerIter(*_M_parent); }\n\n    constexpr default_sentinel_t\n    end() const noexcept\n    { return default_sentinel; }\n\n    constexpr auto\n    size() const\n    requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    {\n      return __detail::__to_unsigned_like\n\t(ranges::min(_M_parent->_M_remainder,\n\t\t     ranges::end(_M_parent->_M_base) - *_M_parent->_M_current));\n    }\n  };\n\n  template<view _Vp>\n    requires input_range<_Vp>\n  class chunk_view<_Vp>::_InnerIter\n  {\n    chunk_view* _M_parent;\n\n    constexpr explicit\n    _InnerIter(chunk_view& __parent) noexcept\n    : _M_parent(std::__addressof(__parent))\n    { }\n\n    friend _OuterIter::value_type;\n\n  public:\n    using iterator_concept = input_iterator_tag;\n    using difference_type = range_difference_t<_Vp>;\n    using value_type = range_value_t<_Vp>;\n\n    _InnerIter(_InnerIter&&) = default;\n    _InnerIter& operator=(_InnerIter&&) = default;\n\n    constexpr const iterator_t<_Vp>&\n    base() const &\n    { return *_M_parent->_M_current; }\n\n    constexpr range_reference_t<_Vp>\n    operator*() const\n    {\n      __glibcxx_assert(*this != default_sentinel);\n      return **_M_parent->_M_current;\n    }\n\n    constexpr _InnerIter&\n    operator++()\n    {\n      __glibcxx_assert(*this != default_sentinel);\n      ++*_M_parent->_M_current;\n      if (*_M_parent->_M_current == ranges::end(_M_parent->_M_base))\n\t_M_parent->_M_remainder = 0;\n      else\n\t--_M_parent->_M_remainder;\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    friend constexpr bool\n    operator==(const _InnerIter& __x, default_sentinel_t) noexcept\n    { return __x._M_parent->_M_remainder == 0; }\n\n    friend constexpr difference_type\n    operator-(default_sentinel_t, const _InnerIter& __x)\n      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    {\n      return ranges::min(__x._M_parent->_M_remainder,\n\t\t\t ranges::end(__x._M_parent->_M_base) - *__x._M_parent->_M_current);\n    }\n\n    friend constexpr difference_type\n    operator-(const _InnerIter& __x, default_sentinel_t __y)\n      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    { return -(__y - __x); }\n\n    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n    // 3851. chunk_view::inner-iterator missing custom iter_move and iter_swap\n    friend constexpr range_rvalue_reference_t<_Vp>\n    iter_move(const _InnerIter& __i)\n    noexcept(noexcept(ranges::iter_move(*__i._M_parent->_M_current)))\n    { return ranges::iter_move(*__i._M_parent->_M_current); }\n\n    friend constexpr void\n    iter_swap(const _InnerIter& __x, const _InnerIter& __y)\n    noexcept(noexcept(ranges::iter_swap(*__x._M_parent->_M_current,\n\t\t\t\t\t*__x._M_parent->_M_current)))\n    requires indirectly_swappable<iterator_t<_Vp>>\n    { return ranges::iter_swap(*__x._M_parent->_M_current, *__y._M_parent->_M_current); }\n  };\n\n  template<view _Vp>\n    requires forward_range<_Vp>\n  class chunk_view<_Vp> : public view_interface<chunk_view<_Vp>>\n  {\n    _Vp _M_base;\n    range_difference_t<_Vp> _M_n;\n    template<bool> class _Iterator;\n\n  public:\n    constexpr explicit\n    chunk_view(_Vp __base, range_difference_t<_Vp> __n)\n    : _M_base(std::move(__base)), _M_n(__n)\n    { __glibcxx_assert(__n > 0); }\n\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin() requires (!__detail::__simple_view<_Vp>)\n    { return _Iterator<false>(this, ranges::begin(_M_base)); }\n\n    constexpr auto\n    begin() const requires forward_range<const _Vp>\n    { return _Iterator<true>(this, ranges::begin(_M_base)); }\n\n    constexpr auto\n    end() requires (!__detail::__simple_view<_Vp>)\n    {\n      if constexpr (common_range<_Vp> && sized_range<_Vp>)\n\t{\n\t  auto __missing = (_M_n - ranges::distance(_M_base) % _M_n) % _M_n;\n\t  return _Iterator<false>(this, ranges::end(_M_base), __missing);\n\t}\n      else if constexpr (common_range<_Vp> && !bidirectional_range<_Vp>)\n\treturn _Iterator<false>(this, ranges::end(_M_base));\n      else\n\treturn default_sentinel;\n    }\n\n    constexpr auto\n    end() const requires forward_range<const _Vp>\n    {\n      if constexpr (common_range<const _Vp> && sized_range<const _Vp>)\n\t{\n\t  auto __missing = (_M_n - ranges::distance(_M_base) % _M_n) % _M_n;\n\t  return _Iterator<true>(this, ranges::end(_M_base), __missing);\n\t}\n      else if constexpr (common_range<const _Vp> && !bidirectional_range<const _Vp>)\n\treturn _Iterator<true>(this, ranges::end(_M_base));\n      else\n\treturn default_sentinel;\n    }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    {\n      return __detail::__to_unsigned_like(__detail::__div_ceil\n\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n    }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    {\n      return __detail::__to_unsigned_like(__detail::__div_ceil\n\t\t\t\t\t  (ranges::distance(_M_base), _M_n));\n    }\n  };\n\n  template<typename _Vp>\n    inline constexpr bool enable_borrowed_range<chunk_view<_Vp>>\n      = forward_range<_Vp> && enable_borrowed_range<_Vp>;\n\n  template<view _Vp>\n    requires forward_range<_Vp>\n  template<bool _Const>\n  class chunk_view<_Vp>::_Iterator\n  {\n    using _Parent = __detail::__maybe_const_t<_Const, chunk_view>;\n    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n    iterator_t<_Base> _M_current = iterator_t<_Base>();\n    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n    range_difference_t<_Base> _M_n = 0;\n    range_difference_t<_Base> _M_missing = 0;\n\n    constexpr\n    _Iterator(_Parent* __parent, iterator_t<_Base> __current,\n\t      range_difference_t<_Base> __missing = 0)\n    : _M_current(__current), _M_end(ranges::end(__parent->_M_base)),\n      _M_n(__parent->_M_n), _M_missing(__missing)\n    { }\n\n    static auto\n    _S_iter_cat()\n    {\n      if constexpr (random_access_range<_Base>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (bidirectional_range<_Base>)\n\treturn bidirectional_iterator_tag{};\n      else\n\treturn forward_iterator_tag{};\n    }\n\n    friend chunk_view;\n\n  public:\n    using iterator_category = input_iterator_tag;\n    using iterator_concept = decltype(_S_iter_cat());\n    using value_type = decltype(views::take(subrange(_M_current, _M_end), _M_n));\n    using difference_type = range_difference_t<_Base>;\n\n    _Iterator() = default;\n\n    constexpr _Iterator(_Iterator<!_Const> __i)\n      requires _Const\n\t&& convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n\t&& convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n    : _M_current(std::move(__i._M_current)), _M_end(std::move(__i._M_end)),\n      _M_n(__i._M_n), _M_missing(__i._M_missing)\n    { }\n\n    constexpr iterator_t<_Base>\n    base() const\n    { return _M_current; }\n\n    constexpr value_type\n    operator*() const\n    {\n      __glibcxx_assert(_M_current != _M_end);\n      return views::take(subrange(_M_current, _M_end), _M_n);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      __glibcxx_assert(_M_current != _M_end);\n      _M_missing = ranges::advance(_M_current, _M_n, _M_end);\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator++(int)\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Base>\n    {\n      ranges::advance(_M_current, _M_missing - _M_n);\n      _M_missing = 0;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Base>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __x)\n      requires random_access_range<_Base>\n    {\n      if (__x > 0)\n\t{\n\t  __glibcxx_assert(ranges::distance(_M_current, _M_end) > _M_n * (__x - 1));\n\t  _M_missing = ranges::advance(_M_current, _M_n * __x, _M_end);\n\t}\n      else if (__x < 0)\n\t{\n\t  ranges::advance(_M_current, _M_n * __x + _M_missing);\n\t  _M_missing = 0;\n\t}\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __x)\n      requires random_access_range<_Base>\n    { return *this += -__x; }\n\n    constexpr value_type\n    operator[](difference_type __n) const\n      requires random_access_range<_Base>\n    { return *(*this + __n); }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n    { return __x._M_current == __y._M_current; }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, default_sentinel_t)\n    { return __x._M_current == __x._M_end; }\n\n    friend constexpr bool\n    operator<(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_current > __y._M_current; }\n\n    friend constexpr bool\n    operator>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __y < __x; }\n\n    friend constexpr bool\n    operator<=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__y < __x); }\n\n    friend constexpr bool\n    operator>=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__x < __y); }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n\t&& three_way_comparable<iterator_t<_Base>>\n    { return __x._M_current <=> __y._M_current; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r  = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __i)\n      requires random_access_range<_Base>\n    {\n      auto __r  = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r  = __i;\n      __r -= __n;\n      return __r;\n    }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n    {\n      return (__x._M_current - __y._M_current\n\t      + __x._M_missing - __y._M_missing) / __x._M_n;\n    }\n\n    friend constexpr difference_type\n    operator-(default_sentinel_t, const _Iterator& __x)\n      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n    { return __detail::__div_ceil(__x._M_end - __x._M_current, __x._M_n); }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, default_sentinel_t __y)\n      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n    { return -(__y - __x); }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Dp>\n\tconcept __can_chunk_view\n\t  = requires { chunk_view(std::declval<_Range>(), std::declval<_Dp>()); };\n    }\n\n    struct _Chunk : __adaptor::_RangeAdaptor<_Chunk>\n    {\n      template<viewable_range _Range, typename _Dp = range_difference_t<_Range>>\n\trequires __detail::__can_chunk_view<_Range, _Dp>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, type_identity_t<_Dp> __n) const\n\t{ return chunk_view(std::forward<_Range>(__r), __n); }\n\n      using __adaptor::_RangeAdaptor<_Chunk>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _Chunk chunk;\n  }\n#endif // __cpp_lib_ranges_chunk\n\n#ifdef __cpp_lib_ranges_slide // C++ >= 23\n  namespace __detail\n  {\n    template<typename _Vp>\n      concept __slide_caches_nothing = random_access_range<_Vp> && sized_range<_Vp>;\n\n    template<typename _Vp>\n      concept __slide_caches_last\n      = !__slide_caches_nothing<_Vp> && bidirectional_range<_Vp> && common_range<_Vp>;\n\n    template<typename _Vp>\n      concept __slide_caches_first\n      = !__slide_caches_nothing<_Vp> && !__slide_caches_last<_Vp>;\n  }\n\n  template<forward_range _Vp>\n    requires view<_Vp>\n  class slide_view : public view_interface<slide_view<_Vp>>\n  {\n    _Vp _M_base;\n    range_difference_t<_Vp> _M_n;\n    [[no_unique_address]]\n      __detail::__maybe_present_t<__detail::__slide_caches_first<_Vp>,\n\t\t\t\t  __detail::_CachedPosition<_Vp>, 0> _M_cached_begin;\n    [[no_unique_address]]\n      __detail::__maybe_present_t<__detail::__slide_caches_last<_Vp>,\n\t\t\t\t  __detail::_CachedPosition<_Vp>, 1> _M_cached_end;\n\n    template<bool> class _Iterator;\n    class _Sentinel;\n\n  public:\n    constexpr explicit\n    slide_view(_Vp __base, range_difference_t<_Vp> __n)\n    : _M_base(std::move(__base)), _M_n(__n)\n    { __glibcxx_assert(__n > 0); }\n\n    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n    // 3848. adjacent_view, adjacent_transform_view and slide_view missing base accessor\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin() requires (!(__detail::__simple_view<_Vp>\n\t\t\t&& __detail::__slide_caches_nothing<const _Vp>))\n    {\n      if constexpr (__detail::__slide_caches_first<_Vp>)\n\t{\n\t  iterator_t<_Vp> __it;\n\t  if (_M_cached_begin._M_has_value())\n\t    __it = _M_cached_begin._M_get(_M_base);\n\t  else\n\t    {\n\t      __it = ranges::next(ranges::begin(_M_base), _M_n - 1, ranges::end(_M_base));\n\t      _M_cached_begin._M_set(_M_base, __it);\n\t    }\n\t  return _Iterator<false>(ranges::begin(_M_base), std::move(__it), _M_n);\n\t}\n      else\n\treturn _Iterator<false>(ranges::begin(_M_base), _M_n);\n    }\n\n    constexpr auto\n    begin() const requires __detail::__slide_caches_nothing<const _Vp>\n    { return _Iterator<true>(ranges::begin(_M_base), _M_n); }\n\n    constexpr auto\n    end() requires (!(__detail::__simple_view<_Vp>\n\t\t      && __detail::__slide_caches_nothing<const _Vp>))\n    {\n      if constexpr (__detail::__slide_caches_nothing<_Vp>)\n\treturn _Iterator<false>(ranges::begin(_M_base) + range_difference_t<_Vp>(size()),\n\t\t\t\t_M_n);\n      else if constexpr (__detail::__slide_caches_last<_Vp>)\n\t{\n\t  iterator_t<_Vp> __it;\n\t  if (_M_cached_end._M_has_value())\n\t    __it = _M_cached_end._M_get(_M_base);\n\t  else\n\t    {\n\t      __it = ranges::prev(ranges::end(_M_base), _M_n - 1, ranges::begin(_M_base));\n\t      _M_cached_end._M_set(_M_base, __it);\n\t    }\n\t  return _Iterator<false>(std::move(__it), _M_n);\n\t}\n      else if constexpr (common_range<_Vp>)\n\treturn _Iterator<false>(ranges::end(_M_base), ranges::end(_M_base), _M_n);\n      else\n\treturn _Sentinel(ranges::end(_M_base));\n    }\n\n    constexpr auto\n    end() const requires __detail::__slide_caches_nothing<const _Vp>\n    { return begin() + range_difference_t<const _Vp>(size()); }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    {\n      auto __sz = ranges::distance(_M_base) - _M_n + 1;\n      if (__sz < 0)\n\t__sz = 0;\n      return __detail::__to_unsigned_like(__sz);\n    }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    {\n      auto __sz = ranges::distance(_M_base) - _M_n + 1;\n      if (__sz < 0)\n\t__sz = 0;\n      return __detail::__to_unsigned_like(__sz);\n    }\n  };\n\n  template<typename _Range>\n    slide_view(_Range&&, range_difference_t<_Range>) -> slide_view<views::all_t<_Range>>;\n\n  template<typename _Vp>\n    inline constexpr bool enable_borrowed_range<slide_view<_Vp>>\n      = enable_borrowed_range<_Vp>;\n\n  template<forward_range _Vp>\n    requires view<_Vp>\n  template<bool _Const>\n  class slide_view<_Vp>::_Iterator\n  {\n    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n    static constexpr bool _S_last_elt_present\n      = __detail::__slide_caches_first<_Base>;\n\n    iterator_t<_Base> _M_current = iterator_t<_Base>();\n    [[no_unique_address]]\n      __detail::__maybe_present_t<_S_last_elt_present, iterator_t<_Base>>\n\t_M_last_elt = decltype(_M_last_elt)();\n    range_difference_t<_Base> _M_n = 0;\n\n    constexpr\n    _Iterator(iterator_t<_Base> __current, range_difference_t<_Base> __n)\n      requires (!_S_last_elt_present)\n    : _M_current(__current), _M_n(__n)\n    { }\n\n    constexpr\n    _Iterator(iterator_t<_Base> __current, iterator_t<_Base> __last_elt,\n\t      range_difference_t<_Base> __n)\n      requires _S_last_elt_present\n    : _M_current(__current), _M_last_elt(__last_elt), _M_n(__n)\n    { }\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (random_access_range<_Base>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (bidirectional_range<_Base>)\n\treturn bidirectional_iterator_tag{};\n      else\n\treturn forward_iterator_tag{};\n    }\n\n    friend slide_view;\n    friend slide_view::_Sentinel;\n\n  public:\n    using iterator_category = input_iterator_tag;\n    using iterator_concept = decltype(_S_iter_concept());\n    using value_type = decltype(views::counted(_M_current, _M_n));\n    using difference_type = range_difference_t<_Base>;\n\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n    : _M_current(std::move(__i._M_current)), _M_n(__i._M_n)\n    { }\n\n    constexpr auto\n    operator*() const\n    { return views::counted(_M_current, _M_n); }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      ++_M_current;\n      if constexpr (_S_last_elt_present)\n\t++_M_last_elt;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator++(int)\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Base>\n    {\n      --_M_current;\n      if constexpr (_S_last_elt_present)\n\t--_M_last_elt;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Base>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __x)\n      requires random_access_range<_Base>\n    {\n      _M_current += __x;\n      if constexpr (_S_last_elt_present)\n\t_M_last_elt += __x;\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __x)\n      requires random_access_range<_Base>\n    {\n      _M_current -= __x;\n      if constexpr (_S_last_elt_present)\n\t_M_last_elt -= __x;\n      return *this;\n    }\n\n    constexpr auto\n    operator[](difference_type __n) const\n      requires random_access_range<_Base>\n    { return views::counted(_M_current + __n, _M_n); }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n    {\n      if constexpr (_S_last_elt_present)\n\treturn __x._M_last_elt == __y._M_last_elt;\n      else\n\treturn __x._M_current == __y._M_current;\n    }\n\n    friend constexpr bool\n    operator<(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_current < __y._M_current; }\n\n    friend constexpr bool\n    operator>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __y < __x; }\n\n    friend constexpr bool\n    operator<=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__y < __x); }\n\n    friend constexpr bool\n    operator>=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__x < __y); }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n\t&& three_way_comparable<iterator_t<_Base>>\n     { return __x._M_current <=> __y._M_current; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __i)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r -= __n;\n      return __r;\n    }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n    {\n      if constexpr (_S_last_elt_present)\n\treturn __x._M_last_elt - __y._M_last_elt;\n      else\n\treturn __x._M_current - __y._M_current;\n    }\n  };\n\n  template<forward_range _Vp>\n    requires view<_Vp>\n  class slide_view<_Vp>::_Sentinel\n  {\n    sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();\n\n    constexpr explicit\n    _Sentinel(sentinel_t<_Vp> __end)\n    : _M_end(__end)\n    { }\n\n    friend slide_view;\n\n  public:\n    _Sentinel() = default;\n\n    friend constexpr bool\n    operator==(const _Iterator<false>& __x, const _Sentinel& __y)\n    { return __x._M_last_elt == __y._M_end; }\n\n    friend constexpr range_difference_t<_Vp>\n    operator-(const _Iterator<false>& __x, const _Sentinel& __y)\n      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    { return __x._M_last_elt - __y._M_end; }\n\n    friend constexpr range_difference_t<_Vp>\n    operator-(const _Sentinel& __y, const _Iterator<false>& __x)\n      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    { return __y._M_end -__x._M_last_elt; }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Dp>\n\tconcept __can_slide_view\n\t  = requires { slide_view(std::declval<_Range>(), std::declval<_Dp>()); };\n    }\n\n    struct _Slide : __adaptor::_RangeAdaptor<_Slide>\n    {\n      template<viewable_range _Range, typename _Dp = range_difference_t<_Range>>\n\trequires __detail::__can_slide_view<_Range, _Dp>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, type_identity_t<_Dp> __n) const\n\t{ return slide_view(std::forward<_Range>(__r), __n); }\n\n      using __adaptor::_RangeAdaptor<_Slide>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _Slide slide;\n  }\n#endif // __cpp_lib_ranges_slide\n\n#ifdef __cpp_lib_ranges_chunk_by // C++ >= 23\n  template<forward_range _Vp,\n\t   indirect_binary_predicate<iterator_t<_Vp>, iterator_t<_Vp>> _Pred>\n    requires view<_Vp> && is_object_v<_Pred>\n  class chunk_by_view : public view_interface<chunk_by_view<_Vp, _Pred>>\n  {\n    _Vp _M_base = _Vp();\n    __detail::__box<_Pred> _M_pred;\n    __detail::_CachedPosition<_Vp> _M_cached_begin;\n\n    constexpr iterator_t<_Vp>\n    _M_find_next(iterator_t<_Vp> __current)\n    {\n      __glibcxx_assert(_M_pred.has_value());\n      auto __pred = [this]<typename _Tp, typename _Up>(_Tp&& __x, _Up&& __y) {\n\treturn !bool((*_M_pred)(std::forward<_Tp>(__x), std::forward<_Up>(__y)));\n      };\n      auto __it = ranges::adjacent_find(__current, ranges::end(_M_base), __pred);\n      return ranges::next(__it, 1, ranges::end(_M_base));\n    }\n\n    constexpr iterator_t<_Vp>\n    _M_find_prev(iterator_t<_Vp> __current) requires bidirectional_range<_Vp>\n    {\n      __glibcxx_assert(_M_pred.has_value());\n      auto __pred = [this]<typename _Tp, typename _Up>(_Tp&& __x, _Up&& __y) {\n\treturn !bool((*_M_pred)(std::forward<_Up>(__y), std::forward<_Tp>(__x)));\n      };\n      auto __rbegin = std::make_reverse_iterator(__current);\n      auto __rend = std::make_reverse_iterator(ranges::begin(_M_base));\n      __glibcxx_assert(__rbegin != __rend);\n      auto __it = ranges::adjacent_find(__rbegin, __rend, __pred).base();\n      return ranges::prev(__it, 1, ranges::begin(_M_base));\n    }\n\n    class _Iterator;\n\n  public:\n    chunk_by_view() requires (default_initializable<_Vp>\n\t\t\t      && default_initializable<_Pred>)\n      = default;\n\n    constexpr explicit\n    chunk_by_view(_Vp __base, _Pred __pred)\n    : _M_base(std::move(__base)), _M_pred(std::move(__pred))\n    { }\n\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr const _Pred&\n    pred() const\n    { return *_M_pred; }\n\n    constexpr _Iterator\n    begin()\n    {\n      __glibcxx_assert(_M_pred.has_value());\n      iterator_t<_Vp> __it;\n      if (_M_cached_begin._M_has_value())\n\t__it = _M_cached_begin._M_get(_M_base);\n      else\n\t{\n\t  __it = _M_find_next(ranges::begin(_M_base));\n\t  _M_cached_begin._M_set(_M_base, __it);\n\t}\n      return _Iterator(*this, ranges::begin(_M_base), __it);\n    }\n\n    constexpr auto\n    end()\n    {\n      if constexpr (common_range<_Vp>)\n\treturn _Iterator(*this, ranges::end(_M_base), ranges::end(_M_base));\n      else\n\treturn default_sentinel;\n    }\n  };\n\n  template<typename _Range, typename _Pred>\n    chunk_by_view(_Range&&, _Pred) -> chunk_by_view<views::all_t<_Range>, _Pred>;\n\n  template<forward_range _Vp,\n\t   indirect_binary_predicate<iterator_t<_Vp>, iterator_t<_Vp>> _Pred>\n    requires view<_Vp> && is_object_v<_Pred>\n  class chunk_by_view<_Vp, _Pred>::_Iterator\n  {\n    chunk_by_view* _M_parent = nullptr;\n    iterator_t<_Vp> _M_current = iterator_t<_Vp>();\n    iterator_t<_Vp> _M_next = iterator_t<_Vp>();\n\n    constexpr\n    _Iterator(chunk_by_view& __parent, iterator_t<_Vp> __current, iterator_t<_Vp> __next)\n    : _M_parent(std::__addressof(__parent)), _M_current(__current), _M_next(__next)\n    { }\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (bidirectional_range<_Vp>)\n\treturn bidirectional_iterator_tag{};\n      else\n\treturn forward_iterator_tag{};\n    }\n\n    friend chunk_by_view;\n\n  public:\n    using value_type = subrange<iterator_t<_Vp>>;\n    using difference_type = range_difference_t<_Vp>;\n    using iterator_category = input_iterator_tag;\n    using iterator_concept = decltype(_S_iter_concept());\n\n    _Iterator() = default;\n\n    constexpr value_type\n    operator*() const\n    {\n      __glibcxx_assert(_M_current != _M_next);\n      return ranges::subrange(_M_current, _M_next);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      __glibcxx_assert(_M_current != _M_next);\n      _M_current = _M_next;\n      _M_next = _M_parent->_M_find_next(_M_current);\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator++(int)\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Vp>\n    {\n      _M_next = _M_current;\n      _M_current = _M_parent->_M_find_prev(_M_next);\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Vp>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n    { return __x._M_current == __y._M_current; }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, default_sentinel_t)\n    { return __x._M_current == __x._M_next; }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Pred>\n\tconcept __can_chunk_by_view\n\t  = requires { chunk_by_view(std::declval<_Range>(), std::declval<_Pred>()); };\n    }\n\n    struct _ChunkBy : __adaptor::_RangeAdaptor<_ChunkBy>\n    {\n      template<viewable_range _Range, typename _Pred>\n\trequires __detail::__can_chunk_by_view<_Range, _Pred>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Pred&& __pred) const\n\t{ return chunk_by_view(std::forward<_Range>(__r), std::forward<_Pred>(__pred)); }\n\n      using __adaptor::_RangeAdaptor<_ChunkBy>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _ChunkBy chunk_by;\n  }\n#endif // __cpp_lib_ranges_chunk_by\n\n#ifdef __cpp_lib_ranges_join_with // C++ >= 23\n  namespace __detail\n  {\n    template<typename _Range, typename _Pattern>\n      concept __compatible_joinable_ranges\n\t= common_with<range_value_t<_Range>, range_value_t<_Pattern>>\n\t  && common_reference_with<range_reference_t<_Range>,\n\t\t\t\t   range_reference_t<_Pattern>>\n\t  && common_reference_with<range_rvalue_reference_t<_Range>,\n\t\t\t\t   range_rvalue_reference_t<_Pattern>>;\n\n    template<typename _Range>\n      concept __bidirectional_common = bidirectional_range<_Range> && common_range<_Range>;\n  }\n\n  template<input_range _Vp, forward_range _Pattern>\n    requires view<_Vp> && view<_Pattern>\n      && input_range<range_reference_t<_Vp>>\n      && __detail::__compatible_joinable_ranges<range_reference_t<_Vp>, _Pattern>\n  class join_with_view : public view_interface<join_with_view<_Vp, _Pattern>>\n  {\n    using _InnerRange = range_reference_t<_Vp>;\n\n    _Vp _M_base = _Vp();\n    [[no_unique_address]]\n      __detail::__maybe_present_t<!forward_range<_Vp>,\n\t__detail::__non_propagating_cache<iterator_t<_Vp>>> _M_outer_it;\n    __detail::__non_propagating_cache<remove_cv_t<_InnerRange>> _M_inner;\n    _Pattern _M_pattern = _Pattern();\n\n    template<bool _Const> using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n    template<bool _Const> using _InnerBase = range_reference_t<_Base<_Const>>;\n    template<bool _Const> using _PatternBase = __detail::__maybe_const_t<_Const, _Pattern>;\n\n    template<bool _Const> using _OuterIter = iterator_t<_Base<_Const>>;\n    template<bool _Const> using _InnerIter = iterator_t<_InnerBase<_Const>>;\n    template<bool _Const> using _PatternIter = iterator_t<_PatternBase<_Const>>;\n\n    template<bool _Const>\n      static constexpr bool _S_ref_is_glvalue = is_reference_v<_InnerBase<_Const>>;\n\n    template<bool _Const>\n    struct __iter_cat\n    { };\n\n    template<bool _Const>\n      requires _S_ref_is_glvalue<_Const>\n\t&& forward_range<_Base<_Const>>\n\t&& forward_range<_InnerBase<_Const>>\n    struct __iter_cat<_Const>\n    {\n      private:\n\tstatic auto\n\t_S_iter_cat()\n\t{\n\t  using _OuterIter = join_with_view::_OuterIter<_Const>;\n\t  using _InnerIter = join_with_view::_InnerIter<_Const>;\n\t  using _PatternIter = join_with_view::_PatternIter<_Const>;\n\t  using _OuterCat = typename iterator_traits<_OuterIter>::iterator_category;\n\t  using _InnerCat = typename iterator_traits<_InnerIter>::iterator_category;\n\t  using _PatternCat = typename iterator_traits<_PatternIter>::iterator_category;\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3798. Rvalue reference and iterator_category\n\t  if constexpr (!is_reference_v<common_reference_t<iter_reference_t<_InnerIter>,\n\t\t\t\t\t\t\t   iter_reference_t<_PatternIter>>>)\n\t    return input_iterator_tag{};\n\t  else if constexpr (derived_from<_OuterCat, bidirectional_iterator_tag>\n\t\t\t     && derived_from<_InnerCat, bidirectional_iterator_tag>\n\t\t\t     && derived_from<_PatternCat, bidirectional_iterator_tag>\n\t\t\t     && common_range<_InnerBase<_Const>>\n\t\t\t     && common_range<_PatternBase<_Const>>)\n\t    return bidirectional_iterator_tag{};\n\t  else if constexpr (derived_from<_OuterCat, forward_iterator_tag>\n\t\t\t     && derived_from<_InnerCat, forward_iterator_tag>\n\t\t\t     && derived_from<_PatternCat, forward_iterator_tag>)\n\t    return forward_iterator_tag{};\n\t  else\n\t    return input_iterator_tag{};\n\t}\n      public:\n\tusing iterator_category = decltype(_S_iter_cat());\n    };\n\n    template<bool> class _Iterator;\n    template<bool> class _Sentinel;\n\n  public:\n    join_with_view() requires (default_initializable<_Vp>\n\t\t\t       && default_initializable<_Pattern>)\n      = default;\n\n    constexpr\n    join_with_view(_Vp __base, _Pattern __pattern)\n    : _M_base(std::move(__base)), _M_pattern(std::move(__pattern))\n    { }\n\n    template<input_range _Range>\n      requires constructible_from<_Vp, views::all_t<_Range>>\n\t&& constructible_from<_Pattern, single_view<range_value_t<_InnerRange>>>\n    constexpr\n    join_with_view(_Range&& __r, range_value_t<_InnerRange> __e)\n    : _M_base(views::all(std::forward<_Range>(__r))),\n      _M_pattern(views::single(std::move(__e)))\n    { }\n\n    constexpr _Vp\n    base() const& requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin()\n    {\n      if constexpr (forward_range<_Vp>)\n\t{\n\t  constexpr bool __use_const = is_reference_v<_InnerRange>\n\t    && __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;\n\t  return _Iterator<__use_const>{*this, ranges::begin(_M_base)};\n\t}\n      else\n\t{\n\t  _M_outer_it = ranges::begin(_M_base);\n\t  return _Iterator<false>{*this};\n\t}\n    }\n\n    constexpr auto\n    begin() const\n      requires forward_range<const _Vp>\n\t&& forward_range<const _Pattern>\n\t&& is_reference_v<range_reference_t<const _Vp>>\n\t&& input_range<range_reference_t<const _Vp>>\n    { return _Iterator<true>{*this, ranges::begin(_M_base)}; }\n\n    constexpr auto\n    end()\n    {\n      constexpr bool __use_const\n\t= __detail::__simple_view<_Vp> && __detail::__simple_view<_Pattern>;\n      if constexpr (is_reference_v<_InnerRange>\n\t\t    && forward_range<_Vp> && common_range<_Vp>\n\t\t    && forward_range<_InnerRange> && common_range<_InnerRange>)\n        return _Iterator<__use_const>{*this, ranges::end(_M_base)};\n      else\n        return _Sentinel<__use_const>{*this};\n    }\n\n    constexpr auto\n    end() const\n      requires forward_range<const _Vp>\n\t&& forward_range<const _Pattern>\n\t&& is_reference_v<range_reference_t<const _Vp>>\n\t&& input_range<range_reference_t<const _Vp>>\n    {\n      using _InnerConstRange = range_reference_t<const _Vp>;\n      if constexpr (forward_range<_InnerConstRange>\n\t\t    && common_range<const _Vp>\n\t\t    && common_range<_InnerConstRange>)\n        return _Iterator<true>{*this, ranges::end(_M_base)};\n      else\n        return _Sentinel<true>{*this};\n    }\n  };\n\n  template<typename _Range, typename _Pattern>\n    join_with_view(_Range&&, _Pattern&&)\n      -> join_with_view<views::all_t<_Range>, views::all_t<_Pattern>>;\n\n  template<input_range _Range>\n    join_with_view(_Range&&, range_value_t<range_reference_t<_Range>>)\n      -> join_with_view<views::all_t<_Range>,\n\t\t\tsingle_view<range_value_t<range_reference_t<_Range>>>>;\n\n  template<input_range _Vp, forward_range _Pattern>\n    requires view<_Vp> && view<_Pattern>\n      && input_range<range_reference_t<_Vp>>\n      && __detail::__compatible_joinable_ranges<range_reference_t<_Vp>, _Pattern>\n  template<bool _Const>\n  class join_with_view<_Vp, _Pattern>::_Iterator : public __iter_cat<_Const>\n  {\n    using _Parent = __detail::__maybe_const_t<_Const, join_with_view>;\n    using _Base = join_with_view::_Base<_Const>;\n    using _InnerBase = join_with_view::_InnerBase<_Const>;\n    using _PatternBase = join_with_view::_PatternBase<_Const>;\n\n    using _OuterIter = join_with_view::_OuterIter<_Const>;\n    using _InnerIter = join_with_view::_InnerIter<_Const>;\n    using _PatternIter = join_with_view::_PatternIter<_Const>;\n\n    static constexpr bool _S_ref_is_glvalue = join_with_view::_S_ref_is_glvalue<_Const>;\n\n    _Parent* _M_parent = nullptr;\n    [[no_unique_address]]\n      __detail::__maybe_present_t<forward_range<_Base>, _OuterIter> _M_outer_it\n\t= decltype(_M_outer_it)();\n    variant<_PatternIter, _InnerIter> _M_inner_it;\n\n    constexpr _OuterIter&\n    _M_get_outer()\n    {\n      if constexpr (forward_range<_Base>)\n\treturn _M_outer_it;\n      else\n\treturn *_M_parent->_M_outer_it;\n    }\n\n    constexpr const _OuterIter&\n    _M_get_outer() const\n    {\n      if constexpr (forward_range<_Base>)\n\treturn _M_outer_it;\n      else\n\treturn *_M_parent->_M_outer_it;\n    }\n\n    constexpr\n    _Iterator(_Parent& __parent, _OuterIter __outer)\n      requires forward_range<_Base>\n    : _M_parent(std::__addressof(__parent)), _M_outer_it(std::move(__outer))\n    {\n      if (_M_get_outer() != ranges::end(_M_parent->_M_base))\n\t{\n\t  auto&& __inner = _M_update_inner();\n\t  _M_inner_it.template emplace<1>(ranges::begin(__inner));\n\t  _M_satisfy();\n\t}\n    }\n\n    constexpr\n    _Iterator(_Parent& __parent)\n      requires (!forward_range<_Base>)\n    : _M_parent(std::__addressof(__parent))\n    {\n      if (_M_get_outer() != ranges::end(_M_parent->_M_base))\n\t{\n\t  auto&& __inner = _M_update_inner();\n\t  _M_inner_it.template emplace<1>(ranges::begin(__inner));\n\t  _M_satisfy();\n\t}\n    }\n\n    constexpr auto&\n    _M_update_inner()\n    {\n      _OuterIter& __outer = _M_get_outer();\n      if constexpr (_S_ref_is_glvalue)\n\treturn __detail::__as_lvalue(*__outer);\n      else\n\treturn _M_parent->_M_inner._M_emplace_deref(__outer);\n    }\n\n    constexpr auto&\n    _M_get_inner()\n    {\n      if constexpr (_S_ref_is_glvalue)\n\treturn __detail::__as_lvalue(*_M_get_outer());\n      else\n\treturn *_M_parent->_M_inner;\n    }\n\n    constexpr void\n    _M_satisfy()\n    {\n      while (true)\n\t{\n\t  if (_M_inner_it.index() == 0)\n\t    {\n\t      if (std::get<0>(_M_inner_it) != ranges::end(_M_parent->_M_pattern))\n\t\tbreak;\n\n\t      auto&& __inner = _M_update_inner();\n\t      _M_inner_it.template emplace<1>(ranges::begin(__inner));\n\t    }\n\t  else\n\t    {\n\t      auto&& __inner = _M_get_inner();\n\t      if (std::get<1>(_M_inner_it) != ranges::end(__inner))\n\t\tbreak;\n\n\t      if (++_M_get_outer() == ranges::end(_M_parent->_M_base))\n\t\t{\n\t\t  if constexpr (_S_ref_is_glvalue)\n\t\t    _M_inner_it.template emplace<0>();\n\t\t  break;\n\t\t}\n\n\t      _M_inner_it.template emplace<0>(ranges::begin(_M_parent->_M_pattern));\n\t    }\n\t}\n    }\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (_S_ref_is_glvalue\n\t\t    && bidirectional_range<_Base>\n\t\t    && __detail::__bidirectional_common<_InnerBase>\n\t\t    && __detail::__bidirectional_common<_PatternBase>)\n\treturn bidirectional_iterator_tag{};\n      else if constexpr (_S_ref_is_glvalue\n\t\t\t && forward_range<_Base>\n\t\t\t && forward_range<_InnerBase>)\n\treturn forward_iterator_tag{};\n      else\n\treturn input_iterator_tag{};\n    }\n\n    friend join_with_view;\n\n  public:\n    using iterator_concept = decltype(_S_iter_concept());\n    // iterator_category defined in join_with_view::__iter_cat\n    using value_type = common_type_t<iter_value_t<_InnerIter>,\n\t\t\t\t     iter_value_t<_PatternIter>>;\n    using difference_type = common_type_t<iter_difference_t<_OuterIter>,\n\t\t\t\t\t  iter_difference_t<_InnerIter>,\n\t\t\t\t\t  iter_difference_t<_PatternIter>>;\n\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const\n\t&& convertible_to<iterator_t<_Vp>, _OuterIter>\n\t&& convertible_to<iterator_t<_InnerRange>, _InnerIter>\n\t&& convertible_to<iterator_t<_Pattern>, _PatternIter>\n    : _M_parent(__i._M_parent),\n      _M_outer_it(std::move(__i._M_outer_it))\n    {\n      if (__i._M_inner_it.index() == 0)\n\t_M_inner_it.template emplace<0>(std::get<0>(std::move(__i._M_inner_it)));\n      else\n\t_M_inner_it.template emplace<1>(std::get<1>(std::move(__i._M_inner_it)));\n    }\n\n    constexpr common_reference_t<iter_reference_t<_InnerIter>,\n\t\t\t         iter_reference_t<_PatternIter>>\n    operator*() const\n    {\n      if (_M_inner_it.index() == 0)\n\treturn *std::get<0>(_M_inner_it);\n      else\n\treturn *std::get<1>(_M_inner_it);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      if (_M_inner_it.index() == 0)\n\t++std::get<0>(_M_inner_it);\n      else\n\t++std::get<1>(_M_inner_it);\n      _M_satisfy();\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    constexpr _Iterator\n    operator++(int)\n      requires _S_ref_is_glvalue\n\t&& forward_iterator<_OuterIter> && forward_iterator<_InnerIter>\n    {\n      _Iterator __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--()\n      requires _S_ref_is_glvalue\n\t&& bidirectional_range<_Base>\n\t&& __detail::__bidirectional_common<_InnerBase>\n\t&& __detail::__bidirectional_common<_PatternBase>\n    {\n      if (_M_outer_it == ranges::end(_M_parent->_M_base))\n\t{\n\t  auto&& __inner = *--_M_outer_it;\n\t  _M_inner_it.template emplace<1>(ranges::end(__inner));\n\t}\n\n      while (true)\n\t{\n\t  if (_M_inner_it.index() == 0)\n\t    {\n\t      auto& __it = std::get<0>(_M_inner_it);\n\t      if (__it == ranges::begin(_M_parent->_M_pattern))\n\t\t{\n\t\t  auto&& __inner = *--_M_outer_it;\n\t\t  _M_inner_it.template emplace<1>(ranges::end(__inner));\n\t\t}\n\t      else\n\t\tbreak;\n\t    }\n\t  else\n\t    {\n\t      auto& __it = std::get<1>(_M_inner_it);\n\t      auto&& __inner = *_M_outer_it;\n\t      if (__it == ranges::begin(__inner))\n\t\t_M_inner_it.template emplace<0>(ranges::end(_M_parent->_M_pattern));\n\t      else\n\t\tbreak;\n\t    }\n\t}\n\n      if (_M_inner_it.index() == 0)\n\t--std::get<0>(_M_inner_it);\n      else\n\t--std::get<1>(_M_inner_it);\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int)\n      requires _S_ref_is_glvalue && bidirectional_range<_Base>\n\t&& __detail::__bidirectional_common<_InnerBase>\n\t&& __detail::__bidirectional_common<_PatternBase>\n    {\n      _Iterator __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n      requires _S_ref_is_glvalue\n\t&& forward_range<_Base> && equality_comparable<_InnerIter>\n    { return __x._M_outer_it == __y._M_outer_it && __x._M_inner_it ==__y._M_inner_it; }\n\n    friend constexpr common_reference_t<iter_rvalue_reference_t<_InnerIter>,\n\t\t\t\t\titer_rvalue_reference_t<_PatternIter>>\n    iter_move(const _Iterator& __x)\n    {\n      if (__x._M_inner_it.index() == 0)\n\treturn ranges::iter_move(std::get<0>(__x._M_inner_it));\n      else\n\treturn ranges::iter_move(std::get<1>(__x._M_inner_it));\n    }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __x, const _Iterator& __y)\n      requires indirectly_swappable<_InnerIter, _PatternIter>\n    {\n      if (__x._M_inner_it.index() == 0)\n\t{\n\t  if (__y._M_inner_it.index() == 0)\n\t    ranges::iter_swap(std::get<0>(__x._M_inner_it), std::get<0>(__y._M_inner_it));\n\t  else\n\t    ranges::iter_swap(std::get<0>(__x._M_inner_it), std::get<1>(__y._M_inner_it));\n\t}\n      else\n\t{\n\t  if (__y._M_inner_it.index() == 0)\n\t    ranges::iter_swap(std::get<1>(__x._M_inner_it), std::get<0>(__y._M_inner_it));\n\t  else\n\t    ranges::iter_swap(std::get<1>(__x._M_inner_it), std::get<1>(__y._M_inner_it));\n\t}\n    }\n  };\n\n  template<input_range _Vp, forward_range _Pattern>\n    requires view<_Vp> && view<_Pattern>\n      && input_range<range_reference_t<_Vp>>\n      && __detail::__compatible_joinable_ranges<range_reference_t<_Vp>, _Pattern>\n  template<bool _Const>\n  class join_with_view<_Vp, _Pattern>::_Sentinel\n  {\n    using _Parent = __detail::__maybe_const_t<_Const, join_with_view>;\n    using _Base = join_with_view::_Base<_Const>;\n\n    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\n    constexpr explicit\n    _Sentinel(_Parent& __parent)\n    : _M_end(ranges::end(__parent._M_base))\n    { }\n\n    friend join_with_view;\n\n  public:\n    _Sentinel() = default;\n\n    constexpr\n    _Sentinel(_Sentinel<!_Const> __s)\n      requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n    : _M_end(std::move(__s._M_end))\n    { }\n\n    template<bool _OtherConst>\n      requires sentinel_for<sentinel_t<_Base>,\n\t\t\t    iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n    friend constexpr bool\n    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_get_outer() == __y._M_end; }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Pattern>\n\tconcept __can_join_with_view\n\t  = requires { join_with_view(std::declval<_Range>(), std::declval<_Pattern>()); };\n    } // namespace __detail\n\n    struct _JoinWith : __adaptor::_RangeAdaptor<_JoinWith>\n    {\n      template<viewable_range _Range, typename _Pattern>\n\trequires __detail::__can_join_with_view<_Range, _Pattern>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, _Pattern&& __f) const\n\t{\n\t  return join_with_view(std::forward<_Range>(__r), std::forward<_Pattern>(__f));\n\t}\n\n      using _RangeAdaptor<_JoinWith>::operator();\n      static constexpr int _S_arity = 2;\n      template<typename _Pattern>\n\tstatic constexpr bool _S_has_simple_extra_args\n\t  = _LazySplit::_S_has_simple_extra_args<_Pattern>;\n    };\n\n    inline constexpr _JoinWith join_with;\n  } // namespace views\n#endif // __cpp_lib_ranges_join_with\n\n#ifdef __cpp_lib_ranges_repeat // C++ >= 23\n  template<move_constructible _Tp, semiregular _Bound = unreachable_sentinel_t>\n    requires is_object_v<_Tp> && same_as<_Tp, remove_cv_t<_Tp>>\n      && (__detail::__is_integer_like<_Bound> || same_as<_Bound, unreachable_sentinel_t>)\n  class repeat_view : public view_interface<repeat_view<_Tp, _Bound>>\n  {\n    __detail::__box<_Tp> _M_value;\n    [[no_unique_address]] _Bound _M_bound = _Bound();\n\n    class _Iterator;\n\n    template<typename _Range>\n    friend constexpr auto\n    views::__detail::__take_of_repeat_view(_Range&&, range_difference_t<_Range>);\n\n    template<typename _Range>\n    friend constexpr auto\n    views::__detail::__drop_of_repeat_view(_Range&&, range_difference_t<_Range>);\n\n  public:\n    repeat_view() requires default_initializable<_Tp> = default;\n\n    constexpr explicit\n    repeat_view(const _Tp& __value, _Bound __bound = _Bound())\n    requires copy_constructible<_Tp>\n    : _M_value(__value), _M_bound(__bound)\n    {\n      if constexpr (!same_as<_Bound, unreachable_sentinel_t>)\n\t__glibcxx_assert(__bound >= 0);\n    }\n\n    constexpr explicit\n    repeat_view(_Tp&& __value, _Bound __bound = _Bound())\n    : _M_value(std::move(__value)), _M_bound(__bound)\n    { }\n\n    template<typename... _Args, typename... _BoundArgs>\n      requires constructible_from<_Tp, _Args...>\n        && constructible_from<_Bound, _BoundArgs...>\n    constexpr explicit\n    repeat_view(piecewise_construct_t,\n\t\ttuple<_Args...> __args,\n\t\ttuple<_BoundArgs...> __bound_args = tuple<>{})\n    : _M_value(std::make_from_tuple<_Tp>(std::move(__args))),\n      _M_bound(std::make_from_tuple<_Bound>(std::move(__bound_args)))\n    { }\n\n    constexpr _Iterator\n    begin() const\n    { return _Iterator(std::__addressof(*_M_value)); }\n\n    constexpr _Iterator\n    end() const requires (!same_as<_Bound, unreachable_sentinel_t>)\n    { return _Iterator(std::__addressof(*_M_value), _M_bound); }\n\n    constexpr unreachable_sentinel_t\n    end() const noexcept\n    { return unreachable_sentinel; }\n\n    constexpr auto\n    size() const requires (!same_as<_Bound, unreachable_sentinel_t>)\n    { return __detail::__to_unsigned_like(_M_bound); }\n  };\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 4053. Unary call to std::views::repeat does not decay the argument\n  template<typename _Tp, typename _Bound = unreachable_sentinel_t>\n    repeat_view(_Tp, _Bound = _Bound()) -> repeat_view<_Tp, _Bound>;\n\n  template<move_constructible _Tp, semiregular _Bound>\n    requires is_object_v<_Tp> && same_as<_Tp, remove_cv_t<_Tp>>\n      && (__detail::__is_integer_like<_Bound> || same_as<_Bound, unreachable_sentinel_t>)\n  class repeat_view<_Tp, _Bound>::_Iterator\n  {\n    using __index_type\n      = __conditional_t<same_as<_Bound, unreachable_sentinel_t>, ptrdiff_t, _Bound>;\n\n    const _Tp* _M_value = nullptr;\n    __index_type _M_current = __index_type();\n\n    constexpr explicit\n    _Iterator(const _Tp* __value, __index_type __bound = __index_type())\n    : _M_value(__value), _M_current(__bound)\n    {\n      if constexpr (!same_as<_Bound, unreachable_sentinel_t>)\n\t__glibcxx_assert(__bound >= 0);\n    }\n\n    friend repeat_view;\n\n  public:\n    using iterator_concept = random_access_iterator_tag;\n    using iterator_category = random_access_iterator_tag;\n    using value_type = _Tp;\n    using difference_type = __conditional_t<__detail::__is_signed_integer_like<__index_type>,\n\t\t\t\t\t    __index_type,\n\t\t\t\t\t    __detail::__iota_diff_t<__index_type>>;\n\n    _Iterator() = default;\n\n    constexpr const _Tp&\n    operator*() const noexcept\n    { return *_M_value; }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      ++_M_current;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator++(int)\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--()\n    {\n      if constexpr (!same_as<_Bound, unreachable_sentinel_t>)\n\t__glibcxx_assert(_M_current > 0);\n      --_M_current;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int)\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __n)\n    {\n      if constexpr (!same_as<_Bound, unreachable_sentinel_t>)\n\t__glibcxx_assert(_M_current + __n >= 0);\n      _M_current += __n;\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __n)\n    {\n      if constexpr (!same_as<_Bound, unreachable_sentinel_t>)\n\t__glibcxx_assert(_M_current - __n >= 0);\n      _M_current -= __n;\n      return *this;\n    }\n\n    constexpr const _Tp&\n    operator[](difference_type __n) const noexcept\n    { return *(*this + __n); }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n    { return __x._M_current == __y._M_current; }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n    { return __x._M_current <=> __y._M_current; }\n\n    friend constexpr _Iterator\n    operator+(_Iterator __i, difference_type __n)\n    {\n      __i += __n;\n      return __i;\n    }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, _Iterator __i)\n    { return __i + __n; }\n\n    friend constexpr _Iterator\n    operator-(_Iterator __i, difference_type __n)\n    {\n      __i -= __n;\n      return __i;\n    }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n    {\n      return (static_cast<difference_type>(__x._M_current)\n\t      - static_cast<difference_type>(__y._M_current));\n    }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Tp, typename _Bound>\n\tinline constexpr bool __is_repeat_view<repeat_view<_Tp, _Bound>> = true;\n\n      template<typename _Tp>\n\tconcept __can_repeat_view\n\t  = requires { repeat_view(std::declval<_Tp>()); };\n\n      template<typename _Tp, typename _Bound>\n\tconcept __can_bounded_repeat_view\n\t  = requires { repeat_view(std::declval<_Tp>(), std::declval<_Bound>()); };\n    }\n\n    struct _Repeat\n    {\n      template<typename _Tp>\n\trequires __detail::__can_repeat_view<_Tp>\n      constexpr auto\n      operator() [[nodiscard]] (_Tp&& __value) const\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 4054. Repeating a repeat_view should repeat the view\n\treturn repeat_view<decay_t<_Tp>>(std::forward<_Tp>(__value));\n      }\n\n      template<typename _Tp, typename _Bound>\n\trequires __detail::__can_bounded_repeat_view<_Tp, _Bound>\n      constexpr auto\n      operator() [[nodiscard]] (_Tp&& __value, _Bound __bound) const\n      { return repeat_view(std::forward<_Tp>(__value), __bound); }\n    };\n\n    inline constexpr _Repeat repeat;\n\n    namespace __detail\n    {\n      template<typename _Range>\n\tconstexpr auto\n\t__take_of_repeat_view(_Range&& __r, range_difference_t<_Range> __n)\n\t{\n\t  using _Tp = remove_cvref_t<_Range>;\n\t  static_assert(__is_repeat_view<_Tp>);\n\t  if constexpr (sized_range<_Tp>)\n\t    return views::repeat(*std::forward<_Range>(__r)._M_value,\n\t\t\t\t std::min(ranges::distance(__r), __n));\n\t  else\n\t    return views::repeat(*std::forward<_Range>(__r)._M_value, __n);\n\t}\n\n      template<typename _Range>\n\tconstexpr auto\n\t__drop_of_repeat_view(_Range&& __r, range_difference_t<_Range> __n)\n\t{\n\t  using _Tp = remove_cvref_t<_Range>;\n\t  static_assert(__is_repeat_view<_Tp>);\n\t  if constexpr (sized_range<_Tp>)\n\t    {\n\t      auto __sz = ranges::distance(__r);\n\t      return views::repeat(*std::forward<_Range>(__r)._M_value,\n\t\t\t\t   __sz - std::min(__sz, __n));\n\t    }\n\t  else\n\t    return __r;\n\t}\n    }\n  }\n#endif // __cpp_lib_ranges_repeat\n\n#ifdef __cpp_lib_ranges_stride // C++ >= 23\n  template<input_range _Vp>\n    requires view<_Vp>\n  class stride_view : public view_interface<stride_view<_Vp>>\n  {\n    _Vp _M_base;\n    range_difference_t<_Vp> _M_stride;\n\n    template<bool _Const> using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n\n    template<bool _Const>\n    struct __iter_cat\n    { };\n\n    template<bool _Const>\n      requires forward_range<_Base<_Const>>\n    struct __iter_cat<_Const>\n    {\n    private:\n      static auto\n      _S_iter_cat()\n      {\n\tusing _Cat = typename iterator_traits<iterator_t<_Base<_Const>>>::iterator_category;\n\tif constexpr (derived_from<_Cat, random_access_iterator_tag>)\n\t  return random_access_iterator_tag{};\n\telse\n\t  return _Cat{};\n      }\n    public:\n      using iterator_category = decltype(_S_iter_cat());\n    };\n\n    template<bool> class _Iterator;\n\n  public:\n    constexpr explicit\n    stride_view(_Vp __base, range_difference_t<_Vp> __stride)\n    : _M_base(std::move(__base)), _M_stride(__stride)\n    { __glibcxx_assert(__stride > 0); }\n\n    constexpr _Vp\n    base() const& requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr range_difference_t<_Vp>\n    stride() const noexcept\n    { return _M_stride; }\n\n    constexpr auto\n    begin() requires (!__detail::__simple_view<_Vp>)\n    { return _Iterator<false>(this, ranges::begin(_M_base)); }\n\n    constexpr auto\n    begin() const requires range<const _Vp>\n    { return _Iterator<true>(this, ranges::begin(_M_base)); }\n\n    constexpr auto\n    end() requires (!__detail::__simple_view<_Vp>)\n    {\n      if constexpr (common_range<_Vp> && sized_range<_Vp> && forward_range<_Vp>)\n\t{\n\t  auto __missing = (_M_stride - ranges::distance(_M_base) % _M_stride) % _M_stride;\n\t  return _Iterator<false>(this, ranges::end(_M_base), __missing);\n\t}\n      else if constexpr (common_range<_Vp> && !bidirectional_range<_Vp>)\n\treturn _Iterator<false>(this, ranges::end(_M_base));\n      else\n        return default_sentinel;\n    }\n\n    constexpr auto\n    end() const requires range<const _Vp>\n    {\n      if constexpr (common_range<const _Vp> && sized_range<const _Vp>\n\t\t    && forward_range<const _Vp>)\n\t{\n\t  auto __missing = (_M_stride - ranges::distance(_M_base) % _M_stride) % _M_stride;\n\t  return _Iterator<true>(this, ranges::end(_M_base), __missing);\n\t}\n      else if constexpr (common_range<const _Vp> && !bidirectional_range<const _Vp>)\n        return _Iterator<true>(this, ranges::end(_M_base));\n      else\n        return default_sentinel;\n    }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    {\n      return __detail::__to_unsigned_like\n\t(__detail::__div_ceil(ranges::distance(_M_base), _M_stride));\n    }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    {\n      return __detail::__to_unsigned_like\n\t(__detail::__div_ceil(ranges::distance(_M_base), _M_stride));\n    }\n  };\n\n  template<typename _Range>\n    stride_view(_Range&&, range_difference_t<_Range>) -> stride_view<views::all_t<_Range>>;\n\n  template<typename _Vp>\n    inline constexpr bool enable_borrowed_range<stride_view<_Vp>>\n      = enable_borrowed_range<_Vp>;\n\n  template<input_range _Vp>\n    requires view<_Vp>\n  template<bool _Const>\n  class stride_view<_Vp>::_Iterator : public __iter_cat<_Const>\n  {\n    using _Parent = __detail::__maybe_const_t<_Const, stride_view>;\n    using _Base = stride_view::_Base<_Const>;\n\n    iterator_t<_Base> _M_current = iterator_t<_Base>();\n    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n    range_difference_t<_Base> _M_stride = 0;\n    range_difference_t<_Base> _M_missing = 0;\n\n    constexpr\n    _Iterator(_Parent* __parent, iterator_t<_Base> __current,\n\t      range_difference_t<_Base> __missing = 0)\n    : _M_current(std::move(__current)), _M_end(ranges::end(__parent->_M_base)),\n      _M_stride(__parent->_M_stride), _M_missing(__missing)\n    { }\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (random_access_range<_Base>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (bidirectional_range<_Base>)\n\treturn bidirectional_iterator_tag{};\n      else if constexpr (forward_range<_Base>)\n\treturn forward_iterator_tag{};\n      else\n\treturn input_iterator_tag{};\n    }\n\n    friend stride_view;\n\n  public:\n    using difference_type = range_difference_t<_Base>;\n    using value_type = range_value_t<_Base>;\n    using iterator_concept = decltype(_S_iter_concept());\n    // iterator_category defined in stride_view::__iter_cat\n\n    _Iterator() requires default_initializable<iterator_t<_Base>> = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __other)\n      requires _Const\n\t&& convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n\t&& convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n     : _M_current(std::move(__other._M_current)), _M_end(std::move(__other._M_end)),\n       _M_stride(__other._M_stride), _M_missing(__other._M_missing)\n     { }\n\n    constexpr iterator_t<_Base>\n    base() &&\n    { return std::move(_M_current); }\n\n    constexpr const iterator_t<_Base>&\n    base() const & noexcept\n    { return _M_current; }\n\n    constexpr decltype(auto)\n    operator*() const\n    { return *_M_current; }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      __glibcxx_assert(_M_current != _M_end);\n      _M_missing = ranges::advance(_M_current, _M_stride, _M_end);\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    constexpr _Iterator\n    operator++(int) requires forward_range<_Base>\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Base>\n    {\n      ranges::advance(_M_current, _M_missing - _M_stride);\n      _M_missing = 0;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Base>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __n) requires random_access_range<_Base>\n    {\n      if (__n > 0)\n\t{\n\t  __glibcxx_assert(ranges::distance(_M_current, _M_end) > _M_stride * (__n - 1));\n\t  _M_missing = ranges::advance(_M_current, _M_stride * __n, _M_end);\n\t}\n      else if (__n < 0)\n\t{\n\t  ranges::advance(_M_current, _M_stride * __n + _M_missing);\n\t  _M_missing = 0;\n\t}\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __n) requires random_access_range<_Base>\n    { return *this += -__n; }\n\n    constexpr decltype(auto) operator[](difference_type __n) const\n      requires random_access_range<_Base>\n    { return *(*this + __n); }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, default_sentinel_t)\n    { return __x._M_current == __x._M_end; }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n      requires equality_comparable<iterator_t<_Base>>\n    { return __x._M_current == __y._M_current; }\n\n    friend constexpr bool\n    operator<(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __x._M_current < __y._M_current; }\n\n    friend constexpr bool\n    operator>(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return __y._M_current < __x._M_current; }\n\n    friend constexpr bool\n    operator<=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__y._M_current < __x._M_current); }\n\n    friend constexpr bool\n    operator>=(const _Iterator& __x, const _Iterator& __y)\n      requires random_access_range<_Base>\n    { return !(__x._M_current < __y._M_current); }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n        requires random_access_range<_Base> && three_way_comparable<iterator_t<_Base>>\n    { return __x._M_current <=> __y._M_current; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r += __n;\n      return __r;\n    }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __i)\n      requires random_access_range<_Base>\n    { return __i + __n; }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __i, difference_type __n)\n      requires random_access_range<_Base>\n    {\n      auto __r = __i;\n      __r -= __n;\n      return __r;\n    }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n    {\n      auto __n = __x._M_current - __y._M_current;\n      if constexpr (forward_range<_Base>)\n\treturn (__n + __x._M_missing - __y._M_missing) / __x._M_stride;\n      else if (__n < 0)\n\treturn -__detail::__div_ceil(-__n, __x._M_stride);\n      else\n\treturn __detail::__div_ceil(__n, __x._M_stride);\n    }\n\n    friend constexpr difference_type\n    operator-(default_sentinel_t, const _Iterator& __x)\n      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n    { return __detail::__div_ceil(__x._M_end - __x._M_current, __x._M_stride); }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, default_sentinel_t __y)\n      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n    { return -(__y - __x); }\n\n    friend constexpr range_rvalue_reference_t<_Base>\n    iter_move(const _Iterator& __i)\n      noexcept(noexcept(ranges::iter_move(__i._M_current)))\n    { return ranges::iter_move(__i._M_current); }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __x, const _Iterator& __y)\n      noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n      requires indirectly_swappable<iterator_t<_Base>>\n    { ranges::iter_swap(__x._M_current, __y._M_current); }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Range, typename _Dp>\n\tconcept __can_stride_view\n\t  = requires { stride_view(std::declval<_Range>(), std::declval<_Dp>()); };\n    }\n\n    struct _Stride : __adaptor::_RangeAdaptor<_Stride>\n    {\n      template<viewable_range _Range, typename _Dp = range_difference_t<_Range>>\n\trequires __detail::__can_stride_view<_Range, _Dp>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r, type_identity_t<_Dp> __n) const\n\t{ return stride_view(std::forward<_Range>(__r), __n); }\n\n      using __adaptor::_RangeAdaptor<_Stride>::operator();\n      static constexpr int _S_arity = 2;\n      static constexpr bool _S_has_simple_extra_args = true;\n    };\n\n    inline constexpr _Stride stride;\n  }\n#endif // __cpp_lib_ranges_stride\n\n#ifdef __cpp_lib_ranges_cartesian_product // C++ >= 23\n  namespace __detail\n  {\n    template<bool _Const, typename _First, typename... _Vs>\n      concept __cartesian_product_is_random_access\n\t= (random_access_range<__maybe_const_t<_Const, _First>>\n\t   && ...\n\t   && (random_access_range<__maybe_const_t<_Const, _Vs>>\n\t       && sized_range<__maybe_const_t<_Const, _Vs>>));\n\n    template<typename _Range>\n      concept __cartesian_product_common_arg\n\t= common_range<_Range> || (sized_range<_Range> && random_access_range<_Range>);\n\n    template<bool _Const, typename _First, typename... _Vs>\n      concept __cartesian_product_is_bidirectional\n\t= (bidirectional_range<__maybe_const_t<_Const, _First>>\n\t   && ...\n\t   && (bidirectional_range<__maybe_const_t<_Const, _Vs>>\n\t       && __cartesian_product_common_arg<__maybe_const_t<_Const, _Vs>>));\n\n    template<typename _First, typename... _Vs>\n      concept __cartesian_product_is_common = __cartesian_product_common_arg<_First>;\n\n    template<typename... _Vs>\n      concept __cartesian_product_is_sized = (sized_range<_Vs> && ...);\n\n    template<bool _Const, template<typename> class FirstSent, typename _First, typename... _Vs>\n      concept __cartesian_is_sized_sentinel\n\t= (sized_sentinel_for<FirstSent<__maybe_const_t<_Const, _First>>,\n\t\t\t      iterator_t<__maybe_const_t<_Const, _First>>>\n\t   && ...\n\t   && (sized_range<__maybe_const_t<_Const, _Vs>>\n\t       && sized_sentinel_for<iterator_t<__maybe_const_t<_Const, _Vs>>,\n\t\t\t\t     iterator_t<__maybe_const_t<_Const, _Vs>>>));\n\n    template<__cartesian_product_common_arg _Range>\n      constexpr auto\n      __cartesian_common_arg_end(_Range& __r)\n      {\n\tif constexpr (common_range<_Range>)\n\t  return ranges::end(__r);\n\telse\n\t  return ranges::begin(__r) + ranges::distance(__r);\n      }\n  } // namespace __detail\n\n  template<input_range _First, forward_range... _Vs>\n    requires (view<_First> && ... && view<_Vs>)\n  class cartesian_product_view : public view_interface<cartesian_product_view<_First, _Vs...>>\n  {\n    tuple<_First, _Vs...> _M_bases;\n\n    template<bool> class _Iterator;\n\n    static auto\n    _S_difference_type()\n    {\n      // TODO: Implement the recommended practice of using the smallest\n      // sufficiently wide type according to the maximum sizes of the\n      // underlying ranges?\n      return common_type_t<ptrdiff_t,\n\t\t\t   range_difference_t<_First>,\n\t\t\t   range_difference_t<_Vs>...>{};\n    }\n\n  public:\n    cartesian_product_view() = default;\n\n    constexpr explicit\n    cartesian_product_view(_First __first, _Vs... __rest)\n    : _M_bases(std::move(__first), std::move(__rest)...)\n    { }\n\n    constexpr _Iterator<false>\n    begin() requires (!__detail::__simple_view<_First> || ... || !__detail::__simple_view<_Vs>)\n    { return _Iterator<false>(*this, __detail::__tuple_transform(ranges::begin, _M_bases)); }\n\n    constexpr _Iterator<true>\n    begin() const requires (range<const _First> && ... && range<const _Vs>)\n    { return _Iterator<true>(*this, __detail::__tuple_transform(ranges::begin, _M_bases)); }\n\n    constexpr _Iterator<false>\n    end() requires ((!__detail::__simple_view<_First> || ... || !__detail::__simple_view<_Vs>)\n\t\t    && __detail::__cartesian_product_is_common<_First, _Vs...>)\n    {\n      auto __its = [this]<size_t... _Is>(index_sequence<_Is...>) {\n\tusing _Ret = tuple<iterator_t<_First>, iterator_t<_Vs>...>;\n\tbool __empty_tail = (ranges::empty(std::get<1 + _Is>(_M_bases)) || ...);\n\tauto& __first = std::get<0>(_M_bases);\n\treturn _Ret{(__empty_tail\n\t\t     ? ranges::begin(__first)\n\t\t     : __detail::__cartesian_common_arg_end(__first)),\n\t\t    ranges::begin(std::get<1 + _Is>(_M_bases))...};\n      }(make_index_sequence<sizeof...(_Vs)>{});\n\n      return _Iterator<false>{*this, std::move(__its)};\n    }\n\n    constexpr _Iterator<true>\n    end() const requires __detail::__cartesian_product_is_common<const _First, const _Vs...>\n    {\n      auto __its = [this]<size_t... _Is>(index_sequence<_Is...>) {\n\tusing _Ret = tuple<iterator_t<const _First>, iterator_t<const _Vs>...>;\n\tbool __empty_tail = (ranges::empty(std::get<1 + _Is>(_M_bases)) || ...);\n\tauto& __first = std::get<0>(_M_bases);\n\treturn _Ret{(__empty_tail\n\t\t     ? ranges::begin(__first)\n\t\t     : __detail::__cartesian_common_arg_end(__first)),\n\t\t    ranges::begin(std::get<1 + _Is>(_M_bases))...};\n      }(make_index_sequence<sizeof...(_Vs)>{});\n\n      return _Iterator<true>{*this, std::move(__its)};\n    }\n\n    constexpr default_sentinel_t\n    end() const noexcept\n    { return default_sentinel; }\n\n    constexpr auto\n    size() requires __detail::__cartesian_product_is_sized<_First, _Vs...>\n    {\n      using _ST = __detail::__make_unsigned_like_t<decltype(_S_difference_type())>;\n      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n\tauto __size = static_cast<_ST>(1);\n#ifdef _GLIBCXX_ASSERTIONS\n\tif constexpr (integral<_ST>)\n\t  {\n\t    bool __overflow\n\t      = (__builtin_mul_overflow(__size,\n\t\t\t\t\tstatic_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))),\n\t\t\t\t\t&__size)\n\t\t || ...);\n\t    __glibcxx_assert(!__overflow);\n\t  }\n\telse\n#endif\n\t  __size = (static_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))) * ...);\n\treturn __size;\n      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n    }\n\n    constexpr auto\n    size() const requires __detail::__cartesian_product_is_sized<const _First, const _Vs...>\n    {\n      using _ST = __detail::__make_unsigned_like_t<decltype(_S_difference_type())>;\n      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n\tauto __size = static_cast<_ST>(1);\n#ifdef _GLIBCXX_ASSERTIONS\n\tif constexpr (integral<_ST>)\n\t  {\n\t    bool __overflow\n\t      = (__builtin_mul_overflow(__size,\n\t\t\t\t\tstatic_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))),\n\t\t\t\t\t&__size)\n\t\t || ...);\n\t    __glibcxx_assert(!__overflow);\n\t  }\n\telse\n#endif\n\t  __size = (static_cast<_ST>(ranges::size(std::get<_Is>(_M_bases))) * ...);\n\treturn __size;\n      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n    }\n  };\n\n  template<typename... _Vs>\n    cartesian_product_view(_Vs&&...) -> cartesian_product_view<views::all_t<_Vs>...>;\n\n  template<input_range _First, forward_range... _Vs>\n    requires (view<_First> && ... && view<_Vs>)\n  template<bool _Const>\n  class cartesian_product_view<_First, _Vs...>::_Iterator\n  {\n    using _Parent = __maybe_const_t<_Const, cartesian_product_view>;\n    _Parent* _M_parent = nullptr;\n    tuple<iterator_t<__maybe_const_t<_Const, _First>>,\n\t  iterator_t<__maybe_const_t<_Const, _Vs>>...> _M_current;\n\n    constexpr\n    _Iterator(_Parent& __parent, decltype(_M_current) __current)\n    : _M_parent(std::__addressof(__parent)),\n      _M_current(std::move(__current))\n    { }\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (__detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (__detail::__cartesian_product_is_bidirectional<_Const, _First, _Vs...>)\n\treturn bidirectional_iterator_tag{};\n      else if constexpr (forward_range<__maybe_const_t<_Const, _First>>)\n\treturn forward_iterator_tag{};\n      else\n\treturn input_iterator_tag{};\n    }\n\n    friend cartesian_product_view;\n\n  public:\n    using iterator_category = input_iterator_tag;\n    using iterator_concept = decltype(_S_iter_concept());\n    using value_type\n      = tuple<range_value_t<__maybe_const_t<_Const, _First>>,\n\t      range_value_t<__maybe_const_t<_Const, _Vs>>...>;\n    using reference\n      = tuple<range_reference_t<__maybe_const_t<_Const, _First>>,\n\t      range_reference_t<__maybe_const_t<_Const, _Vs>>...>;\n    using difference_type = decltype(cartesian_product_view::_S_difference_type());\n\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const\n\t&& (convertible_to<iterator_t<_First>, iterator_t<const _First>>\n\t    && ... && convertible_to<iterator_t<_Vs>, iterator_t<const _Vs>>)\n    : _M_parent(std::__addressof(__i._M_parent)),\n      _M_current(std::move(__i._M_current))\n    { }\n\n    constexpr auto\n    operator*() const\n    {\n      auto __f = [](auto& __i) -> decltype(auto) {\n\treturn *__i;\n      };\n      return __detail::__tuple_transform(__f, _M_current);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      _M_next();\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    constexpr _Iterator\n    operator++(int) requires forward_range<__maybe_const_t<_Const, _First>>\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--()\n      requires __detail::__cartesian_product_is_bidirectional<_Const, _First, _Vs...>\n    {\n      _M_prev();\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int)\n      requires __detail::__cartesian_product_is_bidirectional<_Const, _First, _Vs...>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __x)\n      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n    {\n      _M_advance(__x);\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __x)\n      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n    { return *this += -__x; }\n\n    constexpr reference\n    operator[](difference_type __n) const\n      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n    { return *((*this) + __n); }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n      requires equality_comparable<iterator_t<__maybe_const_t<_Const, _First>>>\n    { return __x._M_current == __y._M_current; }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, default_sentinel_t)\n    {\n      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n\treturn ((std::get<_Is>(__x._M_current)\n\t\t == ranges::end(std::get<_Is>(__x._M_parent->_M_bases)))\n\t\t|| ...);\n      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n    }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__all_random_access<_Const, _First, _Vs...>\n    { return __x._M_current <=> __y._M_current; }\n\n    friend constexpr _Iterator\n    operator+(_Iterator __x, difference_type __y)\n      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n    { return __x += __y; }\n\n    friend constexpr _Iterator\n    operator+(difference_type __x, _Iterator __y)\n      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n    { return __y += __x; }\n\n    friend constexpr _Iterator\n    operator-(_Iterator __x, difference_type __y)\n      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n    { return __x -= __y; }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__cartesian_is_sized_sentinel<_Const, iterator_t, _First, _Vs...>\n    { return __x._M_distance_from(__y._M_current); }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __i, default_sentinel_t)\n      requires __detail::__cartesian_is_sized_sentinel<_Const, sentinel_t, _First, _Vs...>\n    {\n      tuple __end_tuple = [&]<size_t... _Is>(index_sequence<_Is...>) {\n\treturn tuple{ranges::end(std::get<0>(__i._M_parent->_M_bases)),\n\t\t     ranges::begin(std::get<1 + _Is>(__i._M_parent->_M_bases))...};\n      }(make_index_sequence<sizeof...(_Vs)>{});\n      return __i._M_distance_from(__end_tuple);\n    }\n\n    friend constexpr difference_type\n    operator-(default_sentinel_t, const _Iterator& __i)\n      requires __detail::__cartesian_is_sized_sentinel<_Const, sentinel_t, _First, _Vs...>\n    { return -(__i - default_sentinel); }\n\n    friend constexpr auto\n    iter_move(const _Iterator& __i)\n    { return __detail::__tuple_transform(ranges::iter_move, __i._M_current); }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __l, const _Iterator& __r)\n      requires (indirectly_swappable<iterator_t<__maybe_const_t<_Const, _First>>>\n\t\t&& ...\n\t\t&& indirectly_swappable<iterator_t<__maybe_const_t<_Const, _Vs>>>)\n    {\n      [&]<size_t... _Is>(index_sequence<_Is...>) {\n\t(ranges::iter_swap(std::get<_Is>(__l._M_current), std::get<_Is>(__r._M_current)), ...);\n      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n    }\n\n  private:\n    template<size_t _Nm = sizeof...(_Vs)>\n    constexpr void\n    _M_next()\n    {\n      auto& __it = std::get<_Nm>(_M_current);\n      ++__it;\n      if constexpr (_Nm > 0)\n\tif (__it == ranges::end(std::get<_Nm>(_M_parent->_M_bases)))\n\t  {\n\t    __it = ranges::begin(std::get<_Nm>(_M_parent->_M_bases));\n\t    _M_next<_Nm - 1>();\n\t  }\n    }\n\n    template<size_t _Nm = sizeof...(_Vs)>\n    constexpr void\n    _M_prev()\n    {\n      auto& __it = std::get<_Nm>(_M_current);\n      if constexpr (_Nm > 0)\n\tif (__it == ranges::begin(std::get<_Nm>(_M_parent->_M_bases)))\n\t  {\n\t    __it = __detail::__cartesian_common_arg_end(std::get<_Nm>(_M_parent->_M_bases));\n\t    _M_prev<_Nm - 1>();\n\t  }\n      --__it;\n    }\n\n    template<size_t _Nm = sizeof...(_Vs)>\n    constexpr void\n    _M_advance(difference_type __x)\n      requires __detail::__cartesian_product_is_random_access<_Const, _First, _Vs...>\n    {\n      if (__x == 1)\n\t_M_next<_Nm>();\n      else if (__x == -1)\n\t_M_prev<_Nm>();\n      else if (__x != 0)\n\t{\n\t  // Constant time iterator advancement.\n\t  auto& __r = std::get<_Nm>(_M_parent->_M_bases);\n\t  auto& __it = std::get<_Nm>(_M_current);\n\t  if constexpr (_Nm == 0)\n\t    {\n#ifdef _GLIBCXX_ASSERTIONS\n\t      if constexpr (sized_range<__maybe_const_t<_Const, _First>>)\n\t\t{\n\t\t  auto __size = ranges::ssize(__r);\n\t\t  auto __begin = ranges::begin(__r);\n\t\t  auto __offset = __it - __begin;\n\t\t  __glibcxx_assert(__offset + __x >= 0 && __offset + __x <= __size);\n\t\t}\n#endif\n\t      __it += __x;\n\t    }\n\t  else\n\t    {\n\t      auto __size = ranges::ssize(__r);\n\t      auto __begin = ranges::begin(__r);\n\t      auto __offset = __it - __begin;\n\t      __offset += __x;\n\t      __x = __offset / __size;\n\t      __offset %= __size;\n\t      if (__offset < 0)\n\t\t{\n\t\t  __offset = __size + __offset;\n\t\t  --__x;\n\t\t}\n\t      __it = __begin + __offset;\n\t      _M_advance<_Nm - 1>(__x);\n\t    }\n\t}\n    }\n\n    template<typename _Tuple>\n    constexpr difference_type\n    _M_distance_from(const _Tuple& __t) const\n    {\n      return [&]<size_t... _Is>(index_sequence<_Is...>) {\n\tauto __sum = static_cast<difference_type>(0);\n#ifdef _GLIBCXX_ASSERTIONS\n\tif constexpr (integral<difference_type>)\n\t  {\n\t    bool __overflow\n\t      = (__builtin_add_overflow(__sum, _M_scaled_distance<_Is>(__t), &__sum)\n\t\t || ...);\n\t    __glibcxx_assert(!__overflow);\n\t  }\n\telse\n#endif\n\t  __sum = (_M_scaled_distance<_Is>(__t) + ...);\n\treturn __sum;\n      }(make_index_sequence<1 + sizeof...(_Vs)>{});\n    }\n\n    template<size_t _Nm, typename _Tuple>\n    constexpr difference_type\n    _M_scaled_distance(const _Tuple& __t) const\n    {\n      auto __dist = static_cast<difference_type>(std::get<_Nm>(_M_current)\n\t\t\t\t\t\t - std::get<_Nm>(__t));\n#ifdef _GLIBCXX_ASSERTIONS\n      if constexpr (integral<difference_type>)\n\t{\n\t  bool __overflow = __builtin_mul_overflow(__dist, _M_scaled_size<_Nm+1>(), &__dist);\n\t  __glibcxx_assert(!__overflow);\n\t}\n      else\n#endif\n\t__dist *= _M_scaled_size<_Nm+1>();\n      return __dist;\n    }\n\n    template<size_t _Nm>\n    constexpr difference_type\n    _M_scaled_size() const\n    {\n      if constexpr (_Nm <= sizeof...(_Vs))\n\t{\n\t  auto __size = static_cast<difference_type>(ranges::size\n\t\t\t\t\t\t     (std::get<_Nm>(_M_parent->_M_bases)));\n#ifdef _GLIBCXX_ASSERTIONS\n\t  if constexpr (integral<difference_type>)\n\t    {\n\t      bool __overflow = __builtin_mul_overflow(__size, _M_scaled_size<_Nm+1>(), &__size);\n\t      __glibcxx_assert(!__overflow);\n\t    }\n\t  else\n#endif\n\t    __size *= _M_scaled_size<_Nm+1>();\n\t  return __size;\n\t}\n      else\n\treturn static_cast<difference_type>(1);\n    }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename... _Ts>\n\tconcept __can_cartesian_product_view\n\t  = requires { cartesian_product_view<all_t<_Ts>...>(std::declval<_Ts>()...); };\n    }\n\n    struct _CartesianProduct\n    {\n      template<typename... _Ts>\n\trequires (sizeof...(_Ts) == 0 || __detail::__can_cartesian_product_view<_Ts...>)\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Ts&&... __ts) const\n\t{\n\t  if constexpr (sizeof...(_Ts) == 0)\n\t    return views::single(tuple{});\n\t  else\n\t    return cartesian_product_view<all_t<_Ts>...>(std::forward<_Ts>(__ts)...);\n\t}\n    };\n\n    inline constexpr _CartesianProduct cartesian_product;\n  }\n#endif // __cpp_lib_ranges_cartesian_product\n\n#ifdef __cpp_lib_ranges_as_rvalue // C++ >= 23\n  template<input_range _Vp>\n    requires view<_Vp>\n  class as_rvalue_view : public view_interface<as_rvalue_view<_Vp>>\n  {\n    _Vp _M_base = _Vp();\n\n  public:\n    as_rvalue_view() requires default_initializable<_Vp> = default;\n\n    constexpr explicit\n    as_rvalue_view(_Vp __base)\n    : _M_base(std::move(__base))\n    { }\n\n    constexpr _Vp\n    base() const& requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin() requires (!__detail::__simple_view<_Vp>)\n    { return move_iterator(ranges::begin(_M_base)); }\n\n    constexpr auto\n    begin() const requires range<const _Vp>\n    { return move_iterator(ranges::begin(_M_base)); }\n\n    constexpr auto\n    end() requires (!__detail::__simple_view<_Vp>)\n    {\n      if constexpr (common_range<_Vp>)\n\treturn move_iterator(ranges::end(_M_base));\n      else\n\treturn move_sentinel(ranges::end(_M_base));\n    }\n\n    constexpr auto\n    end() const requires range<const _Vp>\n    {\n      if constexpr (common_range<const _Vp>)\n\treturn move_iterator(ranges::end(_M_base));\n      else\n\treturn move_sentinel(ranges::end(_M_base));\n    }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    { return ranges::size(_M_base); }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    { return ranges::size(_M_base); }\n  };\n\n  template<typename _Range>\n    as_rvalue_view(_Range&&) -> as_rvalue_view<views::all_t<_Range>>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<as_rvalue_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Tp>\n\tconcept __can_as_rvalue_view = requires { as_rvalue_view(std::declval<_Tp>()); };\n    }\n\n    struct _AsRvalue : __adaptor::_RangeAdaptorClosure<_AsRvalue>\n    {\n      template<viewable_range _Range>\n\trequires __detail::__can_as_rvalue_view<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\t{\n\t  if constexpr (same_as<range_rvalue_reference_t<_Range>,\n\t\t\t\trange_reference_t<_Range>>)\n\t    return views::all(std::forward<_Range>(__r));\n\t  else\n\t    return as_rvalue_view(std::forward<_Range>(__r));\n\t}\n    };\n\n    inline constexpr _AsRvalue as_rvalue;\n  }\n#endif // __cpp_lib_as_rvalue\n\n#ifdef __cpp_lib_ranges_enumerate // C++ >= 23\n  namespace __detail\n  {\n    template<typename _Range>\n      concept __range_with_movable_reference = input_range<_Range>\n\t&& move_constructible<range_reference_t<_Range>>\n\t&& move_constructible<range_rvalue_reference_t<_Range>>;\n  }\n\n  template<view _Vp>\n    requires __detail::__range_with_movable_reference<_Vp>\n  class enumerate_view : public view_interface<enumerate_view<_Vp>>\n  {\n    _Vp _M_base = _Vp();\n\n    template<bool _Const> class _Iterator;\n    template<bool _Const> class _Sentinel;\n\n  public:\n    enumerate_view() requires default_initializable<_Vp> = default;\n\n    constexpr explicit\n    enumerate_view(_Vp __base)\n    : _M_base(std::move(__base))\n    { }\n\n    constexpr auto\n    begin() requires (!__detail::__simple_view<_Vp>)\n    { return _Iterator<false>(ranges::begin(_M_base), 0); }\n\n    constexpr auto\n    begin() const requires __detail::__range_with_movable_reference<const _Vp>\n    { return _Iterator<true>(ranges::begin(_M_base), 0); }\n\n    constexpr auto\n    end() requires (!__detail::__simple_view<_Vp>)\n    {\n      if constexpr (common_range<_Vp> && sized_range<_Vp>)\n\treturn _Iterator<false>(ranges::end(_M_base), ranges::distance(_M_base));\n      else\n\treturn _Sentinel<false>(ranges::end(_M_base));\n    }\n\n    constexpr auto\n    end() const requires __detail::__range_with_movable_reference<const _Vp>\n    {\n      if constexpr (common_range<const _Vp> && sized_range<const _Vp>)\n\treturn _Iterator<true>(ranges::end(_M_base), ranges::distance(_M_base));\n      else\n\treturn _Sentinel<true>(ranges::end(_M_base));\n    }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    { return ranges::size(_M_base); }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    { return ranges::size(_M_base); }\n\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n  };\n\n  template<typename _Range>\n    enumerate_view(_Range&&) -> enumerate_view<views::all_t<_Range>>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<enumerate_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  template<view _Vp>\n  requires __detail::__range_with_movable_reference<_Vp>\n  template<bool _Const>\n  class enumerate_view<_Vp>::_Iterator\n  {\n    using _Base = __maybe_const_t<_Const, _Vp>;\n\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (random_access_range<_Base>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (bidirectional_range<_Base>)\n\treturn bidirectional_iterator_tag{};\n      else if constexpr (forward_range<_Base>)\n\treturn forward_iterator_tag{};\n      else\n\treturn input_iterator_tag{};\n    }\n\n    friend enumerate_view;\n\n  public:\n    using iterator_category = input_iterator_tag;\n    using iterator_concept = decltype(_S_iter_concept());\n    using difference_type = range_difference_t<_Base>;\n    using value_type = tuple<difference_type, range_value_t<_Base>>;\n\n  private:\n    using __reference_type = tuple<difference_type, range_reference_t<_Base>>;\n\n    iterator_t<_Base> _M_current = iterator_t<_Base>();\n    difference_type _M_pos = 0;\n\n    constexpr explicit\n    _Iterator(iterator_t<_Base> __current, difference_type __pos)\n    : _M_current(std::move(__current)), _M_pos(__pos)\n    { }\n\n  public:\n    _Iterator() requires default_initializable<iterator_t<_Base>> = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n    requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n    : _M_current(std::move(__i._M_current)), _M_pos(__i._M_pos)\n    { }\n\n    constexpr const iterator_t<_Base> &\n    base() const & noexcept\n    { return _M_current; }\n\n    constexpr iterator_t<_Base>\n    base() &&\n    { return std::move(_M_current); }\n\n    constexpr difference_type\n    index() const noexcept\n    { return _M_pos; }\n\n    constexpr auto\n    operator*() const\n    { return __reference_type(_M_pos, *_M_current); }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      ++_M_current;\n      ++_M_pos;\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    constexpr _Iterator\n    operator++(int) requires forward_range<_Base>\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--() requires bidirectional_range<_Base>\n    {\n      --_M_current;\n      --_M_pos;\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int) requires bidirectional_range<_Base>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __n) requires random_access_range<_Base>\n    {\n      _M_current += __n;\n      _M_pos += __n;\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __n) requires random_access_range<_Base>\n    {\n      _M_current -= __n;\n      _M_pos -= __n;\n      return *this;\n    }\n\n    constexpr auto\n    operator[](difference_type __n) const requires random_access_range<_Base>\n    { return __reference_type(_M_pos + __n, _M_current[__n]); }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y) noexcept\n    { return __x._M_pos == __y._M_pos; }\n\n    friend constexpr strong_ordering\n    operator<=>(const _Iterator& __x, const _Iterator& __y) noexcept\n    { return __x._M_pos <=> __y._M_pos; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __x, difference_type __y)\n    requires random_access_range<_Base>\n    { return (auto(__x) += __y); }\n\n    friend constexpr _Iterator\n    operator+(difference_type __x, const _Iterator& __y)\n    requires random_access_range<_Base>\n    { return auto(__y) += __x; }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __x, difference_type __y)\n    requires random_access_range<_Base>\n    { return auto(__x) -= __y; }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y) noexcept\n    { return __x._M_pos - __y._M_pos; }\n\n    friend constexpr auto\n    iter_move(const _Iterator& __i)\n    noexcept(noexcept(ranges::iter_move(__i._M_current))\n\t     && is_nothrow_move_constructible_v<range_rvalue_reference_t<_Base>>)\n    {\n      return tuple<difference_type, range_rvalue_reference_t<_Base>>\n\t(__i._M_pos, ranges::iter_move(__i._M_current));\n    }\n  };\n\n  template<view _Vp>\n  requires __detail::__range_with_movable_reference<_Vp>\n  template<bool _Const>\n  class enumerate_view<_Vp>::_Sentinel\n  {\n    using _Base = __maybe_const_t<_Const, _Vp>;\n\n    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n\n    constexpr explicit\n    _Sentinel(sentinel_t<_Base> __end)\n    : _M_end(std::move(__end))\n    { }\n\n    friend enumerate_view;\n\n  public:\n    _Sentinel() = default;\n\n    constexpr\n    _Sentinel(_Sentinel<!_Const> __other)\n    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n    : _M_end(std::move(__other._M_end))\n    { }\n\n    constexpr sentinel_t<_Base>\n    base() const\n    { return _M_end; }\n\n    template<bool _OtherConst>\n    requires sentinel_for<sentinel_t<_Base>, iterator_t<__maybe_const_t<_OtherConst, _Vp>>>\n    friend constexpr bool\n    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_current == __y._M_end; }\n\n    template<bool _OtherConst>\n    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<__maybe_const_t<_OtherConst, _Vp>>>\n    friend constexpr range_difference_t<__maybe_const_t<_OtherConst, _Vp>>\n    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n    { return __x._M_current - __y._M_end; }\n\n    template<bool _OtherConst>\n    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<__maybe_const_t<_OtherConst, _Vp>>>\n    friend constexpr range_difference_t<__maybe_const_t<_OtherConst, _Vp>>\n    operator-(const _Sentinel& __x, const _Iterator<_OtherConst>& __y)\n    { return __x._M_end - __y._M_current; }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Tp>\n\tconcept __can_enumerate_view\n\t  = requires { enumerate_view<all_t<_Tp>>(std::declval<_Tp>()); };\n    }\n\n    struct _Enumerate : __adaptor::_RangeAdaptorClosure<_Enumerate>\n    {\n      template<viewable_range _Range>\n\trequires __detail::__can_enumerate_view<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\t{ return enumerate_view<all_t<_Range>>(std::forward<_Range>(__r)); }\n    };\n\n    inline constexpr _Enumerate enumerate;\n  }\n#endif // __cpp_lib_ranges_enumerate\n\n#ifdef __cpp_lib_ranges_as_const // C++ >= 23\n  template<view _Vp>\n    requires input_range<_Vp>\n  class as_const_view : public view_interface<as_const_view<_Vp>>\n  {\n    _Vp _M_base = _Vp();\n\n  public:\n    as_const_view() requires default_initializable<_Vp> = default;\n\n    constexpr explicit\n    as_const_view(_Vp __base)\n    noexcept(is_nothrow_move_constructible_v<_Vp>)\n    : _M_base(std::move(__base))\n    { }\n\n    constexpr _Vp\n    base() const &\n    noexcept(is_nothrow_copy_constructible_v<_Vp>)\n    requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    noexcept(is_nothrow_move_constructible_v<_Vp>)\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin() requires (!__detail::__simple_view<_Vp>)\n    { return ranges::cbegin(_M_base); }\n\n    constexpr auto\n    begin() const requires range<const _Vp>\n    { return ranges::cbegin(_M_base); }\n\n    constexpr auto\n    end() requires (!__detail::__simple_view<_Vp>)\n    { return ranges::cend(_M_base); }\n\n    constexpr auto\n    end() const requires range<const _Vp>\n    { return ranges::cend(_M_base); }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    { return ranges::size(_M_base); }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    { return ranges::size(_M_base); }\n  };\n\n  template<typename _Range>\n    as_const_view(_Range&&) -> as_const_view<views::all_t<_Range>>;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range<as_const_view<_Tp>>\n      = enable_borrowed_range<_Tp>;\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Tp>\n\tinline constexpr bool __is_constable_ref_view = false;\n\n      template<typename _Range>\n\tinline constexpr bool __is_constable_ref_view<ref_view<_Range>>\n\t  = constant_range<const _Range>;\n\n      template<typename _Range>\n\tconcept __can_as_const_view = requires { as_const_view(std::declval<_Range>()); };\n    }\n\n    struct _AsConst : __adaptor::_RangeAdaptorClosure<_AsConst>\n    {\n      template<viewable_range _Range>\n      constexpr auto\n      operator()(_Range&& __r) const\n      noexcept(noexcept(as_const_view(std::declval<_Range>())))\n      requires __detail::__can_as_const_view<_Range>\n      {\n\tusing _Tp = remove_cvref_t<_Range>;\n\tusing element_type = remove_reference_t<range_reference_t<_Range>>;\n\tif constexpr (constant_range<views::all_t<_Range>>)\n\t  return views::all(std::forward<_Range>(__r));\n\telse if constexpr (__detail::__is_empty_view<_Tp>)\n\t  return views::empty<const element_type>;\n\telse if constexpr (std::__detail::__is_span<_Tp>)\n\t  return span<const element_type, _Tp::extent>(std::forward<_Range>(__r));\n\telse if constexpr (__detail::__is_constable_ref_view<_Tp>)\n\t  return ref_view(std::as_const(std::forward<_Range>(__r).base()));\n\telse if constexpr (is_lvalue_reference_v<_Range>\n\t\t\t   && constant_range<const _Tp>\n\t\t\t   && !view<_Tp>)\n\t  return ref_view(static_cast<const _Tp&>(__r));\n\telse\n\t  return as_const_view(std::forward<_Range>(__r));\n      }\n    };\n\n    inline constexpr _AsConst as_const;\n  }\n#endif // __cpp_lib_as_const\n} // namespace ranges\n\n  namespace views = ranges::views;\n\n#if __cpp_lib_ranges_to_container // C++ >= 23\nnamespace ranges\n{\n/// @cond undocumented\nnamespace __detail\n{\n  template<typename _Container>\n    constexpr bool __reservable_container\n      = sized_range<_Container>\n      && requires(_Container& __c, range_size_t<_Container> __n) {\n\t__c.reserve(__n);\n\t{ __c.capacity() } -> same_as<decltype(__n)>;\n\t{ __c.max_size() } -> same_as<decltype(__n)>;\n      };\n\n  template<typename _Cont, typename _Range>\n    constexpr bool __toable = requires {\n      requires (!input_range<_Cont>\n\t\t  || convertible_to<range_reference_t<_Range>,\n\t\t\t\t    range_value_t<_Cont>>);\n    };\n} // namespace __detail\n/// @endcond\n\n  /// Convert a range to a container.\n  /**\n   * @tparam _Cont A container type.\n   * @param __r A range that models the `input_range` concept.\n   * @param __args... Arguments to pass to the container constructor.\n   * @since C++23\n   *\n   * This function converts a range to the `_Cont` type.\n   *\n   * For example, `std::ranges::to<std::vector<int>>(some_view)`\n   * will convert the view to `std::vector<int>`.\n   *\n   * Additional constructor arguments for the container can be supplied after\n   * the input range argument, e.g.\n   * `std::ranges::to<std::vector<int, Alloc<int>>>(a_range, an_allocator)`.\n   */\n  template<typename _Cont, input_range _Rg, typename... _Args>\n    requires (!view<_Cont>)\n    constexpr _Cont\n    to [[nodiscard]] (_Rg&& __r, _Args&&... __args)\n    {\n      static_assert(!is_const_v<_Cont> && !is_volatile_v<_Cont>);\n      static_assert(is_class_v<_Cont> || is_union_v<_Cont>);\n\n      if constexpr (__detail::__toable<_Cont, _Rg>)\n\t{\n\t  if constexpr (constructible_from<_Cont, _Rg, _Args...>)\n\t    return _Cont(std::forward<_Rg>(__r),\n\t\t\t std::forward<_Args>(__args)...);\n\t  else if constexpr (constructible_from<_Cont, from_range_t, _Rg, _Args...>)\n\t    return _Cont(from_range, std::forward<_Rg>(__r),\n\t\t\t std::forward<_Args>(__args)...);\n\t  else if constexpr (requires { requires common_range<_Rg>;\n\t\ttypename __iter_category_t<iterator_t<_Rg>>;\n\t\trequires derived_from<__iter_category_t<iterator_t<_Rg>>,\n\t\t\t\t      input_iterator_tag>;\n\t\trequires constructible_from<_Cont, iterator_t<_Rg>,\n\t\t\t\t\t    sentinel_t<_Rg>, _Args...>;\n\t      })\n\t    return _Cont(ranges::begin(__r), ranges::end(__r),\n\t\t\t std::forward<_Args>(__args)...);\n\t  else\n\t    {\n\t      static_assert(constructible_from<_Cont, _Args...>);\n\t      _Cont __c(std::forward<_Args>(__args)...);\n\t      if constexpr (sized_range<_Rg>\n\t\t\t      && __detail::__reservable_container<_Cont>)\n\t\t__c.reserve(static_cast<range_size_t<_Cont>>(ranges::size(__r)));\n\t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t      // 4016. container-insertable checks do not match what\n\t      // container-inserter does\n\t      auto __it = ranges::begin(__r);\n\t      const auto __sent = ranges::end(__r);\n\t      while (__it != __sent)\n\t\t{\n\t\t  if constexpr (requires { __c.emplace_back(*__it); })\n\t\t    __c.emplace_back(*__it);\n\t\t  else if constexpr (requires { __c.push_back(*__it); })\n\t\t    __c.push_back(*__it);\n\t\t  else if constexpr (requires { __c.emplace(__c.end(), *__it); })\n\t\t    __c.emplace(__c.end(), *__it);\n\t\t  else\n\t\t    __c.insert(__c.end(), *__it);\n\t\t  ++__it;\n\t\t}\n\t      return __c;\n\t    }\n\t}\n      else\n\t{\n\t  static_assert(input_range<range_reference_t<_Rg>>);\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3984. ranges::to's recursion branch may be ill-formed\n\t  return ranges::to<_Cont>(ref_view(__r) | views::transform(\n\t\t[]<typename _Elt>(_Elt&& __elem) {\n\t\t  using _ValT = range_value_t<_Cont>;\n\t\t  return ranges::to<_ValT>(std::forward<_Elt>(__elem));\n\t\t}), std::forward<_Args>(__args)...);\n\t}\n    }\n\n/// @cond undocumented\nnamespace __detail\n{\n  template<typename _Rg>\n    struct _InputIter\n    {\n      using iterator_category = input_iterator_tag;\n      using value_type = range_value_t<_Rg>;\n      using difference_type = ptrdiff_t;\n      using pointer = add_pointer_t<range_reference_t<_Rg>>;\n      using reference = range_reference_t<_Rg>;\n      reference operator*() const;\n      pointer operator->() const;\n      _InputIter& operator++();\n      _InputIter operator++(int);\n      bool operator==(const _InputIter&) const;\n    };\n\n  template<template<typename...> typename _Cont, input_range _Rg,\n\t   typename... _Args>\n    using _DeduceExpr1\n      = decltype(_Cont(std::declval<_Rg>(), std::declval<_Args>()...));\n\n  template<template<typename...> typename _Cont, input_range _Rg,\n\t   typename... _Args>\n    using _DeduceExpr2\n      = decltype(_Cont(from_range, std::declval<_Rg>(),\n\t\t       std::declval<_Args>()...));\n\n  template<template<typename...> typename _Cont, input_range _Rg,\n\t   typename... _Args>\n    using _DeduceExpr3\n      = decltype(_Cont(std::declval<_InputIter<_Rg>>(),\n\t\t       std::declval<_InputIter<_Rg>>(),\n\t\t       std::declval<_Args>()...));\n\n} // namespace __detail\n/// @endcond\n\n  template<template<typename...> typename _Cont, input_range _Rg,\n\t   typename... _Args>\n    constexpr auto\n    to [[nodiscard]] (_Rg&& __r, _Args&&... __args)\n    {\n      using __detail::_DeduceExpr1;\n      using __detail::_DeduceExpr2;\n      using __detail::_DeduceExpr3;\n      if constexpr (requires { typename _DeduceExpr1<_Cont, _Rg, _Args...>; })\n\treturn ranges::to<_DeduceExpr1<_Cont, _Rg, _Args...>>(\n\t    std::forward<_Rg>(__r), std::forward<_Args>(__args)...);\n      else if constexpr (requires { typename _DeduceExpr2<_Cont, _Rg, _Args...>; })\n\treturn ranges::to<_DeduceExpr2<_Cont, _Rg, _Args...>>(\n\t    std::forward<_Rg>(__r), std::forward<_Args>(__args)...);\n      else if constexpr (requires { typename _DeduceExpr3<_Cont, _Rg, _Args...>; })\n\treturn ranges::to<_DeduceExpr3<_Cont, _Rg, _Args...>>(\n\t    std::forward<_Rg>(__r), std::forward<_Args>(__args)...);\n      else\n\tstatic_assert(false); // Cannot deduce container specialization.\n    }\n\n/// @cond undocumented\nnamespace __detail\n{\n  template<typename _Cont>\n    struct _To\n    {\n      template<typename _Range, typename... _Args>\n\trequires requires { ranges::to<_Cont>(std::declval<_Range>(),\n\t\t\t\t\t      std::declval<_Args>()...); }\n\tconstexpr auto\n\toperator()(_Range&& __r, _Args&&... __args) const\n\t{\n\t  return ranges::to<_Cont>(std::forward<_Range>(__r),\n\t\t\t\t   std::forward<_Args>(__args)...);\n\t}\n    };\n} // namespace __detail\n/// @endcond\n\n  /// ranges::to adaptor for converting a range to a container type\n  /**\n   * @tparam _Cont A container type.\n   * @param __args... Arguments to pass to the container constructor.\n   * @since C++23\n   *\n   * This range adaptor returns a range adaptor closure object that converts\n   * a range to the `_Cont` type.\n   *\n   * For example, `some_view | std::ranges::to<std::vector<int>>()`\n   * will convert the view to `std::vector<int>`.\n   *\n   * Additional constructor arguments for the container can be supplied, e.g.\n   * `r | std::ranges::to<std::vector<int, Alloc<int>>>(an_allocator)`.\n   */\n  template<typename _Cont, typename... _Args>\n    requires (!view<_Cont>)\n    constexpr auto\n    to [[nodiscard]] (_Args&&... __args)\n    {\n      static_assert(!is_const_v<_Cont> && !is_volatile_v<_Cont>);\n      static_assert(is_class_v<_Cont> || is_union_v<_Cont>);\n\n      using __detail::_To;\n      using views::__adaptor::_Partial;\n      return _Partial<_To<_Cont>, decay_t<_Args>...>{0, std::forward<_Args>(__args)...};\n    }\n\n/// @cond undocumented\nnamespace __detail\n{\n  template<template<typename...> typename _Cont>\n    struct _To2\n    {\n      template<typename _Range, typename... _Args>\n\trequires requires { ranges::to<_Cont>(std::declval<_Range>(),\n\t\t\t\t\t      std::declval<_Args>()...); }\n\tconstexpr auto\n\toperator()(_Range&& __r, _Args&&... __args) const\n\t{\n\t  return ranges::to<_Cont>(std::forward<_Range>(__r),\n\t\t\t\t   std::forward<_Args>(__args)...);\n\t}\n    };\n} // namespace __detail\n/// @endcond\n\n  /// ranges::to adaptor for converting a range to a deduced container type.\n  /**\n   * @tparam _Cont A container template.\n   * @param __args... Arguments to pass to the container constructor.\n   * @since C++23\n   *\n   * This range adaptor returns a range adaptor closure object that converts\n   * a range to a specialization of the `_Cont` class template. The specific\n   * specialization of `_Cont` to be used is deduced automatically.\n   *\n   * For example, `some_view | std::ranges::to<std::vector>(Alloc<int>{})`\n   * will convert the view to `std::vector<T, Alloc<T>>`, where `T` is the\n   * view's value type, i.e. `std::ranges::range_value_t<decltype(some_view)>`.\n   *\n   * Additional constructor arguments for the container can be supplied, e.g.\n   * `r | std::ranges::to<std::vector>(an_allocator)`.\n   */\n  template<template<typename...> typename _Cont, typename... _Args>\n    constexpr auto\n    to [[nodiscard]] (_Args&&... __args)\n    {\n      using __detail::_To2;\n      using views::__adaptor::_Partial;\n      return _Partial<_To2<_Cont>, decay_t<_Args>...>{0, std::forward<_Args>(__args)...};\n    }\n\n} // namespace ranges\n#endif // __cpp_lib_ranges_to_container\n\n#if __cpp_lib_ranges_concat // C++ >= C++26\nnamespace ranges\n{\n  namespace __detail\n  {\n    template<typename... _Rs>\n      using __concat_reference_t = common_reference_t<range_reference_t<_Rs>...>;\n\n    template<typename... _Rs>\n      using __concat_value_t = common_type_t<range_value_t<_Rs>...>;\n\n    template<typename... _Rs>\n      using __concat_rvalue_reference_t\n\t= common_reference_t<range_rvalue_reference_t<_Rs>...>;\n\n    template<typename _Ref, typename _RRef, typename _It>\n      concept __concat_indirectly_readable_impl = requires(const _It __it) {\n\t{ *__it } -> convertible_to<_Ref>;\n\t{ ranges::iter_move(__it) } -> convertible_to<_RRef>;\n      };\n\n    template<typename... _Rs>\n      concept __concat_indirectly_readable\n\t= common_reference_with<__concat_reference_t<_Rs...>&&, __concat_value_t<_Rs...>&>\n\t  && common_reference_with<__concat_reference_t<_Rs...>&&,\n\t\t\t\t   __concat_rvalue_reference_t<_Rs...>&&>\n\t  && common_reference_with<__concat_rvalue_reference_t<_Rs...>&&,\n\t\t\t\t   __concat_value_t<_Rs...> const&>\n\t  && (__concat_indirectly_readable_impl<__concat_reference_t<_Rs...>,\n\t\t\t\t\t\t__concat_rvalue_reference_t<_Rs...>,\n\t\t\t\t\t\titerator_t<_Rs>>\n\t      && ...);\n\n    template<typename... _Rs>\n      concept __concatable = requires {\n\ttypename __concat_reference_t<_Rs...>;\n\ttypename __concat_value_t<_Rs...>;\n\ttypename __concat_rvalue_reference_t<_Rs...>;\n      } && __concat_indirectly_readable<_Rs...>;\n\n    template<bool _Const, typename _Range, typename... _Rs>\n      struct __all_but_last_common\n      {\n\tstatic inline constexpr bool value\n\t  = requires { requires (common_range<__maybe_const_t<_Const, _Range>>\n\t\t\t\t && __all_but_last_common<_Const, _Rs...>::value); };\n      };\n\n    template<bool _Const, typename _Range>\n      struct __all_but_last_common<_Const, _Range>\n      { static inline constexpr bool value = true; };\n\n    template<bool _Const, typename... _Rs>\n      concept __concat_is_random_access = __all_random_access<_Const, _Rs...>\n\t&& __all_but_last_common<_Const, _Rs...>::value;\n\n    template<bool _Const, typename... _Rs>\n      concept __concat_is_bidirectional = __all_bidirectional<_Const, _Rs...>\n\t&& __all_but_last_common<_Const, _Rs...>::value;\n\n    template<typename _Range, typename... _Rs>\n      struct __all_but_first_sized\n      { static inline constexpr bool value = (sized_range<_Rs> && ...); };\n  } // namespace __detail\n\n  template<input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && __detail::__concatable<_Vs...>\n  class concat_view : public view_interface<concat_view<_Vs...>>\n  {\n    tuple<_Vs...> _M_views;\n\n    template<bool _Const> class _Iterator;\n\n  public:\n    constexpr concat_view() = default;\n\n    constexpr explicit\n    concat_view(_Vs... __views)\n    : _M_views(std::move(__views)...)\n    { }\n\n    constexpr _Iterator<false>\n    begin() requires (!(__detail::__simple_view<_Vs> && ...))\n    {\n      _Iterator<false> __it(this, in_place_index<0>, ranges::begin(std::get<0>(_M_views)));\n      __it.template _M_satisfy<0>();\n      return __it;\n    }\n\n    constexpr _Iterator<true>\n    begin() const requires (range<const _Vs> && ...) && __detail::__concatable<const _Vs...>\n    {\n      _Iterator<true> __it(this, in_place_index<0>, ranges::begin(std::get<0>(_M_views)));\n      __it.template _M_satisfy<0>();\n      return __it;\n    }\n\n    constexpr auto\n    end() requires (!(__detail::__simple_view<_Vs> && ...))\n    {\n      constexpr auto __n = sizeof...(_Vs);\n      if constexpr (__detail::__all_forward<false, _Vs...>\n\t\t    && common_range<_Vs...[__n - 1]>)\n\treturn _Iterator<false>(this, in_place_index<__n - 1>,\n\t\t\t\tranges::end(std::get<__n - 1>(_M_views)));\n      else\n\treturn default_sentinel;\n    }\n\n    constexpr auto\n    end() const requires (range<const _Vs> && ...) && __detail::__concatable<const _Vs...>\n    {\n      constexpr auto __n = sizeof...(_Vs);\n      if constexpr (__detail::__all_forward<true, _Vs...>\n\t\t    && common_range<const _Vs...[__n - 1]>)\n\treturn _Iterator<true>(this, in_place_index<__n - 1>,\n\t\t\t       ranges::end(std::get<__n - 1>(_M_views)));\n      else\n\treturn default_sentinel;\n    }\n\n    constexpr auto\n    size() requires (sized_range<_Vs>&&...)\n    {\n      return std::apply([](auto... __sizes) {\n\tusing _CT = __detail::__make_unsigned_like_t<common_type_t<decltype(__sizes)...>>;\n\treturn (_CT(__sizes) + ...);\n      }, __detail::__tuple_transform(ranges::size, _M_views));\n    }\n\n    constexpr auto\n    size() const requires (sized_range<const _Vs>&&...)\n    {\n      return std::apply([](auto... __sizes) {\n\tusing _CT = __detail::__make_unsigned_like_t<common_type_t<decltype(__sizes)...>>;\n\treturn (_CT(__sizes) + ...);\n      }, __detail::__tuple_transform(ranges::size, _M_views));\n    }\n  };\n\n  template<typename... _Rs>\n    concat_view(_Rs&&...) -> concat_view<views::all_t<_Rs>...>;\n\n  namespace __detail\n  {\n    template<bool _Const, typename... _Vs>\n      struct __concat_view_iter_cat\n      { };\n\n    template<bool _Const, typename... _Vs>\n      requires __detail::__all_forward<_Const, _Vs...>\n      struct __concat_view_iter_cat<_Const, _Vs...>\n      {\n\tstatic auto\n\t_S_iter_cat()\n\t{\n\t  if constexpr (!is_reference_v<__concat_reference_t<__maybe_const_t<_Const, _Vs>...>>)\n\t    return input_iterator_tag{};\n\t  else\n\t    return []<typename... _Cats>(_Cats... __cats) {\n\t      if constexpr ((derived_from<_Cats, random_access_iterator_tag> && ...)\n\t\t\t    && __concat_is_random_access<_Const, _Vs...>)\n\t\treturn random_access_iterator_tag{};\n\t      else if constexpr ((derived_from<_Cats, bidirectional_iterator_tag> && ...)\n\t\t\t\t && __concat_is_bidirectional<_Const, _Vs...>)\n\t\treturn bidirectional_iterator_tag{};\n\t      else if constexpr ((derived_from<_Cats, forward_iterator_tag> && ...))\n\t\treturn forward_iterator_tag{};\n\t      else\n\t\treturn input_iterator_tag{};\n\t    }(typename iterator_traits<iterator_t<__maybe_const_t<_Const, _Vs>>>\n\t      ::iterator_category{}...);\n\t}\n      };\n  }\n\n  template<input_range... _Vs>\n    requires (view<_Vs> && ...) && (sizeof...(_Vs) > 0) && __detail::__concatable<_Vs...>\n  template<bool _Const>\n  class concat_view<_Vs...>::_Iterator\n  : public __detail::__concat_view_iter_cat<_Const, _Vs...>\n  {\n    static auto\n    _S_iter_concept()\n    {\n      if constexpr (__detail::__concat_is_random_access<_Const, _Vs...>)\n\treturn random_access_iterator_tag{};\n      else if constexpr (__detail::__concat_is_bidirectional<_Const, _Vs...>)\n\treturn bidirectional_iterator_tag{};\n      else if constexpr (__detail::__all_forward<_Const, _Vs...>)\n\treturn forward_iterator_tag{};\n      else\n\treturn input_iterator_tag{};\n    }\n\n    friend concat_view;\n    friend _Iterator<!_Const>;\n\n  public:\n    // iterator_category defined in __concat_view_iter_cat\n    using iterator_concept = decltype(_S_iter_concept());\n    using value_type = __detail::__concat_value_t<__maybe_const_t<_Const, _Vs>...>;\n    using difference_type = common_type_t<range_difference_t<__maybe_const_t<_Const, _Vs>>...>;\n\n  private:\n    using __base_iter = variant<iterator_t<__maybe_const_t<_Const, _Vs>>...>;\n\n    __maybe_const_t<_Const, concat_view>* _M_parent = nullptr;\n    __base_iter _M_it;\n\n    template<size_t _Nm>\n      constexpr void\n      _M_satisfy()\n      {\n\tif constexpr (_Nm < (sizeof...(_Vs) - 1))\n\t  {\n\t    if (std::get<_Nm>(_M_it) == ranges::end(std::get<_Nm>(_M_parent->_M_views)))\n\t      {\n\t\t_M_it.template emplace<_Nm + 1>(ranges::begin\n\t\t\t\t\t\t(std::get<_Nm + 1>(_M_parent->_M_views)));\n\t\t_M_satisfy<_Nm + 1>();\n\t      }\n\t  }\n      }\n\n    template<size_t _Nm>\n      constexpr void\n      _M_prev()\n      {\n\tif constexpr (_Nm == 0)\n\t  --std::get<0>(_M_it);\n\telse\n\t  {\n\t    if (std::get<_Nm>(_M_it) == ranges::begin(std::get<_Nm>(_M_parent->_M_views)))\n\t      {\n\t\t_M_it.template emplace<_Nm - 1>(ranges::end\n\t\t\t\t\t\t(std::get<_Nm - 1>(_M_parent->_M_views)));\n\t\t_M_prev<_Nm - 1>();\n\t      }\n\t    else\n\t      --std::get<_Nm>(_M_it);\n\t  }\n      }\n\n    template<size_t _Nm>\n      constexpr void\n      _M_advance_fwd(difference_type __offset, difference_type __steps)\n      {\n\tusing _Dt = iter_difference_t<variant_alternative_t<_Nm, __base_iter>>;\n\tif constexpr (_Nm == sizeof...(_Vs) - 1)\n\t  std::get<_Nm>(_M_it) += static_cast<_Dt>(__steps);\n\telse\n\t  {\n\t    auto __n_size = ranges::distance(std::get<_Nm>(_M_parent->_M_views));\n\t    if (__offset + __steps < __n_size)\n\t\tstd::get<_Nm>(_M_it) += static_cast<_Dt>(__steps);\n\t    else\n\t      {\n\t\t_M_it.template emplace<_Nm + 1>(ranges::begin\n\t\t\t\t\t\t(std::get<_Nm + 1>(_M_parent->_M_views)));\n\t\t_M_advance_fwd<_Nm + 1>(0, __offset + __steps - __n_size);\n\t      }\n\t  }\n      }\n\n    template<size_t _Nm>\n      constexpr void\n      _M_advance_bwd(difference_type __offset, difference_type __steps)\n      {\n\tusing _Dt = iter_difference_t<variant_alternative_t<_Nm, __base_iter>>;\n\tif constexpr (_Nm == 0)\n\t  std::get<_Nm>(_M_it) -= static_cast<_Dt>(__steps);\n\telse {\n\t    if (__offset >= __steps)\n\t      std::get<_Nm>(_M_it) -= static_cast<_Dt>(__steps);\n\t    else\n\t      {\n\t\tauto __prev_size = ranges::distance(std::get<_Nm - 1>(_M_parent->_M_views));\n\t\t_M_it.template emplace<_Nm - 1>(ranges::end\n\t\t\t\t\t\t(std::get<_Nm - 1>(_M_parent->_M_views)));\n\t\t_M_advance_bwd<_Nm - 1>(__prev_size, __steps - __offset);\n\t      }\n\t}\n      }\n\n    // Invoke the function object __f, which has a call operator with a size_t\n    // template parameter (corresponding to an index into the pack of views),\n    // using the runtime value of __index as the template argument.\n    template<typename _Fp>\n      static constexpr auto\n      _S_invoke_with_runtime_index(_Fp&& __f, size_t __index)\n      {\n\treturn [&__f, __index]<size_t _Idx>(this auto&& __self) {\n\t  if (_Idx == __index)\n\t    return __f.template operator()<_Idx>();\n\t  if constexpr (_Idx + 1 < sizeof...(_Vs))\n\t    return __self.template operator()<_Idx + 1>();\n\t  __builtin_unreachable();\n\t}.template operator()<0>();\n      }\n\n    template<typename _Fp>\n      constexpr auto\n      _M_invoke_with_runtime_index(_Fp&& __f)\n      { return _S_invoke_with_runtime_index(std::forward<_Fp>(__f), _M_it.index()); }\n\n    template<typename... _Args>\n      explicit constexpr\n      _Iterator(__maybe_const_t<_Const, concat_view>* __parent, _Args&&... __args)\n\trequires constructible_from<__base_iter, _Args&&...>\n      : _M_parent(__parent), _M_it(std::forward<_Args>(__args)...)\n      { }\n\n  public:\n    _Iterator() = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __it)\n      requires _Const && (convertible_to<iterator_t<_Vs>, iterator_t<const _Vs>> && ...)\n    : _M_parent(__it._M_parent),\n      _M_it(_S_invoke_with_runtime_index([this, &__it]<size_t _Idx>() {\n\t      return __base_iter(in_place_index<_Idx>,\n\t\t\t\t std::get<_Idx>(std::move(__it._M_it)));\n\t    }, __it._M_it.index()))\n    { }\n\n    constexpr decltype(auto)\n    operator*() const\n    {\n      __glibcxx_assert(!_M_it.valueless_by_exception());\n      using reference = __detail::__concat_reference_t<__maybe_const_t<_Const, _Vs>...>;\n      return std::visit([](auto&& __it) -> reference { return *__it; }, _M_it);\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      _M_invoke_with_runtime_index([this]<size_t _Idx>() {\n\t++std::get<_Idx>(_M_it);\n\t_M_satisfy<_Idx>();\n      });\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    constexpr _Iterator\n    operator++(int)\n      requires __detail::__all_forward<_Const, _Vs...>\n    {\n      auto __tmp = *this;\n      ++*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator--()\n      requires __detail::__concat_is_bidirectional<_Const, _Vs...>\n    {\n      __glibcxx_assert(!_M_it.valueless_by_exception());\n      _M_invoke_with_runtime_index([this]<size_t _Idx>() {\n\t_M_prev<_Idx>();\n      });\n      return *this;\n    }\n\n    constexpr _Iterator\n    operator--(int)\n      requires __detail::__concat_is_bidirectional<_Const, _Vs...>\n    {\n      auto __tmp = *this;\n      --*this;\n      return __tmp;\n    }\n\n    constexpr _Iterator&\n    operator+=(difference_type __n)\n      requires __detail::__concat_is_random_access<_Const, _Vs...>\n    {\n      __glibcxx_assert(!_M_it.valueless_by_exception());\n      _M_invoke_with_runtime_index([this, __n]<size_t _Idx>() {\n\tauto __begin = ranges::begin(std::get<_Idx>(_M_parent->_M_views));\n\tif (__n > 0)\n\t  _M_advance_fwd<_Idx>(std::get<_Idx>(_M_it) - __begin, __n);\n\telse if (__n < 0)\n\t  _M_advance_bwd<_Idx>(std::get<_Idx>(_M_it) - __begin, -__n);\n      });\n      return *this;\n    }\n\n    constexpr _Iterator&\n    operator-=(difference_type __n)\n      requires __detail::__concat_is_random_access<_Const, _Vs...>\n    {\n      *this += -__n;\n      return *this;\n    }\n\n    constexpr decltype(auto)\n    operator[](difference_type __n) const\n      requires __detail::__concat_is_random_access<_Const, _Vs...>\n    { return *((*this) + __n); }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Iterator& __y)\n      requires (equality_comparable<iterator_t<__maybe_const_t<_Const, _Vs>>> && ...)\n    {\n      __glibcxx_assert(!__x._M_it.valueless_by_exception());\n      __glibcxx_assert(!__y._M_it.valueless_by_exception());\n      return __x._M_it == __y._M_it;\n    }\n\n    friend constexpr bool\n    operator==(const _Iterator& __it, default_sentinel_t)\n    {\n      __glibcxx_assert(!__it._M_it.valueless_by_exception());\n      constexpr auto __last_idx = sizeof...(_Vs) - 1;\n      return (__it._M_it.index() == __last_idx\n\t      && (std::get<__last_idx>(__it._M_it)\n\t\t  == ranges::end(std::get<__last_idx>(__it._M_parent->_M_views))));\n    }\n\n    friend constexpr bool\n    operator<(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    { return __x._M_it < __y._M_it; }\n\n    friend constexpr bool\n    operator>(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    { return __x._M_it > __y._M_it; }\n\n    friend constexpr bool\n    operator<=(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    { return __x._M_it <= __y._M_it; }\n\n    friend constexpr bool\n    operator>=(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__all_random_access<_Const, _Vs...>\n    { return __x._M_it >= __y._M_it; }\n\n    friend constexpr auto\n    operator<=>(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__all_random_access<_Const, _Vs...>\n\t&& (three_way_comparable<iterator_t<__maybe_const_t<_Const, _Vs>>> && ...)\n    { return __x._M_it <=> __y._M_it; }\n\n    friend constexpr _Iterator\n    operator+(const _Iterator& __it, difference_type __n)\n      requires __detail::__concat_is_random_access<_Const, _Vs...>\n    { return auto(__it) += __n; }\n\n    friend constexpr _Iterator\n    operator+(difference_type __n, const _Iterator& __it)\n      requires __detail::__concat_is_random_access<_Const, _Vs...>\n    { return __it + __n; }\n\n    friend constexpr _Iterator\n    operator-(const _Iterator& __it, difference_type __n)\n      requires __detail::__concat_is_random_access<_Const, _Vs...>\n    { return auto(__it) -= __n; }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const _Iterator& __y)\n      requires __detail::__concat_is_random_access<_Const, _Vs...>\n    {\n      return _S_invoke_with_runtime_index([&]<size_t _Ix>() -> difference_type {\n        return _S_invoke_with_runtime_index([&]<size_t _Iy>() -> difference_type {\n\t  if constexpr (_Ix > _Iy)\n\t    {\n\t      auto __dy = ranges::distance(std::get<_Iy>(__y._M_it),\n\t\t\t\t\t   ranges::end(std::get<_Iy>(__y._M_parent\n\t\t\t\t\t\t\t\t     ->_M_views)));\n\t      auto __dx = ranges::distance(ranges::begin(std::get<_Ix>(__x._M_parent\n\t\t\t\t\t\t\t\t       ->_M_views)),\n\t\t\t\t\t   std::get<_Ix>(__x._M_it));\n\t      difference_type __s = 0;\n\t      [&]<size_t _Idx = _Iy + 1>(this auto&& __self) {\n\t        if constexpr (_Idx < _Ix)\n\t\t  {\n\t\t    __s += ranges::size(std::get<_Idx>(__x._M_parent->_M_views));\n\t\t    __self.template operator()<_Idx + 1>();\n\t\t  }\n\t      }();\n\t      return __dy + __s + __dx;\n\t    }\n\t  else if constexpr (_Ix < _Iy)\n\t    return -(__y - __x);\n\t  else\n\t    return std::get<_Ix>(__x._M_it) - std::get<_Iy>(__y._M_it);\n\t}, __y._M_it.index());\n      }, __x._M_it.index());\n    }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, default_sentinel_t)\n      requires (sized_sentinel_for<sentinel_t<__maybe_const_t<_Const, _Vs>>,\n\t\t\t\t   iterator_t<__maybe_const_t<_Const, _Vs>>> && ...)\n\t&& __detail::__all_but_first_sized<__maybe_const_t<_Const, _Vs>...>::value\n    {\n      return _S_invoke_with_runtime_index([&]<size_t _Ix>() -> difference_type {\n\tauto __dx = ranges::distance(std::get<_Ix>(__x._M_it),\n\t\t\t\t     ranges::end(std::get<_Ix>(__x._M_parent->_M_views)));\n\tdifference_type __s = 0;\n\t[&]<size_t _Idx = _Ix + 1>(this auto&& __self) {\n\t  if constexpr (_Idx < sizeof...(_Vs))\n\t    {\n\t      __s += ranges::size(std::get<_Idx>(__x._M_parent->_M_views));\n\t      __self.template operator()<_Idx + 1>();\n\t    }\n\t}();\n\treturn -(__dx + __s);\n      }, __x._M_it.index());\n    }\n\n    friend constexpr difference_type\n    operator-(default_sentinel_t, const _Iterator& __x)\n      requires (sized_sentinel_for<sentinel_t<__maybe_const_t<_Const, _Vs>>,\n\t\t\t\t   iterator_t<__maybe_const_t<_Const, _Vs>>> && ...)\n\t&& __detail::__all_but_first_sized<__maybe_const_t<_Const, _Vs>...>::value\n    { return -(__x - default_sentinel); }\n\n    friend constexpr decltype(auto)\n    iter_move(const _Iterator& __it)\n    {\n      using _Res = __detail::__concat_rvalue_reference_t<__maybe_const_t<_Const, _Vs>...>;\n      return std::visit([](const auto& __i) -> _Res {\n\treturn ranges::iter_move(__i);\n      }, __it._M_it);\n    }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __x, const _Iterator& __y)\n      requires swappable_with<iter_reference_t<_Iterator>, iter_reference_t<_Iterator>>\n\t&& (... && indirectly_swappable<iterator_t<__maybe_const_t<_Const, _Vs>>>)\n    {\n      std::visit([&]<typename _Tp, typename _Up>(const _Tp& __it1, const _Up& __it2) {\n\tif constexpr (is_same_v<_Tp, _Up>)\n\t  ranges::iter_swap(__it1, __it2);\n\telse\n\t  ranges::swap(*__it1, *__it2);\n      }, __x._M_it, __y._M_it);\n    }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename... _Ts>\n\tconcept __can_concat_view = requires { concat_view(std::declval<_Ts>()...); };\n    }\n\n    struct _Concat\n    {\n      template<typename... _Ts>\n\trequires __detail::__can_concat_view<_Ts...>\n      constexpr auto\n      operator() [[nodiscard]] (_Ts&&... __ts) const\n      { return concat_view(std::forward<_Ts>(__ts)...); }\n\n      template<input_range _Range>\n      constexpr auto\n      operator() [[nodiscard]] (_Range&& __t) const\n      { return views::all(std::forward<_Range>(__t)); }\n    };\n\n    inline constexpr _Concat concat;\n  }\n\n} // namespace ranges\n#endif // __cpp_lib_ranges_concat\n\n#if __cpp_lib_ranges_cache_latest // C++ >= 26\nnamespace ranges\n{\n  template<input_range _Vp>\n    requires view<_Vp>\n  class cache_latest_view : public view_interface<cache_latest_view<_Vp>>\n  {\n    _Vp _M_base = _Vp();\n\n    using __cache_t = __conditional_t<is_reference_v<range_reference_t<_Vp>>,\n\t\t\t\t      add_pointer_t<range_reference_t<_Vp>>,\n\t\t\t\t      range_reference_t<_Vp>>;\n    __detail::__non_propagating_cache<__cache_t> _M_cache;\n\n    class _Iterator;\n    class _Sentinel;\n\n  public:\n    cache_latest_view() requires default_initializable<_Vp> = default;\n\n    constexpr explicit\n    cache_latest_view(_Vp __base)\n    : _M_base(std::move(__base))\n    { }\n\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin()\n    { return _Iterator(*this); }\n\n    constexpr auto\n    end()\n    { return _Sentinel(*this); }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    { return ranges::size(_M_base); }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    { return ranges::size(_M_base); }\n  };\n\n  template<typename _Range>\n    cache_latest_view(_Range&&) -> cache_latest_view<views::all_t<_Range>>;\n\n  template<input_range _Vp>\n    requires view<_Vp>\n  class cache_latest_view<_Vp>::_Iterator\n  {\n    cache_latest_view* _M_parent;\n    iterator_t<_Vp> _M_current;\n\n    constexpr explicit\n    _Iterator(cache_latest_view& __parent)\n    : _M_parent(std::__addressof(__parent)),\n      _M_current(ranges::begin(__parent._M_base))\n    { }\n\n    friend class cache_latest_view;\n\n  public:\n    using difference_type = range_difference_t<_Vp>;\n    using value_type = range_value_t<_Vp>;\n    using iterator_concept = input_iterator_tag;\n\n    _Iterator(_Iterator&&) = default;\n\n    _Iterator&\n    operator=(_Iterator&&) = default;\n\n    constexpr iterator_t<_Vp>\n    base() &&\n    { return std::move(_M_current); }\n\n    constexpr const iterator_t<_Vp>&\n    base() const & noexcept\n    { return _M_current; }\n\n    constexpr range_reference_t<_Vp>&\n    operator*() const\n    {\n      if constexpr (is_reference_v<range_reference_t<_Vp>>)\n\t{\n\t  if (!_M_parent->_M_cache)\n\t    _M_parent->_M_cache = std::__addressof(__detail::__as_lvalue(*_M_current));\n\t  return **_M_parent->_M_cache;\n\t}\n      else\n\t{\n\t  if (!_M_parent->_M_cache)\n\t    _M_parent->_M_cache._M_emplace_deref(_M_current);\n\t  return *_M_parent->_M_cache;\n\t}\n    }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      _M_parent->_M_cache._M_reset();\n      ++_M_current;\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    friend constexpr range_rvalue_reference_t<_Vp>\n    iter_move(const _Iterator& __i)\n      noexcept(noexcept(ranges::iter_move(__i._M_current)))\n    { return ranges::iter_move(__i._M_current); }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __x, const _Iterator& __y)\n      noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n      requires indirectly_swappable<iterator_t<_Vp>>\n    { ranges::iter_swap(__x._M_current, __y._M_current); }\n  };\n\n  template<input_range _Vp>\n    requires view<_Vp>\n  class cache_latest_view<_Vp>::_Sentinel\n  {\n    sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();\n\n    constexpr explicit\n    _Sentinel(cache_latest_view& __parent)\n    : _M_end(ranges::end(__parent._M_base))\n    { }\n\n    friend class cache_latest_view;\n\n  public:\n    _Sentinel() = default;\n\n    constexpr sentinel_t<_Vp>\n    base() const\n    { return _M_end; }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const _Sentinel& __y)\n    { return __x._M_current == __y._M_end; }\n\n    friend constexpr range_difference_t<_Vp>\n    operator-(const _Iterator& __x, const _Sentinel& __y)\n      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    { return __x._M_current - __y._M_end; }\n\n    friend constexpr range_difference_t<_Vp>\n    operator-(const _Sentinel& __x, const _Iterator& __y)\n      requires sized_sentinel_for<sentinel_t<_Vp>, iterator_t<_Vp>>\n    { return __x._M_end - __y._M_current; }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Tp>\n\tconcept __can_cache_latest = requires { cache_latest_view(std::declval<_Tp>()); };\n    }\n\n    struct _CacheLatest : __adaptor::_RangeAdaptorClosure<_CacheLatest>\n    {\n      template<viewable_range _Range>\n\trequires __detail::__can_cache_latest<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\t{ return cache_latest_view(std::forward<_Range>(__r)); }\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n    inline constexpr _CacheLatest cache_latest;\n  }\n} // namespace ranges\n#endif // __cpp_lib_ranges_cache_latest\n\n#if __cpp_lib_ranges_to_input // C++ >= 26\nnamespace ranges\n{\n  template<input_range _Vp>\n    requires view<_Vp>\n  class to_input_view : public view_interface<to_input_view<_Vp>>\n  {\n    _Vp _M_base = _Vp();\n\n    template<bool _Const>\n    class _Iterator;\n\n  public:\n    to_input_view() requires default_initializable<_Vp> = default;\n\n    constexpr explicit\n    to_input_view(_Vp __base)\n    : _M_base(std::move(__base))\n    { }\n\n    constexpr _Vp\n    base() const & requires copy_constructible<_Vp>\n    { return _M_base; }\n\n    constexpr _Vp\n    base() &&\n    { return std::move(_M_base); }\n\n    constexpr auto\n    begin() requires (!__detail::__simple_view<_Vp>)\n    { return _Iterator<false>(ranges::begin(_M_base)); }\n\n    constexpr auto\n    begin() const requires range<const _Vp>\n    { return _Iterator<true>(ranges::begin(_M_base)); }\n\n    constexpr auto\n    end() requires (!__detail::__simple_view<_Vp>)\n    { return ranges::end(_M_base); }\n\n    constexpr auto\n    end() const requires range<const _Vp>\n    { return ranges::end(_M_base); }\n\n    constexpr auto\n    size() requires sized_range<_Vp>\n    { return ranges::size(_M_base); }\n\n    constexpr auto\n    size() const requires sized_range<const _Vp>\n    { return ranges::size(_M_base); }\n  };\n\n  template<typename _Range>\n    to_input_view(_Range&&) -> to_input_view<views::all_t<_Range>>;\n\n  template<input_range _Vp>\n    requires view<_Vp>\n  template<bool _Const>\n  class to_input_view<_Vp>::_Iterator\n  {\n    using _Base = __maybe_const_t<_Const, _Vp>;\n\n    iterator_t<_Base> _M_current = iterator_t<_Base>();\n\n    constexpr explicit\n    _Iterator(iterator_t<_Base> __current)\n    : _M_current(std::move(__current))\n    { }\n\n    friend to_input_view;\n    friend _Iterator<!_Const>;\n\n  public:\n    using difference_type = range_difference_t<_Base>;\n    using value_type = range_value_t<_Base>;\n    using iterator_concept = input_iterator_tag;\n\n    _Iterator() requires default_initializable<iterator_t<_Base>> = default;\n\n    _Iterator(_Iterator&&) = default;\n    _Iterator& operator=(_Iterator&&) = default;\n\n    constexpr\n    _Iterator(_Iterator<!_Const> __i)\n      requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n    : _M_current(std::move(__i._M_current))\n    { }\n\n    constexpr iterator_t<_Base>\n    base() &&\n    { return std::move(_M_current); }\n\n    constexpr const iterator_t<_Base>&\n    base() const & noexcept\n    { return _M_current; }\n\n    constexpr decltype(auto)\n    operator*() const\n    { return *_M_current; }\n\n    constexpr _Iterator&\n    operator++()\n    {\n      ++_M_current;\n      return *this;\n    }\n\n    constexpr void\n    operator++(int)\n    { ++*this; }\n\n    friend constexpr bool\n    operator==(const _Iterator& __x, const sentinel_t<_Base>& __y)\n    { return __x._M_current == __y; }\n\n    friend constexpr difference_type\n    operator-(const sentinel_t<_Base>& __y, const _Iterator& __x)\n      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n    { return __y - __x._M_current; }\n\n    friend constexpr difference_type\n    operator-(const _Iterator& __x, const sentinel_t<_Base>& __y)\n      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n    { return __x._M_current - __y; }\n\n    friend constexpr range_rvalue_reference_t<_Base>\n    iter_move(const _Iterator& __i)\n      noexcept(noexcept(ranges::iter_move(__i._M_current)))\n    { return ranges::iter_move(__i._M_current); }\n\n    friend constexpr void\n    iter_swap(const _Iterator& __x, const _Iterator& __y)\n      noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n      requires indirectly_swappable<iterator_t<_Base>>\n    { ranges::iter_swap(__x._M_current, __y._M_current); }\n  };\n\n  namespace views\n  {\n    namespace __detail\n    {\n      template<typename _Tp>\n\tconcept __can_to_input = requires { to_input_view(std::declval<_Tp>()); };\n    }\n\n    struct _ToInput : __adaptor::_RangeAdaptorClosure<_ToInput>\n    {\n      template<viewable_range _Range>\n\trequires __detail::__can_to_input<_Range>\n\tconstexpr auto\n\toperator() [[nodiscard]] (_Range&& __r) const\n\t{\n\t  if constexpr (input_range<_Range>\n\t\t\t&& !common_range<_Range>\n\t\t\t&& !forward_range<_Range>)\n\t    return views::all(std::forward<_Range>(__r));\n\t  else\n\t    return to_input_view(std::forward<_Range>(__r));\n\t}\n\n      static constexpr bool _S_has_simple_call_op = true;\n    };\n\n    inline constexpr _ToInput to_input;\n  }\n} // namespace ranges\n#endif // __cpp_lib_ranges_to_input\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // library concepts\n#endif // C++2a\n#endif /* _GLIBCXX_RANGES */\n"},
                          "roles": ["resultFile"]},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/ranges_base.h"},
                          "sourceLanguage": "cplusplus",
                          "contents": {"text": "// Core concepts and definitions for <ranges> -*- C++ -*-\n\n// Copyright (C) 2019-2025 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/ranges_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{ranges}\n */\n\n#ifndef _GLIBCXX_RANGES_BASE_H\n#define _GLIBCXX_RANGES_BASE_H 1\n\n#ifdef _GLIBCXX_SYSHDR\n#pragma GCC system_header\n#endif\n\n#if __cplusplus > 201703L\n#include <initializer_list>\n#include <bits/stl_iterator.h>\n#include <ext/numeric_traits.h>\n#include <bits/max_size_type.h>\n#include <bits/version.h>\n\n#if __glibcxx_containers_ranges // C++ >= 23\n# include <bits/utility.h> // for tuple_element_t\n#endif\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\" // __int128\n\n#if __glibcxx_algorithm_default_value_type // C++ >= 26\n# define _GLIBCXX26_RANGE_ALGO_DEF_VAL_T(_I, _P) = projected_value_t<_I, _P>\n#else\n# define _GLIBCXX26_RANGE_ALGO_DEF_VAL_T(_I, _P)\n#endif\n\n#ifdef __cpp_lib_concepts\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\nnamespace ranges\n{\n  template<typename>\n    inline constexpr bool disable_sized_range = false;\n\n  template<typename _Tp>\n    inline constexpr bool enable_borrowed_range = false;\n\n  namespace __detail\n  {\n    constexpr __max_size_type\n    __to_unsigned_like(__max_size_type __t) noexcept\n    { return __t; }\n\n    constexpr __max_size_type\n    __to_unsigned_like(__max_diff_type __t) noexcept\n    { return __max_size_type(__t); }\n\n    template<integral _Tp>\n      constexpr auto\n      __to_unsigned_like(_Tp __t) noexcept\n      { return static_cast<make_unsigned_t<_Tp>>(__t); }\n\n#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__\n    constexpr unsigned __int128\n    __to_unsigned_like(__int128 __t) noexcept\n    { return __t; }\n\n    constexpr unsigned __int128\n    __to_unsigned_like(unsigned __int128 __t) noexcept\n    { return __t; }\n#endif\n\n    template<typename _Tp>\n      using __make_unsigned_like_t\n\t= decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));\n\n    // Part of the constraints of ranges::borrowed_range\n    template<typename _Tp>\n      concept __maybe_borrowed_range\n\t= is_lvalue_reference_v<_Tp>\n\t  || enable_borrowed_range<remove_cvref_t<_Tp>>;\n\n  } // namespace __detail\n\n  // Namespace for helpers for the <ranges> customization points.\n  namespace __access\n  {\n    using std::ranges::__detail::__maybe_borrowed_range;\n    using std::__detail::__range_iter_t;\n\n    struct _Begin\n    {\n    private:\n      template<typename _Tp>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n\t    return true;\n\t  else if constexpr (__member_begin<_Tp>)\n\t    return noexcept(__decay_copy(std::declval<_Tp&>().begin()));\n\t  else\n\t    return noexcept(__decay_copy(begin(std::declval<_Tp&>())));\n\t}\n\n    public:\n      template<__maybe_borrowed_range _Tp>\n\trequires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>\n\t  || __adl_begin<_Tp>\n\tconstexpr auto\n\toperator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n\t{\n\t  if constexpr (is_array_v<remove_reference_t<_Tp>>)\n\t    {\n\t      static_assert(is_lvalue_reference_v<_Tp>);\n\t      return __t + 0;\n\t    }\n\t  else if constexpr (__member_begin<_Tp>)\n\t    return __t.begin();\n\t  else\n\t    return begin(__t);\n\t}\n    };\n\n    template<typename _Tp>\n      concept __member_end = requires(_Tp& __t)\n\t{\n\t  { __decay_copy(__t.end()) } -> sentinel_for<__range_iter_t<_Tp>>;\n\t};\n\n    // Poison pill so that unqualified lookup doesn't find std::end.\n    void end() = delete;\n\n    template<typename _Tp>\n      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>\n\t&& requires(_Tp& __t)\n\t{\n\t  { __decay_copy(end(__t)) } -> sentinel_for<__range_iter_t<_Tp>>;\n\t};\n\n    struct _End\n    {\n    private:\n      template<typename _Tp>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n\t    return true;\n\t  else if constexpr (__member_end<_Tp>)\n\t    return noexcept(__decay_copy(std::declval<_Tp&>().end()));\n\t  else\n\t    return noexcept(__decay_copy(end(std::declval<_Tp&>())));\n\t}\n\n    public:\n      template<__maybe_borrowed_range _Tp>\n\trequires is_bounded_array_v<remove_reference_t<_Tp>>\n\t  || __member_end<_Tp> || __adl_end<_Tp>\n\tconstexpr auto\n\toperator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n\t{\n\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n\t    {\n\t      static_assert(is_lvalue_reference_v<_Tp>);\n\t      return __t + extent_v<remove_reference_t<_Tp>>;\n\t    }\n\t  else if constexpr (__member_end<_Tp>)\n\t    return __t.end();\n\t  else\n\t    return end(__t);\n\t}\n    };\n\n    template<typename _Tp>\n      concept __member_rbegin = requires(_Tp& __t)\n\t{\n\t  { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;\n\t};\n\n    void rbegin() = delete;\n\n    template<typename _Tp>\n      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>\n\t&& requires(_Tp& __t)\n\t{\n\t  { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;\n\t};\n\n    template<typename _Tp>\n      concept __reversable = requires(_Tp& __t)\n\t{\n\t  { _Begin{}(__t) } -> bidirectional_iterator;\n\t  { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;\n\t};\n\n    struct _RBegin\n    {\n    private:\n      template<typename _Tp>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (__member_rbegin<_Tp>)\n\t    return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));\n\t  else if constexpr (__adl_rbegin<_Tp>)\n\t    return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));\n\t  else\n\t    {\n\t      if constexpr (noexcept(_End{}(std::declval<_Tp&>())))\n\t\t{\n\t\t  using _It = decltype(_End{}(std::declval<_Tp&>()));\n\t\t  // std::reverse_iterator copy-initializes its member.\n\t\t  return is_nothrow_copy_constructible_v<_It>;\n\t\t}\n\t      else\n\t\treturn false;\n\t    }\n\t}\n\n    public:\n      template<__maybe_borrowed_range _Tp>\n\trequires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>\n\tconstexpr auto\n\toperator()[[nodiscard]](_Tp&& __t) const\n\tnoexcept(_S_noexcept<_Tp&>())\n\t{\n\t  if constexpr (__member_rbegin<_Tp>)\n\t    return __t.rbegin();\n\t  else if constexpr (__adl_rbegin<_Tp>)\n\t    return rbegin(__t);\n\t  else\n\t    return std::make_reverse_iterator(_End{}(__t));\n\t}\n    };\n\n    template<typename _Tp>\n      concept __member_rend = requires(_Tp& __t)\n\t{\n\t  { __decay_copy(__t.rend()) }\n\t    -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;\n\t};\n\n    void rend() = delete;\n\n    template<typename _Tp>\n      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>\n\t&& requires(_Tp& __t)\n\t{\n\t  { __decay_copy(rend(__t)) }\n\t    -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;\n\t};\n\n    struct _REnd\n    {\n    private:\n      template<typename _Tp>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (__member_rend<_Tp>)\n\t    return noexcept(__decay_copy(std::declval<_Tp&>().rend()));\n\t  else if constexpr (__adl_rend<_Tp>)\n\t    return noexcept(__decay_copy(rend(std::declval<_Tp&>())));\n\t  else\n\t    {\n\t      if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))\n\t\t{\n\t\t  using _It = decltype(_Begin{}(std::declval<_Tp&>()));\n\t\t  // std::reverse_iterator copy-initializes its member.\n\t\t  return is_nothrow_copy_constructible_v<_It>;\n\t\t}\n\t      else\n\t\treturn false;\n\t    }\n\t}\n\n    public:\n      template<__maybe_borrowed_range _Tp>\n\trequires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>\n\tconstexpr auto\n\toperator()[[nodiscard]](_Tp&& __t) const\n\tnoexcept(_S_noexcept<_Tp&>())\n\t{\n\t  if constexpr (__member_rend<_Tp>)\n\t    return __t.rend();\n\t  else if constexpr (__adl_rend<_Tp>)\n\t    return rend(__t);\n\t  else\n\t    return std::make_reverse_iterator(_Begin{}(__t));\n\t}\n    };\n\n    template<typename _Tp>\n      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>\n\t&& requires(_Tp& __t)\n\t{\n\t  { __decay_copy(__t.size()) } -> __detail::__is_integer_like;\n\t};\n\n    void size() = delete;\n\n    template<typename _Tp>\n      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>\n\t&& !disable_sized_range<remove_cvref_t<_Tp>>\n\t&& requires(_Tp& __t)\n\t{\n\t  { __decay_copy(size(__t)) } -> __detail::__is_integer_like;\n\t};\n\n    template<typename _Tp>\n      concept __sentinel_size = requires(_Tp& __t)\n\t{\n\t  requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);\n\n\t  { _Begin{}(__t) } -> forward_iterator;\n\n\t  { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;\n\n\t  __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));\n\t};\n\n    struct _Size\n    {\n    private:\n      template<typename _Tp>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n\t    return true;\n\t  else if constexpr (__member_size<_Tp>)\n\t    return noexcept(__decay_copy(std::declval<_Tp&>().size()));\n\t  else if constexpr (__adl_size<_Tp>)\n\t    return noexcept(__decay_copy(size(std::declval<_Tp&>())));\n\t  else if constexpr (__sentinel_size<_Tp>)\n\t    return noexcept(_End{}(std::declval<_Tp&>())\n\t\t\t    - _Begin{}(std::declval<_Tp&>()));\n\t}\n\n    public:\n      template<typename _Tp>\n\trequires is_bounded_array_v<remove_reference_t<_Tp>>\n\t  || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>\n\tconstexpr auto\n\toperator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n\t{\n\t  if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)\n\t    return extent_v<remove_reference_t<_Tp>>;\n\t  else if constexpr (__member_size<_Tp>)\n\t    return __t.size();\n\t  else if constexpr (__adl_size<_Tp>)\n\t    return size(__t);\n\t  else if constexpr (__sentinel_size<_Tp>)\n\t    return __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));\n\t}\n    };\n\n    struct _SSize\n    {\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 3403. Domain of ranges::ssize(E) doesn't match ranges::size(E)\n      template<typename _Tp>\n\trequires requires (_Tp& __t) { _Size{}(__t); }\n\tconstexpr auto\n\toperator()[[nodiscard]](_Tp&& __t) const noexcept(noexcept(_Size{}(__t)))\n\t{\n\t  auto __size = _Size{}(__t);\n\t  using __size_type = decltype(__size);\n\t  // Return the wider of ptrdiff_t and make-signed-like-t<__size_type>.\n\t  if constexpr (integral<__size_type>)\n\t    {\n\t      using __gnu_cxx::__int_traits;\n\t      if constexpr (__int_traits<__size_type>::__digits\n\t\t\t    < __int_traits<ptrdiff_t>::__digits)\n\t\treturn static_cast<ptrdiff_t>(__size);\n\t      else\n\t\treturn static_cast<make_signed_t<__size_type>>(__size);\n\t    }\n#if defined __STRICT_ANSI__ && defined __SIZEOF_INT128__\n\t  // For strict-ansi modes integral<__int128> is false\n\t  else if constexpr (__detail::__is_int128<__size_type>)\n\t    return static_cast<__int128>(__size);\n#endif\n\t  else // Must be one of __max_diff_type or __max_size_type.\n\t    return __detail::__max_diff_type(__size);\n\t}\n    };\n\n    template<typename _Tp>\n      concept __member_empty = requires(_Tp& __t) { bool(__t.empty()); };\n\n    template<typename _Tp>\n      concept __size0_empty = requires(_Tp& __t) { _Size{}(__t) == 0; };\n\n    template<typename _Tp>\n      concept __eq_iter_empty = requires(_Tp& __t)\n\t{\n\t  requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);\n\n\t  { _Begin{}(__t) } -> forward_iterator;\n\n\t  bool(_Begin{}(__t) == _End{}(__t));\n\t};\n\n    struct _Empty\n    {\n    private:\n      template<typename _Tp>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (__member_empty<_Tp>)\n\t    return noexcept(bool(std::declval<_Tp&>().empty()));\n\t  else if constexpr (__size0_empty<_Tp>)\n\t    return noexcept(_Size{}(std::declval<_Tp&>()) == 0);\n\t  else\n\t    return noexcept(bool(_Begin{}(std::declval<_Tp&>())\n\t\t== _End{}(std::declval<_Tp&>())));\n\t}\n\n    public:\n      template<typename _Tp>\n\trequires __member_empty<_Tp> || __size0_empty<_Tp>\n\t  || __eq_iter_empty<_Tp>\n\tconstexpr bool\n\toperator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())\n\t{\n\t  if constexpr (__member_empty<_Tp>)\n\t    return bool(__t.empty());\n\t  else if constexpr (__size0_empty<_Tp>)\n\t    return _Size{}(__t) == 0;\n\t  else\n\t    return bool(_Begin{}(__t) == _End{}(__t));\n\t}\n    };\n\n    template<typename _Tp>\n      concept __pointer_to_object = is_pointer_v<_Tp>\n\t\t\t\t    && is_object_v<remove_pointer_t<_Tp>>;\n\n    template<typename _Tp>\n      concept __member_data = requires(_Tp& __t)\n\t{\n\t  { __decay_copy(__t.data()) } -> __pointer_to_object;\n\t};\n\n    template<typename _Tp>\n      concept __begin_data = contiguous_iterator<__range_iter_t<_Tp>>;\n\n    struct _Data\n    {\n    private:\n      template<typename _Tp>\n\tstatic constexpr bool\n\t_S_noexcept()\n\t{\n\t  if constexpr (__member_data<_Tp>)\n\t    return noexcept(__decay_copy(std::declval<_Tp&>().data()));\n\t  else\n\t    return noexcept(_Begin{}(std::declval<_Tp&>()));\n\t}\n\n    public:\n      template<__maybe_borrowed_range _Tp>\n\trequires __member_data<_Tp> || __begin_data<_Tp>\n\tconstexpr auto\n\toperator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp>())\n\t{\n\t  if constexpr (__member_data<_Tp>)\n\t    return __t.data();\n\t  else\n\t    return std::to_address(_Begin{}(__t));\n\t}\n    };\n\n  } // namespace __access\n\n  inline namespace _Cpo\n  {\n    inline constexpr ranges::__access::_Begin begin{};\n    inline constexpr ranges::__access::_End end{};\n    inline constexpr ranges::__access::_RBegin rbegin{};\n    inline constexpr ranges::__access::_REnd rend{};\n    inline constexpr ranges::__access::_Size size{};\n    inline constexpr ranges::__access::_SSize ssize{};\n    inline constexpr ranges::__access::_Empty empty{};\n    inline constexpr ranges::__access::_Data data{};\n  }\n\n  /// [range.range] The range concept.\n  template<typename _Tp>\n    concept range = requires(_Tp& __t)\n      {\n\tranges::begin(__t);\n\tranges::end(__t);\n      };\n\n  /// [range.range] The borrowed_range concept.\n  template<typename _Tp>\n    concept borrowed_range\n      = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;\n\n  template<typename _Tp>\n    using iterator_t = std::__detail::__range_iter_t<_Tp>;\n\n  template<range _Range>\n    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));\n\n#if __glibcxx_ranges_as_const // >= C++23\n  // const_iterator_t and const_sentinel_t defined below.\n\n  template<range _Range>\n    using range_const_reference_t = iter_const_reference_t<iterator_t<_Range>>;\n#endif\n\n  template<range _Range>\n    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n\n  template<range _Range>\n    using range_value_t = iter_value_t<iterator_t<_Range>>;\n\n  template<range _Range>\n    using range_reference_t = iter_reference_t<iterator_t<_Range>>;\n\n  template<range _Range>\n    using range_rvalue_reference_t\n      = iter_rvalue_reference_t<iterator_t<_Range>>;\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 3860. range_common_reference_t is missing\n  template<range _Range>\n    using range_common_reference_t\n      = iter_common_reference_t<iterator_t<_Range>>;\n\n  /// [range.sized] The sized_range concept.\n  template<typename _Tp>\n    concept sized_range = range<_Tp>\n      && requires(_Tp& __t) { ranges::size(__t); };\n\n  template<sized_range _Range>\n    using range_size_t = decltype(ranges::size(std::declval<_Range&>()));\n\n  template<typename _Derived>\n    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>\n    class view_interface; // defined in <bits/ranges_util.h>\n\n  namespace __detail\n  {\n    template<typename _Tp, typename _Up>\n      requires (!same_as<_Tp, view_interface<_Up>>)\n      void __is_derived_from_view_interface_fn(const _Tp&,\n\t\t\t\t\t       const view_interface<_Up>&); // not defined\n\n    // Returns true iff _Tp has exactly one public base class that's a\n    // specialization of view_interface.\n    template<typename _Tp>\n      concept __is_derived_from_view_interface\n\t= requires (_Tp __t) { __is_derived_from_view_interface_fn(__t, __t); };\n  } // namespace __detail\n\n  /// [range.view] The ranges::view_base type.\n  struct view_base { };\n\n  /// [range.view] The ranges::enable_view boolean.\n  template<typename _Tp>\n    inline constexpr bool enable_view = derived_from<_Tp, view_base>\n      || __detail::__is_derived_from_view_interface<_Tp>;\n\n  /// [range.view] The ranges::view concept.\n  template<typename _Tp>\n    concept view\n      = range<_Tp> && movable<_Tp> && enable_view<_Tp>;\n\n  // [range.refinements]\n\n  /// A range for which ranges::begin returns an output iterator.\n  template<typename _Range, typename _Tp>\n    concept output_range\n      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;\n\n  /// A range for which ranges::begin returns an input iterator.\n  template<typename _Tp>\n    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;\n\n  /// A range for which ranges::begin returns a forward iterator.\n  template<typename _Tp>\n    concept forward_range\n      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;\n\n  /// A range for which ranges::begin returns a bidirectional iterator.\n  template<typename _Tp>\n    concept bidirectional_range\n      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;\n\n  /// A range for which ranges::begin returns a random access iterator.\n  template<typename _Tp>\n    concept random_access_range\n      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;\n\n  /// A range for which ranges::begin returns a contiguous iterator.\n  template<typename _Tp>\n    concept contiguous_range\n      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>\n      && requires(_Tp& __t)\n      {\n\t{ ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;\n      };\n\n  /// A range for which ranges::begin and ranges::end return the same type.\n  template<typename _Tp>\n    concept common_range\n      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n\n#if __glibcxx_ranges_as_const // >= C++23\n  template<typename _Tp>\n    concept constant_range\n      = input_range<_Tp> && std::__detail::__constant_iterator<iterator_t<_Tp>>;\n#endif\n\n  namespace __access\n  {\n#if __glibcxx_ranges_as_const // >= C++23\n    template<input_range _Range>\n      constexpr auto&\n      __possibly_const_range(_Range& __r) noexcept\n      {\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 4027. possibly-const-range should prefer returning const R&\n\tif constexpr (input_range<const _Range>)\n\t  return const_cast<const _Range&>(__r);\n\telse\n\t  return __r;\n      }\n#else\n    // If _To is an lvalue-reference, return const _Tp&, otherwise const _Tp&&.\n    template<typename _To, typename _Tp>\n      constexpr decltype(auto)\n      __as_const(_Tp& __t) noexcept\n      {\n\tstatic_assert(std::is_same_v<_To&, _Tp&>);\n\n\tif constexpr (is_lvalue_reference_v<_To>)\n\t  return const_cast<const _Tp&>(__t);\n\telse\n\t  return static_cast<const _Tp&&>(__t);\n      }\n#endif\n\n    struct _CBegin\n    {\n#if __glibcxx_ranges_as_const // >= C++23\n      template<__maybe_borrowed_range _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(std::make_const_iterator\n\t\t\t  (ranges::begin(__access::__possibly_const_range(__t)))))\n\trequires requires { std::make_const_iterator\n\t\t\t    (ranges::begin(__access::__possibly_const_range(__t))); }\n\t{\n\t  auto& __r = __access::__possibly_const_range(__t);\n\t  return const_iterator<decltype(ranges::begin(__r))>(ranges::begin(__r));\n\t}\n#else\n      template<typename _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __e) const\n\tnoexcept(noexcept(_Begin{}(__access::__as_const<_Tp>(__e))))\n\trequires requires { _Begin{}(__access::__as_const<_Tp>(__e)); }\n\t{\n\t  return _Begin{}(__access::__as_const<_Tp>(__e));\n\t}\n#endif\n    };\n\n    struct _CEnd final\n    {\n#if __glibcxx_ranges_as_const // >= C++23\n      template<__maybe_borrowed_range _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(std::make_const_sentinel\n\t\t\t  (ranges::end(__access::__possibly_const_range(__t)))))\n\trequires requires { std::make_const_sentinel\n\t\t\t    (ranges::end(__access::__possibly_const_range(__t))); }\n\t{\n\t  auto& __r = __access::__possibly_const_range(__t);\n\t  return const_sentinel<decltype(ranges::end(__r))>(ranges::end(__r));\n\t}\n#else\n      template<typename _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __e) const\n\tnoexcept(noexcept(_End{}(__access::__as_const<_Tp>(__e))))\n\trequires requires { _End{}(__access::__as_const<_Tp>(__e)); }\n\t{\n\t  return _End{}(__access::__as_const<_Tp>(__e));\n\t}\n#endif\n    };\n\n    struct _CRBegin\n    {\n#if __glibcxx_ranges_as_const // >= C++23\n      template<__maybe_borrowed_range _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(std::make_const_iterator\n\t\t\t  (ranges::rbegin(__access::__possibly_const_range(__t)))))\n\trequires requires { std::make_const_iterator\n\t\t\t    (ranges::rbegin(__access::__possibly_const_range(__t))); }\n\t{\n\t  auto& __r = __access::__possibly_const_range(__t);\n\t  return const_iterator<decltype(ranges::rbegin(__r))>(ranges::rbegin(__r));\n\t}\n#else\n      template<typename _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __e) const\n\tnoexcept(noexcept(_RBegin{}(__access::__as_const<_Tp>(__e))))\n\trequires requires { _RBegin{}(__access::__as_const<_Tp>(__e)); }\n\t{\n\t  return _RBegin{}(__access::__as_const<_Tp>(__e));\n\t}\n#endif\n    };\n\n    struct _CREnd\n    {\n#if __glibcxx_ranges_as_const // >= C++23\n      template<__maybe_borrowed_range _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(std::make_const_sentinel\n\t\t\t  (ranges::rend(__access::__possibly_const_range(__t)))))\n\trequires requires { std::make_const_sentinel\n\t\t\t    (ranges::rend(__access::__possibly_const_range(__t))); }\n\t{\n\t  auto& __r = __access::__possibly_const_range(__t);\n\t  return const_sentinel<decltype(ranges::rend(__r))>(ranges::rend(__r));\n\t}\n#else\n      template<typename _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __e) const\n\tnoexcept(noexcept(_REnd{}(__access::__as_const<_Tp>(__e))))\n\trequires requires { _REnd{}(__access::__as_const<_Tp>(__e)); }\n\t{\n\t  return _REnd{}(__access::__as_const<_Tp>(__e));\n\t}\n#endif\n    };\n\n    struct _CData\n    {\n#if __glibcxx_ranges_as_const // >= C++23\n      template<__maybe_borrowed_range _Tp>\n\t[[nodiscard]]\n\tconstexpr const auto*\n\toperator()(_Tp&& __t) const\n\tnoexcept(noexcept(ranges::data(__access::__possibly_const_range(__t))))\n\trequires requires { ranges::data(__access::__possibly_const_range(__t)); }\n\t{ return ranges::data(__access::__possibly_const_range(__t)); }\n#else\n      template<typename _Tp>\n\t[[nodiscard]]\n\tconstexpr auto\n\toperator()(_Tp&& __e) const\n\tnoexcept(noexcept(_Data{}(__access::__as_const<_Tp>(__e))))\n\trequires requires { _Data{}(__access::__as_const<_Tp>(__e)); }\n\t{\n\t  return _Data{}(__access::__as_const<_Tp>(__e));\n\t}\n#endif\n    };\n  } // namespace __access\n\n  inline namespace _Cpo\n  {\n    inline constexpr ranges::__access::_CBegin cbegin{};\n    inline constexpr ranges::__access::_CEnd cend{};\n    inline constexpr ranges::__access::_CRBegin crbegin{};\n    inline constexpr ranges::__access::_CREnd crend{};\n    inline constexpr ranges::__access::_CData cdata{};\n  }\n\n#if __glibcxx_ranges_as_const // >= C++23\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 3946. The definition of const_iterator_t should be reworked\n  template<range _Range>\n    using const_iterator_t = decltype(ranges::cbegin(std::declval<_Range&>()));\n\n  template<range _Range>\n    using const_sentinel_t = decltype(ranges::cend(std::declval<_Range&>()));\n#endif\n\n  namespace __detail\n  {\n    template<typename _Tp>\n      inline constexpr bool __is_initializer_list = false;\n\n    template<typename _Tp>\n      inline constexpr bool __is_initializer_list<initializer_list<_Tp>> = true;\n  } // namespace __detail\n\n  /// A range which can be safely converted to a view.\n  template<typename _Tp>\n    concept viewable_range = range<_Tp>\n      && ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>)\n\t  || (!view<remove_cvref_t<_Tp>>\n\t      && (is_lvalue_reference_v<_Tp>\n\t\t  || (movable<remove_reference_t<_Tp>>\n\t\t      && !__detail::__is_initializer_list<remove_cvref_t<_Tp>>))));\n\n  // [range.iter.ops] range iterator operations\n\n  struct __advance_fn final\n  {\n    template<input_or_output_iterator _It>\n      constexpr void\n      operator()(_It& __it, iter_difference_t<_It> __n) const\n      {\n\tif constexpr (random_access_iterator<_It>)\n\t  __it += __n;\n\telse if constexpr (bidirectional_iterator<_It>)\n\t  {\n\t    if (__n > 0)\n\t      {\n\t\tdo\n\t\t  {\n\t\t    ++__it;\n\t\t  }\n\t\twhile (--__n);\n\t      }\n\t    else if (__n < 0)\n\t      {\n\t\tdo\n\t\t  {\n\t\t    --__it;\n\t\t  }\n\t\twhile (++__n);\n\t      }\n\t  }\n\telse\n\t  {\n\t    // cannot decrement a non-bidirectional iterator\n\t    __glibcxx_assert(__n >= 0);\n\t    while (__n-- > 0)\n\t      ++__it;\n\t  }\n      }\n\n    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n      constexpr void\n      operator()(_It& __it, _Sent __bound) const\n      {\n\tif constexpr (assignable_from<_It&, _Sent>)\n\t  __it = std::move(__bound);\n\telse if constexpr (sized_sentinel_for<_Sent, _It>)\n\t  (*this)(__it, __bound - __it);\n\telse\n\t  {\n\t    while (__it != __bound)\n\t      ++__it;\n\t  }\n      }\n\n    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n      constexpr iter_difference_t<_It>\n      operator()(_It& __it, iter_difference_t<_It> __n, _Sent __bound) const\n      {\n\tif constexpr (sized_sentinel_for<_Sent, _It>)\n\t  {\n\t    const auto __diff = __bound - __it;\n\n\t    if (__diff == 0)\n\t      return __n;\n\t    else if (__diff > 0 ? __n >= __diff : __n <= __diff)\n\t      {\n\t\t(*this)(__it, __bound);\n\t\treturn __n - __diff;\n\t      }\n\t    else if (__n != 0) [[likely]]\n\t      {\n\t\t// n and bound must not lead in opposite directions:\n\t\t__glibcxx_assert((__n < 0) == (__diff < 0));\n\n\t\t(*this)(__it, __n);\n\t\treturn 0;\n\t      }\n\t    else\n\t      return 0;\n\t  }\n\telse if (__it == __bound || __n == 0)\n\t  return __n;\n\telse if (__n > 0)\n\t  {\n\t    iter_difference_t<_It> __m = 0;\n\t    do\n\t      {\n\t\t++__it;\n\t\t++__m;\n\t      }\n\t    while (__m != __n && __it != __bound);\n\t    return __n - __m;\n\t  }\n\telse if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)\n\t  {\n\t    iter_difference_t<_It> __m = 0;\n\t    do\n\t      {\n\t\t--__it;\n\t\t--__m;\n\t      }\n\t    while (__m != __n && __it != __bound);\n\t    return __n - __m;\n\t  }\n\telse\n\t  {\n\t    // cannot decrement a non-bidirectional iterator\n\t    __glibcxx_assert(__n >= 0);\n\t    return __n;\n\t  }\n      }\n\n    void operator&() const = delete;\n  };\n\n  inline constexpr __advance_fn advance{};\n\n  struct __distance_fn final\n  {\n    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n    // 3664. LWG 3392 broke std::ranges::distance(a, a+3)\n    template<typename _It, sentinel_for<_It> _Sent>\n      requires (!sized_sentinel_for<_Sent, _It>)\n      constexpr iter_difference_t<_It>\n      operator()[[nodiscard]](_It __first, _Sent __last) const\n      {\n\titer_difference_t<_It> __n = 0;\n\twhile (__first != __last)\n\t  {\n\t    ++__first;\n\t    ++__n;\n\t  }\n\treturn __n;\n      }\n\n    template<typename _It, sized_sentinel_for<decay_t<_It>> _Sent>\n      [[nodiscard]]\n      constexpr iter_difference_t<decay_t<_It>>\n      operator()(_It&& __first, _Sent __last) const\n      { return __last - static_cast<const decay_t<_It>&>(__first); }\n\n    template<range _Range>\n      [[nodiscard]]\n      constexpr range_difference_t<_Range>\n      operator()(_Range&& __r) const\n      {\n\tif constexpr (sized_range<_Range>)\n\t  return static_cast<range_difference_t<_Range>>(ranges::size(__r));\n\telse\n\t  return (*this)(ranges::begin(__r), ranges::end(__r));\n      }\n\n    void operator&() const = delete;\n  };\n\n  inline constexpr __distance_fn distance{};\n\n  struct __next_fn final\n  {\n    template<input_or_output_iterator _It>\n      [[nodiscard]]\n      constexpr _It\n      operator()(_It __x) const\n      {\n\t++__x;\n\treturn __x;\n      }\n\n    template<input_or_output_iterator _It>\n      [[nodiscard]]\n      constexpr _It\n      operator()(_It __x, iter_difference_t<_It> __n) const\n      {\n\tranges::advance(__x, __n);\n\treturn __x;\n      }\n\n    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n      [[nodiscard]]\n      constexpr _It\n      operator()(_It __x, _Sent __bound) const\n      {\n\tranges::advance(__x, __bound);\n\treturn __x;\n      }\n\n    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n      [[nodiscard]]\n      constexpr _It\n      operator()(_It __x, iter_difference_t<_It> __n, _Sent __bound) const\n      {\n\tranges::advance(__x, __n, __bound);\n\treturn __x;\n      }\n\n    void operator&() const = delete;\n  };\n\n  inline constexpr __next_fn next{};\n\n  struct __prev_fn final\n  {\n    template<bidirectional_iterator _It>\n      [[nodiscard]]\n      constexpr _It\n      operator()(_It __x) const\n      {\n\t--__x;\n\treturn __x;\n      }\n\n    template<bidirectional_iterator _It>\n      [[nodiscard]]\n      constexpr _It\n      operator()(_It __x, iter_difference_t<_It> __n) const\n      {\n\tranges::advance(__x, -__n);\n\treturn __x;\n      }\n\n    template<bidirectional_iterator _It>\n      [[nodiscard]]\n      constexpr _It\n      operator()(_It __x, iter_difference_t<_It> __n, _It __bound) const\n      {\n\tranges::advance(__x, -__n, __bound);\n\treturn __x;\n      }\n\n    void operator&() const = delete;\n  };\n\n  inline constexpr __prev_fn prev{};\n\n  /// Type returned by algorithms instead of a dangling iterator or subrange.\n  struct dangling\n  {\n    constexpr dangling() noexcept = default;\n    template<typename... _Args>\n      constexpr dangling(_Args&&...) noexcept { }\n  };\n\n  template<range _Range>\n    using borrowed_iterator_t = __conditional_t<borrowed_range<_Range>,\n\t\t\t\t\t\titerator_t<_Range>,\n\t\t\t\t\t\tdangling>;\n} // namespace ranges\n\n#if __glibcxx_ranges_to_container // C++ >= 23\n  struct from_range_t { explicit from_range_t() = default; };\n  inline constexpr from_range_t from_range{};\n#endif\n\n#if __glibcxx_containers_ranges // C++ >= 23\n/// @cond undocumented\n  template<typename _T1, typename _T2>\n    struct pair;\n\nnamespace __detail\n{\n  template<typename _Rg, typename _Tp>\n    concept __container_compatible_range\n      = ranges::input_range<_Rg>\n\t  && convertible_to<ranges::range_reference_t<_Rg>, _Tp>;\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 4223. Deduction guides for maps are mishandling tuples and references\n  template<ranges::input_range _Range>\n    using __range_key_type\n      = remove_const_t<tuple_element_t<0, ranges::range_value_t<_Range>>>;\n\n  template<ranges::input_range _Range>\n    using __range_mapped_type\n      = tuple_element_t<1, ranges::range_value_t<_Range>>;\n\n  // The allocator's value_type for map-like containers.\n  template<ranges::input_range _Range>\n    using __range_to_alloc_type\n      = pair<const __range_key_type<_Range>, __range_mapped_type<_Range>>;\n}\n/// @endcond\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // library concepts\n#pragma GCC diagnostic pop\n#endif // C++20\n#endif // _GLIBCXX_RANGES_BASE_H\n"},
                          "roles": ["resultFile"]},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/ranges_util.h"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/tuple"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/stl_map.h"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/map"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/cstddef"},
                          "sourceLanguage": "cplusplus",
                          "contents": {"text": "// -*- C++ -*- forwarding header.\n\n// Copyright (C) 1997-2025 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file cstddef\n *  This is a Standard C++ Library file.  You should @c \\#include this file\n *  in your programs, rather than any of the @a *.h implementation files.\n *\n *  This is the C++ version of the Standard C Library header @c stddef.h,\n *  and its contents are (mostly) the same as that header, but are all\n *  contained in the namespace @c std (except for names which are defined\n *  as macros in C).\n */\n\n//\n// ISO C++ 14882: 18.1  Types\n//\n\n#ifndef _GLIBCXX_CSTDDEF\n#define _GLIBCXX_CSTDDEF 1\n\n#ifdef _GLIBCXX_SYSHDR\n#pragma GCC system_header\n#endif\n\n#undef __need_wchar_t\n#undef __need_ptrdiff_t\n#undef __need_size_t\n#undef __need_NULL\n#undef __need_wint_t\n#include <bits/c++config.h>\n#include <stddef.h>\n\n#define __glibcxx_want_byte\n#include <bits/version.h>\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\" // __int128\n\nextern \"C++\"\n{\n#if __cplusplus >= 201103L\nnamespace std\n{\n  // We handle size_t, ptrdiff_t, and nullptr_t in c++config.h.\n  using ::max_align_t;\n}\n#endif // C++11\n\n#ifdef __cpp_lib_byte // C++ >= 17\nnamespace std\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n  /// std::byte\n  enum class byte : unsigned char {};\n\n  template<typename _IntegerType> struct __byte_operand { };\n  template<> struct __byte_operand<bool> { using __type = byte; };\n  template<> struct __byte_operand<char> { using __type = byte; };\n  template<> struct __byte_operand<signed char> { using __type = byte; };\n  template<> struct __byte_operand<unsigned char> { using __type = byte; };\n  template<> struct __byte_operand<wchar_t> { using __type = byte; };\n#ifdef _GLIBCXX_USE_CHAR8_T\n  template<> struct __byte_operand<char8_t> { using __type = byte; };\n#endif\n  template<> struct __byte_operand<char16_t> { using __type = byte; };\n  template<> struct __byte_operand<char32_t> { using __type = byte; };\n  template<> struct __byte_operand<short> { using __type = byte; };\n  template<> struct __byte_operand<unsigned short> { using __type = byte; };\n  template<> struct __byte_operand<int> { using __type = byte; };\n  template<> struct __byte_operand<unsigned int> { using __type = byte; };\n  template<> struct __byte_operand<long> { using __type = byte; };\n  template<> struct __byte_operand<unsigned long> { using __type = byte; };\n  template<> struct __byte_operand<long long> { using __type = byte; };\n  template<> struct __byte_operand<unsigned long long> { using __type = byte; };\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_0>\n  { using __type = byte; };\n  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_0>\n  { using __type = byte; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_1>\n  { using __type = byte; };\n  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_1>\n  { using __type = byte; };\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n  template<> struct __byte_operand<__GLIBCXX_TYPE_INT_N_2>\n  { using __type = byte; };\n  template<> struct __byte_operand<unsigned __GLIBCXX_TYPE_INT_N_2>\n  { using __type = byte; };\n#endif\n  template<typename _IntegerType>\n    struct __byte_operand<const _IntegerType>\n    : __byte_operand<_IntegerType> { };\n  template<typename _IntegerType>\n    struct __byte_operand<volatile _IntegerType>\n    : __byte_operand<_IntegerType> { };\n  template<typename _IntegerType>\n    struct __byte_operand<const volatile _IntegerType>\n    : __byte_operand<_IntegerType> { };\n\n  template<typename _IntegerType>\n    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;\n\n  template<typename _IntegerType>\n    [[__gnu__::__always_inline__]]\n    constexpr __byte_op_t<_IntegerType>\n    operator<<(byte __b, _IntegerType __shift) noexcept\n    { return (byte)(unsigned char)((unsigned)__b << __shift); }\n\n  template<typename _IntegerType>\n    [[__gnu__::__always_inline__]]\n    constexpr __byte_op_t<_IntegerType>\n    operator>>(byte __b, _IntegerType __shift) noexcept\n    { return (byte)(unsigned char)((unsigned)__b >> __shift); }\n\n  [[__gnu__::__always_inline__]]\n  constexpr byte\n  operator|(byte __l, byte __r) noexcept\n  { return (byte)(unsigned char)((unsigned)__l | (unsigned)__r); }\n\n  [[__gnu__::__always_inline__]]\n  constexpr byte\n  operator&(byte __l, byte __r) noexcept\n  { return (byte)(unsigned char)((unsigned)__l & (unsigned)__r); }\n\n  [[__gnu__::__always_inline__]]\n  constexpr byte\n  operator^(byte __l, byte __r) noexcept\n  { return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r); }\n\n  [[__gnu__::__always_inline__]]\n  constexpr byte\n  operator~(byte __b) noexcept\n  { return (byte)(unsigned char)~(unsigned)__b; }\n\n  template<typename _IntegerType>\n    [[__gnu__::__always_inline__]]\n    constexpr __byte_op_t<_IntegerType>&\n    operator<<=(byte& __b, _IntegerType __shift) noexcept\n    { return __b = __b << __shift; }\n\n  template<typename _IntegerType>\n    [[__gnu__::__always_inline__]]\n    constexpr __byte_op_t<_IntegerType>&\n    operator>>=(byte& __b, _IntegerType __shift) noexcept\n    { return __b = __b >> __shift; }\n\n  [[__gnu__::__always_inline__]]\n  constexpr byte&\n  operator|=(byte& __l, byte __r) noexcept\n  { return __l = __l | __r; }\n\n  [[__gnu__::__always_inline__]]\n  constexpr byte&\n  operator&=(byte& __l, byte __r) noexcept\n  { return __l = __l & __r; }\n\n  [[__gnu__::__always_inline__]]\n  constexpr byte&\n  operator^=(byte& __l, byte __r) noexcept\n  { return __l = __l ^ __r; }\n\n  template<typename _IntegerType>\n    [[nodiscard,__gnu__::__always_inline__]]\n    constexpr _IntegerType\n    to_integer(__byte_op_t<_IntegerType> __b) noexcept\n    { return _IntegerType(__b); }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // __cpp_lib_byte\n} // extern \"C++\"\n\n#pragma GCC diagnostic pop\n\n#endif // _GLIBCXX_CSTDDEF\n"},
                          "roles": ["resultFile"]},
                         {"location": {"uri": "/usr/include/c++/15.2.1/charconv"},
                          "sourceLanguage": "cplusplus",
                          "contents": {"text": "// Primitive numeric conversions (to_chars and from_chars) -*- C++ -*-\n\n// Copyright (C) 2017-2025 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file include/charconv\n *  This is a Standard C++ Library header.\n */\n\n#ifndef _GLIBCXX_CHARCONV\n#define _GLIBCXX_CHARCONV 1\n\n#ifdef _GLIBCXX_SYSHDR\n#pragma GCC system_header\n#endif\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\" // __int128\n\n#include <bits/requires_hosted.h> // for error codes\n\n// As an extension we support <charconv> in C++14, but this header should not\n// be included by any other library headers in C++14 mode. This ensures that\n// the names defined in this header are not added to namespace std unless a\n// user explicitly includes <charconv> in C++14 code.\n#if __cplusplus >= 201402L\n\n#include <type_traits>\n#include <bit>\t\t\t// for __bit_width\n#include <bits/charconv.h>\t// for __to_chars_len, __to_chars_10_impl\n#include <bits/error_constants.h> // for std::errc\n#include <ext/numeric_traits.h>\n\n#define __glibcxx_want_to_chars\n#define __glibcxx_want_constexpr_charconv\n#include <bits/version.h>\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /// Result type of std::to_chars\n  struct to_chars_result\n  {\n    char* ptr;\n    errc ec;\n\n#if __cplusplus > 201703L && __cpp_impl_three_way_comparison >= 201907L\n    friend bool\n    operator==(const to_chars_result&, const to_chars_result&) = default;\n#endif\n#if __cplusplus > 202302L\n    constexpr explicit operator bool() const noexcept { return ec == errc{}; }\n#endif\n  };\n\n  /// Result type of std::from_chars\n  struct from_chars_result\n  {\n    const char* ptr;\n    errc ec;\n\n#if __cplusplus > 201703L && __cpp_impl_three_way_comparison >= 201907L\n    friend bool\n    operator==(const from_chars_result&, const from_chars_result&) = default;\n#endif\n#if __cplusplus > 202302L\n    constexpr explicit operator bool() const noexcept { return ec == errc{}; }\n#endif\n  };\n\nnamespace __detail\n{\n  // Pick an unsigned type of suitable size. This is used to reduce the\n  // number of specializations of __to_chars_len, __to_chars etc. that\n  // get instantiated. For example, to_chars<char> and to_chars<short>\n  // and to_chars<unsigned> will all use the same code, and so will\n  // to_chars<long> when sizeof(int) == sizeof(long).\n  template<typename _Tp>\n    struct __to_chars_unsigned_type : __make_unsigned_selector_base\n    {\n      using _UInts = _List<unsigned int, unsigned long, unsigned long long\n#if __SIZEOF_INT128__ > __SIZEOF_LONG_LONG__\n\t, unsigned __int128\n#endif\n\t>;\n      using type = typename __select<sizeof(_Tp), _UInts>::__type;\n    };\n\n  template<typename _Tp>\n    using __unsigned_least_t = typename __to_chars_unsigned_type<_Tp>::type;\n\n  // Generic implementation for arbitrary bases.\n  // Defined in <bits/charconv.h>.\n  template<typename _Tp>\n    constexpr unsigned\n    __to_chars_len(_Tp __value, int __base /* = 10 */) noexcept;\n\n  template<typename _Tp>\n    constexpr unsigned\n    __to_chars_len_2(_Tp __value) noexcept\n    { return std::__bit_width(__value); }\n\n  // Generic implementation for arbitrary bases.\n  template<typename _Tp>\n    constexpr to_chars_result\n    __to_chars(char* __first, char* __last, _Tp __val, int __base) noexcept\n    {\n      static_assert(__integer_to_chars_is_unsigned<_Tp>, \"implementation bug\");\n\n      to_chars_result __res;\n\n      const unsigned __len = __to_chars_len(__val, __base);\n\n      if (__builtin_expect(size_t(__last - __first) < __len, 0))\n\t{\n\t  __res.ptr = __last;\n\t  __res.ec = errc::value_too_large;\n\t  return __res;\n\t}\n\n      unsigned __pos = __len - 1;\n\n      constexpr char __digits[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',\n\t'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n\t'u', 'v', 'w', 'x', 'y', 'z'\n      };\n\n      while (__val >= (unsigned)__base)\n\t{\n\t  auto const __quo = __val / __base;\n\t  auto const __rem = __val % __base;\n\t  __first[__pos--] = __digits[__rem];\n\t  __val = __quo;\n\t}\n      *__first = __digits[__val];\n\n      __res.ptr = __first + __len;\n      __res.ec = {};\n      return __res;\n    }\n\n  template<typename _Tp>\n    constexpr to_chars_result\n    __to_chars_16(char* __first, char* __last, _Tp __val) noexcept\n    {\n      static_assert(__integer_to_chars_is_unsigned<_Tp>, \"implementation bug\");\n\n      to_chars_result __res;\n\n      const unsigned __len = (__to_chars_len_2(__val) + 3) / 4;\n\n      if (__builtin_expect(size_t(__last - __first) < __len, 0))\n\t{\n\t  __res.ptr = __last;\n\t  __res.ec = errc::value_too_large;\n\t  return __res;\n\t}\n\n      constexpr char __digits[] = {\n\t'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n\t'a', 'b', 'c', 'd', 'e', 'f'\n      };\n      unsigned __pos = __len - 1;\n      while (__val >= 0x100)\n\t{\n\t  auto __num = __val & 0xF;\n\t  __val >>= 4;\n\t  __first[__pos] = __digits[__num];\n\t  __num = __val & 0xF;\n\t  __val >>= 4;\n\t  __first[__pos - 1] = __digits[__num];\n\t  __pos -= 2;\n\t}\n      if (__val >= 0x10)\n\t{\n\t  const auto __num = __val & 0xF;\n\t  __val >>= 4;\n\t  __first[1] = __digits[__num];\n\t  __first[0] = __digits[__val];\n\t}\n      else\n\t__first[0] = __digits[__val];\n      __res.ptr = __first + __len;\n      __res.ec = {};\n      return __res;\n    }\n\n  template<typename _Tp>\n    constexpr to_chars_result\n    __to_chars_10(char* __first, char* __last, _Tp __val) noexcept\n    {\n      static_assert(__integer_to_chars_is_unsigned<_Tp>, \"implementation bug\");\n\n      to_chars_result __res;\n\n      const unsigned __len = __to_chars_len(__val, 10);\n\n      if (__builtin_expect(size_t(__last - __first) < __len, 0))\n\t{\n\t  __res.ptr = __last;\n\t  __res.ec = errc::value_too_large;\n\t  return __res;\n\t}\n\n      __detail::__to_chars_10_impl(__first, __len, __val);\n      __res.ptr = __first + __len;\n      __res.ec = {};\n      return __res;\n    }\n\n  template<typename _Tp>\n    constexpr to_chars_result\n    __to_chars_8(char* __first, char* __last, _Tp __val) noexcept\n    {\n      static_assert(__integer_to_chars_is_unsigned<_Tp>, \"implementation bug\");\n\n      to_chars_result __res;\n      unsigned __len = 0;\n\n      if _GLIBCXX17_CONSTEXPR (__gnu_cxx::__int_traits<_Tp>::__digits <= 16)\n\t{\n\t  __len = __val > 077777u ? 6u\n\t    : __val > 07777u ? 5u\n\t    : __val > 0777u ? 4u\n\t    : __val > 077u ? 3u\n\t    : __val > 07u ? 2u\n\t    : 1u;\n\t}\n      else\n\t__len = (__to_chars_len_2(__val) + 2) / 3;\n\n      if (__builtin_expect(size_t(__last - __first) < __len, 0))\n\t{\n\t  __res.ptr = __last;\n\t  __res.ec = errc::value_too_large;\n\t  return __res;\n\t}\n\n      unsigned __pos = __len - 1;\n      while (__val >= 0100)\n\t{\n\t  auto __num = __val & 7;\n\t  __val >>= 3;\n\t  __first[__pos] = '0' + __num;\n\t  __num = __val & 7;\n\t  __val >>= 3;\n\t  __first[__pos - 1] = '0' + __num;\n\t  __pos -= 2;\n\t}\n      if (__val >= 010)\n\t{\n\t  auto const __num = __val & 7;\n\t  __val >>= 3;\n\t  __first[1] = '0' + __num;\n\t  __first[0] = '0' + __val;\n\t}\n      else\n\t__first[0] = '0' + __val;\n      __res.ptr = __first + __len;\n      __res.ec = {};\n      return __res;\n    }\n\n  template<typename _Tp>\n    constexpr to_chars_result\n    __to_chars_2(char* __first, char* __last, _Tp __val) noexcept\n    {\n      static_assert(__integer_to_chars_is_unsigned<_Tp>, \"implementation bug\");\n\n      to_chars_result __res;\n\n      const unsigned __len = __to_chars_len_2(__val);\n\n      if (__builtin_expect(size_t(__last - __first) < __len, 0))\n\t{\n\t  __res.ptr = __last;\n\t  __res.ec = errc::value_too_large;\n\t  return __res;\n\t}\n\n      unsigned __pos = __len - 1;\n\n      while (__pos)\n\t{\n\t  __first[__pos--] = '0' + (__val & 1);\n\t  __val >>= 1;\n\t}\n      // First digit is always '1' because __to_chars_len_2 skips\n      // leading zero bits and std::to_chars handles zero values\n      // directly.\n      __first[0] = '1';\n\n      __res.ptr = __first + __len;\n      __res.ec = {};\n      return __res;\n    }\n\n} // namespace __detail\n\n  template<typename _Tp>\n    constexpr to_chars_result\n    __to_chars_i(char* __first, char* __last, _Tp __value, int __base = 10)\n    {\n      __glibcxx_assert(2 <= __base && __base <= 36);\n\n      using _Up = __detail::__unsigned_least_t<_Tp>;\n      _Up __unsigned_val = __value;\n\n      if (__first >= __last) [[__unlikely__]]\n\treturn { __last, errc::value_too_large };\n\n      if (__value == 0)\n\t{\n\t  *__first = '0';\n\t  return { __first + 1, errc{} };\n\t}\n      else if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)\n\tif (__value < 0)\n\t  {\n\t    *__first++ = '-';\n\t    __unsigned_val = _Up(~__value) + _Up(1);\n\t  }\n\n      switch (__base)\n      {\n      case 16:\n\treturn __detail::__to_chars_16(__first, __last, __unsigned_val);\n      case 10:\n\treturn __detail::__to_chars_10(__first, __last, __unsigned_val);\n      case 8:\n\treturn __detail::__to_chars_8(__first, __last, __unsigned_val);\n      case 2:\n\treturn __detail::__to_chars_2(__first, __last, __unsigned_val);\n      default:\n\treturn __detail::__to_chars(__first, __last, __unsigned_val, __base);\n      }\n    }\n\n#define _GLIBCXX_TO_CHARS(T) \\\n  _GLIBCXX23_CONSTEXPR inline to_chars_result \\\n  to_chars(char* __first, char* __last, T __value, int __base = 10) \\\n  { return std::__to_chars_i<T>(__first, __last, __value, __base); }\n_GLIBCXX_TO_CHARS(char)\n_GLIBCXX_TO_CHARS(signed char)\n_GLIBCXX_TO_CHARS(unsigned char)\n_GLIBCXX_TO_CHARS(signed short)\n_GLIBCXX_TO_CHARS(unsigned short)\n_GLIBCXX_TO_CHARS(signed int)\n_GLIBCXX_TO_CHARS(unsigned int)\n_GLIBCXX_TO_CHARS(signed long)\n_GLIBCXX_TO_CHARS(unsigned long)\n_GLIBCXX_TO_CHARS(signed long long)\n_GLIBCXX_TO_CHARS(unsigned long long)\n#if defined(__GLIBCXX_TYPE_INT_N_0)\n_GLIBCXX_TO_CHARS(signed __GLIBCXX_TYPE_INT_N_0)\n_GLIBCXX_TO_CHARS(unsigned __GLIBCXX_TYPE_INT_N_0)\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_1)\n_GLIBCXX_TO_CHARS(signed __GLIBCXX_TYPE_INT_N_1)\n_GLIBCXX_TO_CHARS(unsigned __GLIBCXX_TYPE_INT_N_1)\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_2)\n_GLIBCXX_TO_CHARS(signed __GLIBCXX_TYPE_INT_N_2)\n_GLIBCXX_TO_CHARS(unsigned __GLIBCXX_TYPE_INT_N_2)\n#endif\n#if defined(__GLIBCXX_TYPE_INT_N_3)\n_GLIBCXX_TO_CHARS(signed __GLIBCXX_TYPE_INT_N_3)\n_GLIBCXX_TO_CHARS(unsigned __GLIBCXX_TYPE_INT_N_3)\n#endif\n#undef _GLIBCXX_TO_CHARS\n\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 3266. to_chars(bool) should be deleted\n  to_chars_result to_chars(char*, char*, bool, int = 10) = delete;\n\nnamespace __detail\n{\n  template<typename _Tp>\n    constexpr bool\n    __raise_and_add(_Tp& __val, int __base, unsigned char __c)\n    {\n      if (__builtin_mul_overflow(__val, __base, &__val)\n\t  || __builtin_add_overflow(__val, __c, &__val))\n\treturn false;\n      return true;\n    }\n\n  template<bool _DecOnly>\n    struct __from_chars_alnum_to_val_table\n    {\n      struct type { unsigned char __data[1u << __CHAR_BIT__] = {}; };\n\n      // Construct and return a lookup table that maps 0-9, A-Z and a-z to their\n      // corresponding base-36 value and maps all other characters to 127.\n      static constexpr type\n      _S_make_table()\n      {\n\tconstexpr unsigned char __lower_letters[27] = \"abcdefghijklmnopqrstuvwxyz\";\n\tconstexpr unsigned char __upper_letters[27] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\ttype __table;\n\tfor (auto& __entry : __table.__data)\n\t  __entry = 127;\n\tfor (int __i = 0; __i < 10; ++__i)\n\t  __table.__data['0' + __i] = __i;\n\tfor (int __i = 0; __i < 26; ++__i)\n\t  {\n\t    __table.__data[__lower_letters[__i]] = 10 + __i;\n\t    __table.__data[__upper_letters[__i]] = 10 + __i;\n\t  }\n\treturn __table;\n      }\n\n      // This initializer is made superficially dependent in order\n      // to prevent the compiler from wastefully constructing the\n      // table ahead of time when it's not needed.\n      static constexpr type value = (_DecOnly, _S_make_table());\n    };\n\n#if ! __cpp_inline_variables\n  template<bool _DecOnly>\n    const typename __from_chars_alnum_to_val_table<_DecOnly>::type\n      __from_chars_alnum_to_val_table<_DecOnly>::value;\n#endif\n\n  // If _DecOnly is true: if the character is a decimal digit, then\n  // return its corresponding base-10 value, otherwise return a value >= 127.\n  // If _DecOnly is false: if the character is an alphanumeric digit, then\n  // return its corresponding base-36 value, otherwise return a value >= 127.\n  template<bool _DecOnly = false>\n    _GLIBCXX20_CONSTEXPR unsigned char\n    __from_chars_alnum_to_val(unsigned char __c)\n    {\n      if _GLIBCXX17_CONSTEXPR (_DecOnly)\n\treturn static_cast<unsigned char>(__c - '0');\n      else\n\treturn __from_chars_alnum_to_val_table<_DecOnly>::value.__data[__c];\n    }\n\n  /// std::from_chars implementation for integers in a power-of-two base.\n  /// If _DecOnly is true, then we may assume __base is at most 8.\n  template<bool _DecOnly, typename _Tp>\n    _GLIBCXX23_CONSTEXPR bool\n    __from_chars_pow2_base(const char*& __first, const char* __last, _Tp& __val,\n\t\t\t   int __base)\n    {\n      static_assert(is_integral<_Tp>::value, \"implementation bug\");\n      static_assert(is_unsigned<_Tp>::value, \"implementation bug\");\n\n      // __glibcxx_assert((__base & (__base - 1)) == 0);\n      // __glibcxx_assert(_DecOnly ? __base <= 8 : __base <= 32);\n      const int __log2_base = __countr_zero(unsigned(__base & 0x3f));\n\n      const ptrdiff_t __len = __last - __first;\n      ptrdiff_t __i = 0;\n      while (__i < __len && __first[__i] == '0')\n\t++__i;\n      const ptrdiff_t __leading_zeroes = __i;\n      if (__i >= __len) [[__unlikely__]]\n\t{\n\t  __first += __i;\n\t  return true;\n\t}\n\n      // Remember the leading significant digit value if necessary.\n      unsigned char __leading_c = 0;\n      if (__base != 2)\n\t{\n\t  __leading_c = __from_chars_alnum_to_val<_DecOnly>(__first[__i]);\n\t  // __glibcxx_assert(__leading_c != 0);\n\t  if (__leading_c >= __base) [[__unlikely__]]\n\t    {\n\t      __first += __i;\n\t      return true;\n\t    }\n\t  __val = __leading_c;\n\t  ++__i;\n\t}\n\n      for (; __i < __len; ++__i)\n\t{\n\t  const unsigned char __c = __from_chars_alnum_to_val<_DecOnly>(__first[__i]);\n\t  if (__c >= __base)\n\t    break;\n\t  __val = (__val << __log2_base) | __c;\n\t}\n      __first += __i;\n      auto __significant_bits = (__i - __leading_zeroes) * __log2_base;\n      if (__base != 2)\n\t// Compensate for a leading significant digit that didn't use all\n\t// of its available bits.\n\t__significant_bits -= __log2_base - __bit_width(__leading_c);\n      // __glibcxx_assert(__significant_bits >= 0);\n      return __significant_bits <= __gnu_cxx::__int_traits<_Tp>::__digits;\n    }\n\n  /// std::from_chars implementation for integers in any base.\n  /// If _DecOnly is true, then we may assume __base is at most 10.\n  template<bool _DecOnly, typename _Tp>\n    constexpr bool\n    __from_chars_alnum(const char*& __first, const char* __last, _Tp& __val,\n\t\t       int __base)\n    {\n      // __glibcxx_assert(_DecOnly ? __base <= 10 : __base <= 36);\n\n      const int __bits_per_digit = __bit_width(unsigned(__base & 0x3f));\n      int __unused_bits_lower_bound = __gnu_cxx::__int_traits<_Tp>::__digits;\n      for (; __first != __last; ++__first)\n\t{\n\t  const unsigned char __c = __from_chars_alnum_to_val<_DecOnly>(*__first);\n\t  if (__c >= __base)\n\t    return true;\n\n\t  __unused_bits_lower_bound -= __bits_per_digit;\n\t  if (__unused_bits_lower_bound >= 0) [[__likely__]]\n\t    // We're definitely not going to overflow.\n\t    __val = __val * __base + __c;\n\t  else if (!__raise_and_add(__val, __base, __c)) [[__unlikely__]]\n\t    {\n\t      while (++__first != __last\n\t\t     && __from_chars_alnum_to_val<_DecOnly>(*__first) < __base)\n\t\t;\n\t      return false;\n\t    }\n\t}\n      return true;\n    }\n\n} // namespace __detail\n\n  /// std::from_chars for integral types.\n  template<typename _Tp,\n\t   enable_if_t<__or_<__is_standard_integer<_Tp>,\n\t\t\t     is_same<char, remove_cv_t<_Tp>>>::value, int> = 0>\n    _GLIBCXX23_CONSTEXPR from_chars_result\n    from_chars(const char* __first, const char* __last, _Tp& __value,\n\t       int __base = 10)\n    {\n      __glibcxx_assert(2 <= __base && __base <= 36);\n\n      from_chars_result __res{__first, {}};\n\n      int __sign = 1;\n      if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)\n\tif (__first != __last && *__first == '-')\n\t  {\n\t    __sign = -1;\n\t    ++__first;\n\t  }\n\n      using _Up = __detail::__unsigned_least_t<_Tp>;\n      _Up __val = 0;\n\n      const auto __start = __first;\n      bool __valid;\n      if ((__base & (__base - 1)) == 0)\n\t{\n\t  if (__base <= 8)\n\t    __valid = __detail::__from_chars_pow2_base<true>(__first, __last, __val, __base);\n\t  else\n\t    __valid = __detail::__from_chars_pow2_base<false>(__first, __last, __val, __base);\n\t}\n      else if (__base <= 10)\n\t__valid = __detail::__from_chars_alnum<true>(__first, __last, __val, __base);\n      else\n\t__valid = __detail::__from_chars_alnum<false>(__first, __last, __val, __base);\n\n      if (__builtin_expect(__first == __start, 0))\n\t__res.ec = errc::invalid_argument;\n      else\n\t{\n\t  __res.ptr = __first;\n\t  if (!__valid)\n\t    __res.ec = errc::result_out_of_range;\n\t  else\n\t    {\n\t      if _GLIBCXX17_CONSTEXPR (std::is_signed<_Tp>::value)\n\t\t{\n\t\t  _Tp __tmp;\n\t\t  if (__builtin_mul_overflow(__val, __sign, &__tmp))\n\t\t    __res.ec = errc::result_out_of_range;\n\t\t  else\n\t\t    __value = __tmp;\n\t\t}\n\t      else\n\t\t{\n\t\t  if _GLIBCXX17_CONSTEXPR (__gnu_cxx::__int_traits<_Up>::__max\n\t\t      > __gnu_cxx::__int_traits<_Tp>::__max)\n\t\t    {\n\t\t      if (__val > __gnu_cxx::__int_traits<_Tp>::__max)\n\t\t\t__res.ec = errc::result_out_of_range;\n\t\t      else\n\t\t\t__value = __val;\n\t\t    }\n\t\t  else\n\t\t    __value = __val;\n\t\t}\n\t    }\n\t}\n      return __res;\n    }\n\n  /// floating-point format for primitive numerical conversion\n  enum class chars_format\n  {\n    scientific = 1, fixed = 2, hex = 4, general = fixed | scientific\n  };\n\n  [[nodiscard]]\n  constexpr chars_format\n  operator|(chars_format __lhs, chars_format __rhs) noexcept\n  { return (chars_format)((unsigned)__lhs | (unsigned)__rhs); }\n\n  [[nodiscard]]\n  constexpr chars_format\n  operator&(chars_format __lhs, chars_format __rhs) noexcept\n  { return (chars_format)((unsigned)__lhs & (unsigned)__rhs); }\n\n  [[nodiscard]]\n  constexpr chars_format\n  operator^(chars_format __lhs, chars_format __rhs) noexcept\n  { return (chars_format)((unsigned)__lhs ^ (unsigned)__rhs); }\n\n  [[nodiscard]]\n  constexpr chars_format\n  operator~(chars_format __fmt) noexcept\n  { return (chars_format)~(unsigned)__fmt; }\n\n  constexpr chars_format&\n  operator|=(chars_format& __lhs, chars_format __rhs) noexcept\n  { return __lhs = __lhs | __rhs; }\n\n  constexpr chars_format&\n  operator&=(chars_format& __lhs, chars_format __rhs) noexcept\n  { return __lhs = __lhs & __rhs; }\n\n  constexpr chars_format&\n  operator^=(chars_format& __lhs, chars_format __rhs) noexcept\n  { return __lhs = __lhs ^ __rhs; }\n\n#if defined __cpp_lib_to_chars || _GLIBCXX_HAVE_USELOCALE\n  from_chars_result\n  from_chars(const char* __first, const char* __last, float& __value,\n\t     chars_format __fmt = chars_format::general) noexcept;\n\n  from_chars_result\n  from_chars(const char* __first, const char* __last, double& __value,\n\t     chars_format __fmt = chars_format::general) noexcept;\n\n  from_chars_result\n  from_chars(const char* __first, const char* __last, long double& __value,\n\t     chars_format __fmt = chars_format::general) noexcept;\n\n  // Library routines for 16-bit extended floating point formats\n  // using float as interchange format.\n  from_chars_result\n  __from_chars_float16_t(const char* __first, const char* __last,\n\t\t\t float& __value,\n\t\t\t chars_format __fmt = chars_format::general) noexcept;\n  from_chars_result\n  __from_chars_bfloat16_t(const char* __first, const char* __last,\n\t\t\t  float& __value,\n\t\t\t  chars_format __fmt = chars_format::general) noexcept;\n\n#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32) \\\n    && defined(__cpp_lib_to_chars)\n  inline from_chars_result\n  from_chars(const char* __first, const char* __last, _Float16& __value,\n\t     chars_format __fmt = chars_format::general) noexcept\n  {\n    float __val;\n    from_chars_result __res\n      = __from_chars_float16_t(__first, __last, __val, __fmt);\n    if (__res.ec == errc{})\n      __value = _Float16(__val);\n    return __res;\n  }\n#endif\n\n#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n  inline from_chars_result\n  from_chars(const char* __first, const char* __last, _Float32& __value,\n\t     chars_format __fmt = chars_format::general) noexcept\n  {\n    float __val;\n    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n    if (__res.ec == errc{})\n      __value = _Float32(__val);\n    return __res;\n  }\n#endif\n\n#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n  inline from_chars_result\n  from_chars(const char* __first, const char* __last, _Float64& __value,\n\t     chars_format __fmt = chars_format::general) noexcept\n  {\n    double __val;\n    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n    if (__res.ec == errc{})\n      __value = _Float64(__val);\n    return __res;\n  }\n#endif\n\n#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n  inline from_chars_result\n  from_chars(const char* __first, const char* __last, _Float128& __value,\n\t     chars_format __fmt = chars_format::general) noexcept\n  {\n    long double __val;\n    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n    if (__res.ec == errc{})\n      __value = _Float128(__val);\n    return __res;\n  }\n#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n  __extension__ from_chars_result\n  from_chars(const char* __first, const char* __last, __ieee128& __value,\n\t     chars_format __fmt = chars_format::general) noexcept;\n\n  inline from_chars_result\n  from_chars(const char* __first, const char* __last, _Float128& __value,\n\t     chars_format __fmt = chars_format::general) noexcept\n  {\n    __extension__ __ieee128 __val;\n    from_chars_result __res = from_chars(__first, __last, __val, __fmt);\n    if (__res.ec == errc{})\n      __value = _Float128(__val);\n    return __res;\n  }\n#else\n  from_chars_result\n  from_chars(const char* __first, const char* __last, _Float128& __value,\n\t     chars_format __fmt = chars_format::general) noexcept;\n#endif\n#endif\n\n#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32) \\\n    && defined(__cpp_lib_to_chars)\n  inline from_chars_result\n  from_chars(const char* __first, const char* __last,\n\t     __gnu_cxx::__bfloat16_t & __value,\n\t     chars_format __fmt = chars_format::general) noexcept\n  {\n    float __val;\n    from_chars_result __res\n      = __from_chars_bfloat16_t(__first, __last, __val, __fmt);\n    if (__res.ec == errc{})\n      __value = __gnu_cxx::__bfloat16_t(__val);\n    return __res;\n  }\n#endif\n#endif\n\n#if defined __cpp_lib_to_chars\n  // Floating-point std::to_chars\n\n  // Overloads for float.\n  to_chars_result to_chars(char* __first, char* __last, float __value) noexcept;\n  to_chars_result to_chars(char* __first, char* __last, float __value,\n\t\t\t   chars_format __fmt) noexcept;\n  to_chars_result to_chars(char* __first, char* __last, float __value,\n\t\t\t   chars_format __fmt, int __precision) noexcept;\n\n  // Overloads for double.\n  to_chars_result to_chars(char* __first, char* __last, double __value) noexcept;\n  to_chars_result to_chars(char* __first, char* __last, double __value,\n\t\t\t   chars_format __fmt) noexcept;\n  to_chars_result to_chars(char* __first, char* __last, double __value,\n\t\t\t   chars_format __fmt, int __precision) noexcept;\n\n  // Overloads for long double.\n  to_chars_result to_chars(char* __first, char* __last, long double __value)\n    noexcept;\n  to_chars_result to_chars(char* __first, char* __last, long double __value,\n\t\t\t   chars_format __fmt) noexcept;\n  to_chars_result to_chars(char* __first, char* __last, long double __value,\n\t\t\t   chars_format __fmt, int __precision) noexcept;\n\n  // Library routines for 16-bit extended floating point formats\n  // using float as interchange format.\n  to_chars_result __to_chars_float16_t(char* __first, char* __last,\n\t\t\t\t       float __value,\n\t\t\t\t       chars_format __fmt) noexcept;\n  to_chars_result __to_chars_bfloat16_t(char* __first, char* __last,\n\t\t\t\t\tfloat __value,\n\t\t\t\t\tchars_format __fmt) noexcept;\n\n#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float16 __value) noexcept\n  {\n    return __to_chars_float16_t(__first, __last, float(__value),\n\t\t\t\tchars_format{});\n  }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float16 __value,\n\t   chars_format __fmt) noexcept\n  { return __to_chars_float16_t(__first, __last, float(__value), __fmt); }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float16 __value,\n\t   chars_format __fmt, int __precision) noexcept\n  { return to_chars(__first, __last, float(__value), __fmt, __precision); }\n#endif\n\n#if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float32 __value) noexcept\n  { return to_chars(__first, __last, float(__value)); }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float32 __value,\n\t   chars_format __fmt) noexcept\n  { return to_chars(__first, __last, float(__value), __fmt); }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float32 __value,\n\t   chars_format __fmt, int __precision) noexcept\n  { return to_chars(__first, __last, float(__value), __fmt, __precision); }\n#endif\n\n#if defined(__STDCPP_FLOAT64_T__) && defined(_GLIBCXX_DOUBLE_IS_IEEE_BINARY64)\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float64 __value) noexcept\n  { return to_chars(__first, __last, double(__value)); }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float64 __value,\n\t   chars_format __fmt) noexcept\n  { return to_chars(__first, __last, double(__value), __fmt); }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float64 __value,\n\t   chars_format __fmt, int __precision) noexcept\n  { return to_chars(__first, __last, double(__value), __fmt, __precision); }\n#endif\n\n#if defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_LDOUBLE_IS_IEEE_BINARY128)\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float128 __value) noexcept\n  { return to_chars(__first, __last, static_cast<long double>(__value)); }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float128 __value,\n\t   chars_format __fmt) noexcept\n  {\n    return to_chars(__first, __last, static_cast<long double>(__value), __fmt);\n  }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float128 __value,\n\t   chars_format __fmt, int __precision) noexcept\n  {\n    return to_chars(__first, __last, static_cast<long double>(__value), __fmt,\n\t\t    __precision);\n  }\n#elif defined(__STDCPP_FLOAT128_T__) && defined(_GLIBCXX_HAVE_FLOAT128_MATH)\n#ifdef _GLIBCXX_LONG_DOUBLE_ALT128_COMPAT\n  __extension__ to_chars_result\n  to_chars(char* __first, char* __last, __float128 __value) noexcept;\n  __extension__ to_chars_result\n  to_chars(char* __first, char* __last, __float128 __value,\n\t   chars_format __fmt) noexcept;\n  __extension__ to_chars_result\n  to_chars(char* __first, char* __last, __float128 __value,\n\t   chars_format __fmt, int __precision) noexcept;\n\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float128 __value) noexcept\n  {\n    return __extension__ to_chars(__first, __last,\n\t\t\t\t  static_cast<__float128>(__value));\n  }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float128 __value,\n\t   chars_format __fmt) noexcept\n  {\n\n    return __extension__ to_chars(__first, __last,\n\t\t\t\t  static_cast<__float128>(__value), __fmt);\n  }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, _Float128 __value,\n\t   chars_format __fmt, int __precision) noexcept\n  {\n\n    return __extension__ to_chars(__first, __last,\n\t\t\t\t  static_cast<__float128>(__value), __fmt,\n\t\t\t\t  __precision);\n  }\n#else\n  to_chars_result to_chars(char* __first, char* __last, _Float128 __value)\n    noexcept;\n  to_chars_result to_chars(char* __first, char* __last, _Float128 __value,\n\t\t\t   chars_format __fmt) noexcept;\n  to_chars_result to_chars(char* __first, char* __last, _Float128 __value,\n\t\t\t   chars_format __fmt, int __precision) noexcept;\n#endif\n#endif\n\n#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n  inline to_chars_result\n  to_chars(char* __first, char* __last,\n\t   __gnu_cxx::__bfloat16_t __value) noexcept\n  {\n    return __to_chars_bfloat16_t(__first, __last, float(__value),\n\t\t\t\t chars_format{});\n  }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, __gnu_cxx::__bfloat16_t __value,\n\t   chars_format __fmt) noexcept\n  { return __to_chars_bfloat16_t(__first, __last, float(__value), __fmt); }\n  inline to_chars_result\n  to_chars(char* __first, char* __last, __gnu_cxx::__bfloat16_t __value,\n\t   chars_format __fmt, int __precision) noexcept\n  { return to_chars(__first, __last, float(__value), __fmt, __precision); }\n#endif\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // C++14\n#pragma GCC diagnostic pop\n#endif // _GLIBCXX_CHARCONV\n"},
                          "roles": ["resultFile"]},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                          "sourceLanguage": "cplusplus",
                          "contents": {"text": "// Iostreams base classes -*- C++ -*-\n\n// Copyright (C) 1997-2025 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// <http://www.gnu.org/licenses/>.\n\n/** @file bits/ios_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{ios}\n */\n\n//\n// ISO C++ 14882: 27.4  Iostreams base classes\n//\n\n#ifndef _IOS_BASE_H\n#define _IOS_BASE_H 1\n\n#ifdef _GLIBCXX_SYSHDR\n#pragma GCC system_header\n#endif\n\n#include <ext/atomicity.h>\n#include <bits/localefwd.h>\n#include <bits/locale_classes.h>\n\n#if __cplusplus < 201103L\n# include <stdexcept>\n#else\n# include <system_error>\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  // The following definitions of bitmask types are enums, not ints,\n  // as permitted (but not required) in the standard, in order to provide\n  // better type safety in iostream calls.  A side effect is that in C++98\n  // expressions involving them are not compile-time constants.\n  enum _Ios_Fmtflags\n    {\n      _S_boolalpha \t= 1L << 0,\n      _S_dec \t\t= 1L << 1,\n      _S_fixed \t\t= 1L << 2,\n      _S_hex \t\t= 1L << 3,\n      _S_internal \t= 1L << 4,\n      _S_left \t\t= 1L << 5,\n      _S_oct \t\t= 1L << 6,\n      _S_right \t\t= 1L << 7,\n      _S_scientific \t= 1L << 8,\n      _S_showbase \t= 1L << 9,\n      _S_showpoint \t= 1L << 10,\n      _S_showpos \t= 1L << 11,\n      _S_skipws \t= 1L << 12,\n      _S_unitbuf \t= 1L << 13,\n      _S_uppercase \t= 1L << 14,\n      _S_adjustfield \t= _S_left | _S_right | _S_internal,\n      _S_basefield \t= _S_dec | _S_oct | _S_hex,\n      _S_floatfield \t= _S_scientific | _S_fixed,\n      _S_ios_fmtflags_end = 1L << 16,\n      _S_ios_fmtflags_max = __INT_MAX__,\n      _S_ios_fmtflags_min = ~__INT_MAX__\n    };\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Fmtflags\n  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Fmtflags\n  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Fmtflags\n  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Fmtflags\n  operator~(_Ios_Fmtflags __a) _GLIBCXX_NOTHROW\n  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Fmtflags&\n  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n  { return __a = __a | __b; }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Fmtflags&\n  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n  { return __a = __a & __b; }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Fmtflags&\n  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n  { return __a = __a ^ __b; }\n\n  // If std::ios_base::noreplace isn't available, -Wswitch should ignore\n  // _S_noreplace.\n#ifdef __glibcxx_ios_noreplace\n#define _NOREPLACE_UNUSED\n#else\n#define _NOREPLACE_UNUSED __attribute__((__unused__))\n#endif\n\n  enum __attribute__((__flag_enum__)) _Ios_Openmode\n    {\n      _S_app \t\t= 1L << 0,\n      _S_ate \t\t= 1L << 1,\n      _S_bin \t\t= 1L << 2,\n      _S_in \t\t= 1L << 3,\n      _S_out \t\t= 1L << 4,\n      _S_trunc \t\t= 1L << 5,\n      _S_noreplace _NOREPLACE_UNUSED = 1L << 6,\n      _S_ios_openmode_end __attribute__((__unused__)) = 1L << 16,\n      _S_ios_openmode_max __attribute__((__unused__)) = __INT_MAX__,\n      _S_ios_openmode_min __attribute__((__unused__)) = ~__INT_MAX__\n    };\n\n#undef _NOREPLACE_UNUSED\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Openmode\n  operator&(_Ios_Openmode __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Openmode\n  operator|(_Ios_Openmode __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Openmode\n  operator^(_Ios_Openmode __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Openmode\n  operator~(_Ios_Openmode __a) _GLIBCXX_NOTHROW\n  { return _Ios_Openmode(~static_cast<int>(__a)); }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Openmode&\n  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n  { return __a = __a | __b; }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Openmode&\n  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n  { return __a = __a & __b; }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Openmode&\n  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Iostate\n    {\n      _S_goodbit \t\t= 0,\n      _S_badbit \t\t= 1L << 0,\n      _S_eofbit \t\t= 1L << 1,\n      _S_failbit\t\t= 1L << 2,\n      _S_ios_iostate_end = 1L << 16,\n      _S_ios_iostate_max = __INT_MAX__,\n      _S_ios_iostate_min = ~__INT_MAX__\n    };\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Iostate\n  operator&(_Ios_Iostate __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Iostate\n  operator|(_Ios_Iostate __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Iostate\n  operator^(_Ios_Iostate __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n\n  _GLIBCXX_NODISCARD _GLIBCXX_CONSTEXPR\n  inline _Ios_Iostate\n  operator~(_Ios_Iostate __a) _GLIBCXX_NOTHROW\n  { return _Ios_Iostate(~static_cast<int>(__a)); }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Iostate&\n  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n  { return __a = __a | __b; }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Iostate&\n  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n  { return __a = __a & __b; }\n\n  _GLIBCXX14_CONSTEXPR\n  inline const _Ios_Iostate&\n  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n  { return __a = __a ^ __b; }\n\n\n  enum _Ios_Seekdir\n    {\n      _S_beg = 0,\n      _S_cur = _GLIBCXX_STDIO_SEEK_CUR,\n      _S_end = _GLIBCXX_STDIO_SEEK_END,\n      _S_ios_seekdir_end = 1L << 16\n    };\n\n#if __cplusplus >= 201103L\n  /// I/O error code\n  enum class io_errc { stream = 1 };\n\n  template <> struct is_error_code_enum<io_errc> : public true_type { };\n\n  [[__nodiscard__, __gnu__::__const__]]\n  const error_category&\n  iostream_category() noexcept;\n\n  [[__nodiscard__]]\n  inline error_code\n  make_error_code(io_errc __e) noexcept\n  { return error_code(static_cast<int>(__e), iostream_category()); }\n\n  [[__nodiscard__]]\n  inline error_condition\n  make_error_condition(io_errc __e) noexcept\n  { return error_condition(static_cast<int>(__e), iostream_category()); }\n#endif\n\n  // 27.4.2  Class ios_base\n  /**\n   *  @brief  The base of the I/O class hierarchy.\n   *  @ingroup io\n   *\n   *  This class defines everything that can be defined about I/O that does\n   *  not depend on the type of characters being input or output.  Most\n   *  people will only see @c ios_base when they need to specify the full\n   *  name of the various I/O flags (e.g., the openmodes).\n  */\n  class ios_base\n  {\n#if _GLIBCXX_USE_CXX11_ABI\n#if __cplusplus < 201103L\n    // Type that is layout-compatible with std::system_error\n    struct system_error : std::runtime_error\n    {\n      // Type that is layout-compatible with std::error_code\n      struct error_code\n      {\n\terror_code() { }\n      private:\n\tint\t\t_M_value;\n\tconst void*\t_M_cat;\n      } _M_code;\n    };\n#endif\n#endif\n  public:\n\n    /**\n     *  @brief These are thrown to indicate problems with io.\n     *  @ingroup exceptions\n     *\n     *  27.4.2.1.1  Class ios_base::failure\n     */\n#if _GLIBCXX_USE_CXX11_ABI\n    class _GLIBCXX_ABI_TAG_CXX11 failure : public system_error\n    {\n    public:\n      explicit\n      failure(const string& __str);\n\n#if __cplusplus >= 201103L\n      explicit\n      failure(const string&, const error_code&);\n\n      explicit\n      failure(const char*, const error_code& = io_errc::stream);\n#endif\n\n      virtual\n      ~failure() throw();\n\n      virtual const char*\n      what() const throw();\n    };\n#else\n    class failure : public exception\n    {\n    public:\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 48.  Use of non-existent exception constructor\n      explicit\n      failure(const string& __str) throw();\n\n      // This declaration is not useless:\n      // http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Vague-Linkage.html\n      virtual\n      ~failure() throw();\n\n      virtual const char*\n      what() const throw();\n\n#if __cplusplus >= 201103L\n      // Define the new members required by C++11,\n      // even though the error_code cannot be stored.\n\n      explicit\n      failure(const string& __s, const error_code&) noexcept\n      : failure(__s)\n      { }\n\n      explicit\n      failure(const char* __s, const error_code& = error_code{})\n      : failure(string(__s))\n      { }\n\n      // Stand-in for system_error::code() but returning by value.\n      error_code code() const noexcept { return error_code{}; }\n#endif\n\n    private:\n      string _M_msg;\n    };\n#endif\n\n    // 27.4.2.1.2  Type ios_base::fmtflags\n    /**\n     *  @brief This is a bitmask type.\n     *\n     *  @c @a _Ios_Fmtflags is implementation-defined, but it is valid to\n     *  perform bitwise operations on these values and expect the Right\n     *  Thing to happen.  Defined objects of type fmtflags are:\n     *  - boolalpha\n     *  - dec\n     *  - fixed\n     *  - hex\n     *  - internal\n     *  - left\n     *  - oct\n     *  - right\n     *  - scientific\n     *  - showbase\n     *  - showpoint\n     *  - showpos\n     *  - skipws\n     *  - unitbuf\n     *  - uppercase\n     *  - adjustfield\n     *  - basefield\n     *  - floatfield\n    */\n    typedef _Ios_Fmtflags fmtflags;\n\n    /// Insert/extract @c bool in alphabetic rather than numeric format.\n    static const fmtflags boolalpha =   _S_boolalpha;\n\n    /// Converts integer input or generates integer output in decimal base.\n    static const fmtflags dec =         _S_dec;\n\n    /// Generate floating-point output in fixed-point notation.\n    static const fmtflags fixed =       _S_fixed;\n\n    /// Converts integer input or generates integer output in hexadecimal base.\n    static const fmtflags hex =         _S_hex;\n\n    /// Adds fill characters at a designated internal point in certain\n    /// generated output, or identical to @c right if no such point is\n    /// designated.\n    static const fmtflags internal =    _S_internal;\n\n    /// Adds fill characters on the right (final positions) of certain\n    /// generated output.  (I.e., the thing you print is flush left.)\n    static const fmtflags left =        _S_left;\n\n    /// Converts integer input or generates integer output in octal base.\n    static const fmtflags oct =         _S_oct;\n\n    /// Adds fill characters on the left (initial positions) of certain\n    /// generated output.  (I.e., the thing you print is flush right.)\n    static const fmtflags right =       _S_right;\n\n    /// Generates floating-point output in scientific notation.\n    static const fmtflags scientific =  _S_scientific;\n\n    /// Generates a prefix indicating the numeric base of generated integer\n    /// output.\n    static const fmtflags showbase =    _S_showbase;\n\n    /// Generates a decimal-point character unconditionally in generated\n    /// floating-point output.\n    static const fmtflags showpoint =   _S_showpoint;\n\n    /// Generates a + sign in non-negative generated numeric output.\n    static const fmtflags showpos =     _S_showpos;\n\n    /// Skips leading white space before certain input operations.\n    static const fmtflags skipws =      _S_skipws;\n\n    /// Flushes output after each output operation.\n    static const fmtflags unitbuf =     _S_unitbuf;\n\n    /// Replaces certain lowercase letters with their uppercase equivalents\n    /// in generated output.\n    static const fmtflags uppercase =   _S_uppercase;\n\n    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.\n    static const fmtflags adjustfield = _S_adjustfield;\n\n    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.\n    static const fmtflags basefield =   _S_basefield;\n\n    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.\n    static const fmtflags floatfield =  _S_floatfield;\n\n    // 27.4.2.1.3  Type ios_base::iostate\n    /**\n     *  @brief This is a bitmask type.\n     *\n     *  @c @a _Ios_Iostate is implementation-defined, but it is valid to\n     *  perform bitwise operations on these values and expect the Right\n     *  Thing to happen.  Defined objects of type iostate are:\n     *  - badbit\n     *  - eofbit\n     *  - failbit\n     *  - goodbit\n    */\n    typedef _Ios_Iostate iostate;\n\n    /// Indicates a loss of integrity in an input or output sequence (such\n    /// as an irrecoverable read error from a file).\n    static const iostate badbit =\t_S_badbit;\n\n    /// Indicates that an input operation reached the end of an input sequence.\n    static const iostate eofbit =\t_S_eofbit;\n\n    /// Indicates that an input operation failed to read the expected\n    /// characters, or that an output operation failed to generate the\n    /// desired characters.\n    static const iostate failbit =\t_S_failbit;\n\n    /// Indicates all is well.\n    static const iostate goodbit =\t_S_goodbit;\n\n    // 27.4.2.1.4  Type ios_base::openmode\n    /**\n     *  @brief This is a bitmask type.\n     *\n     *  @c @a _Ios_Openmode is implementation-defined, but it is valid to\n     *  perform bitwise operations on these values and expect the Right\n     *  Thing to happen.  Defined objects of type openmode are:\n     *  - app\n     *  - ate\n     *  - binary\n     *  - in\n     *  - out\n     *  - trunc\n    */\n    typedef _Ios_Openmode openmode;\n\n    /// Seek to end before each write.\n    static const openmode app =\t\t_S_app;\n\n    /// Open and seek to end immediately after opening.\n    static const openmode ate =\t\t_S_ate;\n\n    /// Perform input and output in binary mode (as opposed to text mode).\n    /// This is probably not what you think it is; see\n    /// https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary\n    static const openmode binary =\t_S_bin;\n\n    /// Open for input.  Default for @c ifstream and fstream.\n    static const openmode in =\t\t_S_in;\n\n    /// Open for output.  Default for @c ofstream and fstream.\n    static const openmode out =\t\t_S_out;\n\n    /// Truncate an existing stream when opening.  Default for @c ofstream.\n    static const openmode trunc =\t_S_trunc;\n\n    static const openmode __noreplace =\t_S_noreplace;\n\n#ifdef __glibcxx_ios_noreplace // C++ >= 23 && HOSTED\n    /// Open a file in exclusive mode.\n    static const openmode noreplace =\t_S_noreplace;\n#endif\n\n    // 27.4.2.1.5  Type ios_base::seekdir\n    /**\n     *  @brief This is an enumerated type.\n     *\n     *  @c @a _Ios_Seekdir is implementation-defined.  Defined values\n     *  of type seekdir are:\n     *  - beg\n     *  - cur, equivalent to @c SEEK_CUR in the C standard library.\n     *  - end, equivalent to @c SEEK_END in the C standard library.\n    */\n    typedef _Ios_Seekdir seekdir;\n\n    /// Request a seek relative to the beginning of the stream.\n    static const seekdir beg =\t\t_S_beg;\n\n    /// Request a seek relative to the current position within the sequence.\n    static const seekdir cur =\t\t_S_cur;\n\n    /// Request a seek relative to the current end of the sequence.\n    static const seekdir end =\t\t_S_end;\n\n#if __cplusplus <= 201402L\n    // Annex D.6 (removed in C++17)\n    typedef int io_state\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::iostate\");\n    typedef int open_mode\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::openmode\");\n    typedef int seek_dir\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::seekdir\");\n\n    typedef std::streampos streampos\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::streampos\");\n    typedef std::streamoff streamoff\n      _GLIBCXX_DEPRECATED_SUGGEST(\"std::streamoff\");\n#endif\n\n    // Callbacks;\n    /**\n     *  @brief  The set of events that may be passed to an event callback.\n     *\n     *  erase_event is used during ~ios() and copyfmt().  imbue_event is used\n     *  during imbue().  copyfmt_event is used during copyfmt().\n    */\n    enum event\n    {\n      erase_event,\n      imbue_event,\n      copyfmt_event\n    };\n\n    /**\n     *  @brief  The type of an event callback function.\n     *  @param  __e  One of the members of the event enum.\n     *  @param  __b  Reference to the ios_base object.\n     *  @param  __i  The integer provided when the callback was registered.\n     *\n     *  Event callbacks are user defined functions that get called during\n     *  several ios_base and basic_ios functions, specifically imbue(),\n     *  copyfmt(), and ~ios().\n    */\n    typedef void (*event_callback) (event __e, ios_base& __b, int __i);\n\n    /**\n     *  @brief  Add the callback __fn with parameter __index.\n     *  @param  __fn  The function to add.\n     *  @param  __index  The integer to pass to the function when invoked.\n     *\n     *  Registers a function as an event callback with an integer parameter to\n     *  be passed to the function when invoked.  Multiple copies of the\n     *  function are allowed.  If there are multiple callbacks, they are\n     *  invoked in the order they were registered.\n    */\n    void\n    register_callback(event_callback __fn, int __index);\n\n  protected:\n    streamsize\t\t_M_precision;\n    streamsize\t\t_M_width;\n    fmtflags\t\t_M_flags;\n    iostate\t\t_M_exception;\n    iostate\t\t_M_streambuf_state;\n\n    // 27.4.2.6  Members for callbacks\n    // 27.4.2.6  ios_base callbacks\n    struct _Callback_list\n    {\n      // Data Members\n      _Callback_list*\t\t_M_next;\n      ios_base::event_callback\t_M_fn;\n      int\t\t\t_M_index;\n      _Atomic_word\t\t_M_refcount;  // 0 means one reference.\n\n      _Callback_list(ios_base::event_callback __fn, int __index,\n\t\t     _Callback_list* __cb)\n      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\n\n      void\n      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }\n\n      // 0 => OK to delete.\n      int\n      _M_remove_reference()\n      {\n        // Be race-detector-friendly.  For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_refcount);\n        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);\n        if (__res == 0)\n          {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_refcount);\n          }\n        return __res;\n      }\n    };\n\n     _Callback_list*\t_M_callbacks;\n\n    void\n    _M_call_callbacks(event __ev) throw();\n\n    void\n    _M_dispose_callbacks(void) throw();\n\n    // 27.4.2.5  Members for iword/pword storage\n    struct _Words\n    {\n      void*\t_M_pword;\n      long\t_M_iword;\n      _Words() : _M_pword(0), _M_iword(0) { }\n    };\n\n    // Only for failed iword/pword calls.\n    _Words\t\t_M_word_zero;\n\n    // Guaranteed storage.\n    // The first 5 iword and pword slots are reserved for internal use.\n    enum { _S_local_word_size = 8 };\n    _Words\t\t_M_local_word[_S_local_word_size];\n\n    // Allocated storage.\n    int\t\t\t_M_word_size;\n    _Words*\t\t_M_word;\n\n    _Words&\n    _M_grow_words(int __index, bool __iword);\n\n    // Members for locale and locale caching.\n    locale\t\t_M_ios_locale;\n\n    void\n    _M_init() throw();\n\n  public:\n\n    // 27.4.2.1.6  Class ios_base::Init\n    // Used to initialize standard streams. In theory, g++ could use\n    // -finit-priority to order this stuff correctly without going\n    // through these machinations.\n    class Init\n    {\n      friend class ios_base;\n    public:\n      Init();\n      ~Init();\n\n#if __cplusplus >= 201103L\n      Init(const Init&) = default;\n      Init& operator=(const Init&) = default;\n#endif\n\n    private:\n      static _Atomic_word\t_S_refcount;\n      static bool\t\t_S_synced_with_stdio;\n    };\n\n    // [27.4.2.2] fmtflags state functions\n    /**\n     *  @brief  Access to format flags.\n     *  @return  The format control flags for both input and output.\n    */\n    _GLIBCXX_NODISCARD\n    fmtflags\n    flags() const\n    { return _M_flags; }\n\n    /**\n     *  @brief  Setting new format flags all at once.\n     *  @param  __fmtfl  The new flags to set.\n     *  @return  The previous format control flags.\n     *\n     *  This function overwrites all the format flags with @a __fmtfl.\n    */\n    fmtflags\n    flags(fmtflags __fmtfl)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags = __fmtfl;\n      return __old;\n    }\n\n    /**\n     *  @brief  Setting new format flags.\n     *  @param  __fmtfl  Additional flags to set.\n     *  @return  The previous format control flags.\n     *\n     *  This function sets additional flags in format control.  Flags that\n     *  were previously set remain set.\n    */\n    fmtflags\n    setf(fmtflags __fmtfl)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags |= __fmtfl;\n      return __old;\n    }\n\n    /**\n     *  @brief  Setting new format flags.\n     *  @param  __fmtfl  Additional flags to set.\n     *  @param  __mask  The flags mask for @a fmtfl.\n     *  @return  The previous format control flags.\n     *\n     *  This function clears @a mask in the format flags, then sets\n     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.\n    */\n    fmtflags\n    setf(fmtflags __fmtfl, fmtflags __mask)\n    {\n      fmtflags __old = _M_flags;\n      _M_flags &= ~__mask;\n      _M_flags |= (__fmtfl & __mask);\n      return __old;\n    }\n\n    /**\n     *  @brief  Clearing format flags.\n     *  @param  __mask  The flags to unset.\n     *\n     *  This function clears @a __mask in the format flags.\n    */\n    void\n    unsetf(fmtflags __mask)\n    { _M_flags &= ~__mask; }\n\n    /**\n     *  @brief  Flags access.\n     *  @return  The precision to generate on certain output operations.\n     *\n     *  Be careful if you try to give a definition of @a precision here; see\n     *  DR 189.\n    */\n    _GLIBCXX_NODISCARD\n    streamsize\n    precision() const\n    { return _M_precision; }\n\n    /**\n     *  @brief  Changing flags.\n     *  @param  __prec  The new precision value.\n     *  @return  The previous value of precision().\n    */\n    streamsize\n    precision(streamsize __prec)\n    {\n      streamsize __old = _M_precision;\n      _M_precision = __prec;\n      return __old;\n    }\n\n    /**\n     *  @brief  Flags access.\n     *  @return  The minimum field width to generate on output operations.\n     *\n     *  <em>Minimum field width</em> refers to the number of characters.\n    */\n    _GLIBCXX_NODISCARD\n    streamsize\n    width() const\n    { return _M_width; }\n\n    /**\n     *  @brief  Changing flags.\n     *  @param  __wide  The new width value.\n     *  @return  The previous value of width().\n    */\n    streamsize\n    width(streamsize __wide)\n    {\n      streamsize __old = _M_width;\n      _M_width = __wide;\n      return __old;\n    }\n\n    // [27.4.2.4] ios_base static members\n    /**\n     *  @brief  Interaction with the standard C I/O objects.\n     *  @param  __sync  Whether to synchronize or not.\n     *  @return  True if the standard streams were previously synchronized.\n     *\n     *  The synchronization referred to is @e only that between the standard\n     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,\n     *  cout).  User-declared streams are unaffected.  See\n     *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/fstreams.html#std.io.filestreams.binary\n    */\n    static bool\n    sync_with_stdio(bool __sync = true);\n\n    // [27.4.2.3] ios_base locale functions\n    /**\n     *  @brief  Setting a new locale.\n     *  @param  __loc  The new locale.\n     *  @return  The previous locale.\n     *\n     *  Sets the new locale for this stream, and then invokes each callback\n     *  with imbue_event.\n    */\n    locale\n    imbue(const locale& __loc) throw();\n\n    /**\n     *  @brief  Locale access\n     *  @return  A copy of the current locale.\n     *\n     *  If @c imbue(loc) has previously been called, then this function\n     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),\n     *  the global C++ locale.\n    */\n    _GLIBCXX_NODISCARD\n    locale\n    getloc() const\n    { return _M_ios_locale; }\n\n    /**\n     *  @brief  Locale access\n     *  @return  A reference to the current locale.\n     *\n     *  Like getloc above, but returns a reference instead of\n     *  generating a copy.\n    */\n    const locale&\n    _M_getloc() const\n    { return _M_ios_locale; }\n\n    // [27.4.2.5] ios_base storage functions\n    /**\n     *  @brief  Access to unique indices.\n     *  @return  An integer different from all previous calls.\n     *\n     *  This function returns a unique integer every time it is called.  It\n     *  can be used for any purpose, but is primarily intended to be a unique\n     *  index for the iword and pword functions.  The expectation is that an\n     *  application calls xalloc in order to obtain an index in the iword and\n     *  pword arrays that can be used without fear of conflict.\n     *\n     *  The implementation maintains a static variable that is incremented and\n     *  returned on each invocation.  xalloc is guaranteed to return an index\n     *  that is safe to use in the iword and pword arrays.\n    */\n    static int\n    xalloc() throw();\n\n    /**\n     *  @brief  Access to integer array.\n     *  @param  __ix  Index into the array.\n     *  @return  A reference to an integer associated with the index.\n     *\n     *  The iword function provides access to an array of integers that can be\n     *  used for any purpose.  The array grows as required to hold the\n     *  supplied index.  All integers in the array are initialized to 0.\n     *\n     *  The implementation reserves several indices.  You should use xalloc to\n     *  obtain an index that is safe to use.  Also note that since the array\n     *  can grow dynamically, it is not safe to hold onto the reference.\n    */\n    long&\n    iword(int __ix)\n    {\n      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)\n\t\t\t? _M_word[__ix] : _M_grow_words(__ix, true);\n      return __word._M_iword;\n    }\n\n    /**\n     *  @brief  Access to void pointer array.\n     *  @param  __ix  Index into the array.\n     *  @return  A reference to a void* associated with the index.\n     *\n     *  The pword function provides access to an array of pointers that can be\n     *  used for any purpose.  The array grows as required to hold the\n     *  supplied index.  All pointers in the array are initialized to 0.\n     *\n     *  The implementation reserves several indices.  You should use xalloc to\n     *  obtain an index that is safe to use.  Also note that since the array\n     *  can grow dynamically, it is not safe to hold onto the reference.\n    */\n    void*&\n    pword(int __ix)\n    {\n      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)\n\t\t\t? _M_word[__ix] : _M_grow_words(__ix, false);\n      return __word._M_pword;\n    }\n\n    // Destructor\n    /**\n     *  Invokes each callback with erase_event.  Destroys local storage.\n     *\n     *  Note that the ios_base object for the standard streams never gets\n     *  destroyed.  As a result, any callbacks registered with the standard\n     *  streams will not get invoked with erase_event (unless copyfmt is\n     *  used).\n    */\n    virtual ~ios_base();\n\n  protected:\n    ios_base() throw ();\n\n#if __cplusplus < 201103L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 50.  Copy constructor and assignment operator of ios_base\n  private:\n    ios_base(const ios_base&);\n\n    ios_base&\n    operator=(const ios_base&);\n#else\n  public:\n    ios_base(const ios_base&) = delete;\n\n    ios_base&\n    operator=(const ios_base&) = delete;\n\n  protected:\n    void\n    _M_move(ios_base&) noexcept;\n\n    void\n    _M_swap(ios_base& __rhs) noexcept;\n#endif\n  };\n\n  // [27.4.5.1] fmtflags manipulators\n  /// Calls base.setf(ios_base::boolalpha).\n  inline ios_base&\n  boolalpha(ios_base& __base)\n  {\n    __base.setf(ios_base::boolalpha);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::boolalpha).\n  inline ios_base&\n  noboolalpha(ios_base& __base)\n  {\n    __base.unsetf(ios_base::boolalpha);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::showbase).\n  inline ios_base&\n  showbase(ios_base& __base)\n  {\n    __base.setf(ios_base::showbase);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::showbase).\n  inline ios_base&\n  noshowbase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showbase);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::showpoint).\n  inline ios_base&\n  showpoint(ios_base& __base)\n  {\n    __base.setf(ios_base::showpoint);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::showpoint).\n  inline ios_base&\n  noshowpoint(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpoint);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::showpos).\n  inline ios_base&\n  showpos(ios_base& __base)\n  {\n    __base.setf(ios_base::showpos);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::showpos).\n  inline ios_base&\n  noshowpos(ios_base& __base)\n  {\n    __base.unsetf(ios_base::showpos);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::skipws).\n  inline ios_base&\n  skipws(ios_base& __base)\n  {\n    __base.setf(ios_base::skipws);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::skipws).\n  inline ios_base&\n  noskipws(ios_base& __base)\n  {\n    __base.unsetf(ios_base::skipws);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::uppercase).\n  inline ios_base&\n  uppercase(ios_base& __base)\n  {\n    __base.setf(ios_base::uppercase);\n    return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::uppercase).\n  inline ios_base&\n  nouppercase(ios_base& __base)\n  {\n    __base.unsetf(ios_base::uppercase);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::unitbuf).\n  inline ios_base&\n  unitbuf(ios_base& __base)\n  {\n     __base.setf(ios_base::unitbuf);\n     return __base;\n  }\n\n  /// Calls base.unsetf(ios_base::unitbuf).\n  inline ios_base&\n  nounitbuf(ios_base& __base)\n  {\n     __base.unsetf(ios_base::unitbuf);\n     return __base;\n  }\n\n  // [27.4.5.2] adjustfield manipulators\n  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).\n  inline ios_base&\n  internal(ios_base& __base)\n  {\n     __base.setf(ios_base::internal, ios_base::adjustfield);\n     return __base;\n  }\n\n  /// Calls base.setf(ios_base::left, ios_base::adjustfield).\n  inline ios_base&\n  left(ios_base& __base)\n  {\n    __base.setf(ios_base::left, ios_base::adjustfield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::right, ios_base::adjustfield).\n  inline ios_base&\n  right(ios_base& __base)\n  {\n    __base.setf(ios_base::right, ios_base::adjustfield);\n    return __base;\n  }\n\n  // [27.4.5.3] basefield manipulators\n  /// Calls base.setf(ios_base::dec, ios_base::basefield).\n  inline ios_base&\n  dec(ios_base& __base)\n  {\n    __base.setf(ios_base::dec, ios_base::basefield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::hex, ios_base::basefield).\n  inline ios_base&\n  hex(ios_base& __base)\n  {\n    __base.setf(ios_base::hex, ios_base::basefield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::oct, ios_base::basefield).\n  inline ios_base&\n  oct(ios_base& __base)\n  {\n    __base.setf(ios_base::oct, ios_base::basefield);\n    return __base;\n  }\n\n  // [27.4.5.4] floatfield manipulators\n  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).\n  inline ios_base&\n  fixed(ios_base& __base)\n  {\n    __base.setf(ios_base::fixed, ios_base::floatfield);\n    return __base;\n  }\n\n  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).\n  inline ios_base&\n  scientific(ios_base& __base)\n  {\n    __base.setf(ios_base::scientific, ios_base::floatfield);\n    return __base;\n  }\n\n#if __cplusplus >= 201103L\n  // New C++11 floatfield manipulators\n\n  /// Calls\n  /// base.setf(ios_base::fixed|ios_base::scientific, ios_base::floatfield)\n  inline ios_base&\n  hexfloat(ios_base& __base)\n  {\n    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __base;\n  }\n\n  /// Calls @c base.unsetf(ios_base::floatfield)\n  inline ios_base&\n  defaultfloat(ios_base& __base)\n  {\n    __base.unsetf(ios_base::floatfield);\n    return __base;\n  }\n#endif\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif /* _IOS_BASE_H */\n"},
                          "roles": ["resultFile"]},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/memory_resource.h"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/basic_string.h"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/streambuf"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/string"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/streambuf_iterator.h"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/bits/locale_classes.h"},
                          "sourceLanguage": "cplusplus"},
                         {"location": {"uri": "/usr/include/c++/15.2.1/iterator"},
                          "sourceLanguage": "cplusplus"}],
           "results": [{"ruleId": "error",
                        "level": "error",
                        "message": {"text": "static assertion failed"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                            "region": {"startLine": 9474,
                                                                       "startColumn": 25,
                                                                       "endColumn": 60},
                                                            "contextRegion": {"startLine": 9474,
                                                                              "snippet": {"text": "\t  static_assert(input_range<range_reference_t<_Rg>>);\n"}}},
                                       "logicalLocations": [{"name": "to<std::map<int, int>, std::vector<int> >",
                                                             "fullyQualifiedName": "std::ranges::to<std::map<int, int>, std::vector<int> >",
                                                             "decoratedName": "_ZNSt6ranges2toISt3mapIiiSt4lessIiESaISt4pairIKiiEEESt6vectorIiSaIiEEJEEET_OT0_DpOT1_",
                                                             "kind": "function"}],
                                       "id": 0,
                                       "relationships": [{"target": 1,
                                                          "kinds": ["isIncludedBy"]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 9474,
                                                                              "startColumn": 25,
                                                                              "endColumn": 60},
                                                                   "contextRegion": {"startLine": 9474,
                                                                                     "snippet": {"text": "\t  static_assert(input_range<range_reference_t<_Rg>>);\n"}}},
                                              "message": {"text": "constraints not satisfied"},
                                              "properties": {"nestingLevel": 0},
                                              "id": 2,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ranges_base.h"},
                                                                   "region": {"startLine": 516,
                                                                              "startColumn": 9,
                                                                              "endColumn": 27},
                                                                   "contextRegion": {"startLine": 516,
                                                                                     "snippet": {"text": "\tranges::begin(__t);\n"}}},
                                              "message": {"text": "the required expression 'std::ranges::_Cpo::begin(__t)' is invalid"},
                                              "properties": {"nestingLevel": 1},
                                              "id": 3,
                                              "relationships": [{"target": 4,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ranges_base.h"},
                                                                   "region": {"startLine": 517,
                                                                              "startColumn": 9,
                                                                              "endColumn": 25},
                                                                   "contextRegion": {"startLine": 517,
                                                                                     "snippet": {"text": "\tranges::end(__t);\n"}}},
                                              "message": {"text": "the required expression 'std::ranges::_Cpo::end(__t)' is invalid"},
                                              "properties": {"nestingLevel": 1},
                                              "id": 5,
                                              "relationships": [{"target": 4,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"message": {"text": "set '-fconcepts-diagnostics-depth=' to at least 2 for more detail"},
                                              "properties": {"nestingLevel": 1}},
                                             {"physicalLocation": {"artifactLocation": {"uri": "test/main.cpp",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 2},
                                                                   "contextRegion": {"startLine": 2,
                                                                                     "snippet": {"text": "#include <ranges>\n"}}},
                                              "relationships": [{"target": 0,
                                                                 "kinds": ["includes"]},
                                                                {"target": 2,
                                                                 "kinds": ["includes"]}],
                                              "id": 1},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ranges_util.h"},
                                                                   "region": {"startLine": 34},
                                                                   "contextRegion": {"startLine": 34,
                                                                                     "snippet": {"text": "# include <bits/ranges_base.h>\n"}}},
                                              "relationships": [{"target": 3,
                                                                 "kinds": ["includes"]},
                                                                {"target": 5,
                                                                 "kinds": ["includes"]},
                                                                {"target": 6,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 4},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/tuple"},
                                                                   "region": {"startLine": 46},
                                                                   "contextRegion": {"startLine": 46,
                                                                                     "snippet": {"text": "# include <bits/ranges_util.h>\t\t// for std::ranges::subrange\n"}}},
                                              "relationships": [{"target": 4,
                                                                 "kinds": ["includes"]},
                                                                {"target": 7,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 6},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/stl_map.h"},
                                                                   "region": {"startLine": 63},
                                                                   "contextRegion": {"startLine": 63,
                                                                                     "snippet": {"text": "#include <tuple>\n"}}},
                                              "relationships": [{"target": 6,
                                                                 "kinds": ["includes"]},
                                                                {"target": 8,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 7},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/map"},
                                                                   "region": {"startLine": 65},
                                                                   "contextRegion": {"startLine": 65,
                                                                                     "snippet": {"text": "#include <bits/stl_map.h>\n"}}},
                                              "relationships": [{"target": 7,
                                                                 "kinds": ["includes"]},
                                                                {"target": 9,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 8},
                                             {"physicalLocation": {"artifactLocation": {"uri": "test/main.cpp",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1},
                                                                   "contextRegion": {"startLine": 1,
                                                                                     "snippet": {"text": "#include <map>\n"}}},
                                              "relationships": [{"target": 8,
                                                                 "kinds": ["includes"]}],
                                              "id": 9}]},
                       {"ruleId": "error",
                        "level": "error",
                        "message": {"text": "no matching function for call to 'to<_ValT>(int&)'"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                            "region": {"startLine": 9480,
                                                                       "startColumn": 26,
                                                                       "endColumn": 43},
                                                            "contextRegion": {"startLine": 9480,
                                                                              "snippet": {"text": "\t\t  return ranges::to<_ValT>(std::forward<_Elt>(__elem));\n"}}},
                                       "logicalLocations": [{"name": "operator()<int&>",
                                                             "fullyQualifiedName": "std::ranges::to<std::map<int, int>, std::vector<int> >(std::vector<int>&&)::<lambda(_Elt&&)>::operator()<int&>",
                                                             "decoratedName": "_ZZNSt6ranges2toISt3mapIiiSt4lessIiESaISt4pairIKiiEEESt6vectorIiSaIiEEJEEET_OT0_DpOT1_ENKUlTyOSC_E_clIRiEEDaSI_",
                                                             "kind": "function"}],
                                       "id": 0,
                                       "relationships": [{"target": 1,
                                                          "kinds": ["isIncludedBy"]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 9480,
                                                                              "startColumn": 26,
                                                                              "endColumn": 43},
                                                                   "contextRegion": {"startLine": 9480,
                                                                                     "snippet": {"text": "\t\t  return ranges::to<_ValT>(std::forward<_Elt>(__elem));\n"}}},
                                              "message": {"text": "there is 1 candidate"},
                                              "properties": {"nestingLevel": 1},
                                              "id": 2,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 9423,
                                                                              "startColumn": 5,
                                                                              "endColumn": 7},
                                                                   "contextRegion": {"startLine": 9423,
                                                                                     "snippet": {"text": "    to [[nodiscard]] (_Rg&& __r, _Args&&... __args)\n"}}},
                                              "message": {"text": "candidate 1: 'template<class _Cont, class _Rg, class ... _Args>  requires (input_range<_Rg>) && !(view<_Cont>) constexpr _Cont std::ranges::to(_Rg&&, _Args&& ...)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 3,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 9423,
                                                                              "startColumn": 5,
                                                                              "endColumn": 7},
                                                                   "contextRegion": {"startLine": 9423,
                                                                                     "snippet": {"text": "    to [[nodiscard]] (_Rg&& __r, _Args&&... __args)\n"}}},
                                              "message": {"text": "template argument deduction/substitution failed:"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 4,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 9423,
                                                                              "startColumn": 5,
                                                                              "endColumn": 7},
                                                                   "contextRegion": {"startLine": 9423,
                                                                                     "snippet": {"text": "    to [[nodiscard]] (_Rg&& __r, _Args&&... __args)\n"}}},
                                              "message": {"text": "constraints not satisfied"},
                                              "properties": {"nestingLevel": 4},
                                              "id": 5,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ranges_base.h"},
                                                                   "region": {"startLine": 516,
                                                                              "startColumn": 9,
                                                                              "endColumn": 27},
                                                                   "contextRegion": {"startLine": 516,
                                                                                     "snippet": {"text": "\tranges::begin(__t);\n"}}},
                                              "message": {"text": "the required expression 'std::ranges::_Cpo::begin(__t)' is invalid"},
                                              "properties": {"nestingLevel": 5},
                                              "id": 6,
                                              "relationships": [{"target": 7,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ranges_base.h"},
                                                                   "region": {"startLine": 517,
                                                                              "startColumn": 9,
                                                                              "endColumn": 25},
                                                                   "contextRegion": {"startLine": 517,
                                                                                     "snippet": {"text": "\tranges::end(__t);\n"}}},
                                              "message": {"text": "the required expression 'std::ranges::_Cpo::end(__t)' is invalid"},
                                              "properties": {"nestingLevel": 5},
                                              "id": 8,
                                              "relationships": [{"target": 7,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "test/main.cpp",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 2},
                                                                   "contextRegion": {"startLine": 2,
                                                                                     "snippet": {"text": "#include <ranges>\n"}}},
                                              "relationships": [{"target": 0,
                                                                 "kinds": ["includes"]},
                                                                {"target": 2,
                                                                 "kinds": ["includes"]},
                                                                {"target": 3,
                                                                 "kinds": ["includes"]},
                                                                {"target": 4,
                                                                 "kinds": ["includes"]},
                                                                {"target": 5,
                                                                 "kinds": ["includes"]}],
                                              "id": 1},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ranges_util.h"},
                                                                   "region": {"startLine": 34},
                                                                   "contextRegion": {"startLine": 34,
                                                                                     "snippet": {"text": "# include <bits/ranges_base.h>\n"}}},
                                              "relationships": [{"target": 6,
                                                                 "kinds": ["includes"]},
                                                                {"target": 8,
                                                                 "kinds": ["includes"]},
                                                                {"target": 9,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 7},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/tuple"},
                                                                   "region": {"startLine": 46},
                                                                   "contextRegion": {"startLine": 46,
                                                                                     "snippet": {"text": "# include <bits/ranges_util.h>\t\t// for std::ranges::subrange\n"}}},
                                              "relationships": [{"target": 7,
                                                                 "kinds": ["includes"]},
                                                                {"target": 10,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 9},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/stl_map.h"},
                                                                   "region": {"startLine": 63},
                                                                   "contextRegion": {"startLine": 63,
                                                                                     "snippet": {"text": "#include <tuple>\n"}}},
                                              "relationships": [{"target": 9,
                                                                 "kinds": ["includes"]},
                                                                {"target": 11,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 10},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/map"},
                                                                   "region": {"startLine": 65},
                                                                   "contextRegion": {"startLine": 65,
                                                                                     "snippet": {"text": "#include <bits/stl_map.h>\n"}}},
                                              "relationships": [{"target": 10,
                                                                 "kinds": ["includes"]},
                                                                {"target": 12,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 11},
                                             {"physicalLocation": {"artifactLocation": {"uri": "test/main.cpp",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1},
                                                                   "contextRegion": {"startLine": 1,
                                                                                     "snippet": {"text": "#include <map>\n"}}},
                                              "relationships": [{"target": 11,
                                                                 "kinds": ["includes"]}],
                                              "id": 12}]},
                       {"ruleId": "error",
                        "level": "error",
                        "message": {"text": "no match for 'operator|' (operand types are 'std::ranges::ref_view<std::vector<int> >' and 'std::ranges::views::__adaptor::_Partial<std::ranges::views::_Transform, std::ranges::to<std::map<int, int>, std::vector<int> >(std::vector<int>&&)::<lambda(_Elt&&)> >')"},
                        "locations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                            "region": {"startLine": 9477,
                                                                       "startColumn": 36,
                                                                       "endLine": 9481,
                                                                       "endColumn": 19},
                                                            "contextRegion": {"startLine": 9477,
                                                                              "endLine": 9481,
                                                                              "snippet": {"text": "\t  return ranges::to<_Cont>(ref_view(__r) | views::transform(\n\t\t[]<typename _Elt>(_Elt&& __elem) {\n\t\t  using _ValT = range_value_t<_Cont>;\n\t\t  return ranges::to<_ValT>(std::forward<_Elt>(__elem));\n\t\t}), std::forward<_Args>(__args)...);\n"}}},
                                       "logicalLocations": [{"name": "to<std::map<int, int>, std::vector<int> >",
                                                             "fullyQualifiedName": "std::ranges::to<std::map<int, int>, std::vector<int> >",
                                                             "decoratedName": "_ZNSt6ranges2toISt3mapIiiSt4lessIiESaISt4pairIKiiEEESt6vectorIiSaIiEEJEEET_OT0_DpOT1_",
                                                             "kind": "function"}],
                                       "id": 0,
                                       "relationships": [{"target": 1,
                                                          "kinds": ["isIncludedBy"]}]}],
                        "relatedLocations": [{"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 9477,
                                                                              "startColumn": 36,
                                                                              "endLine": 9481,
                                                                              "endColumn": 19},
                                                                   "contextRegion": {"startLine": 9477,
                                                                                     "endLine": 9481,
                                                                                     "snippet": {"text": "\t  return ranges::to<_Cont>(ref_view(__r) | views::transform(\n\t\t[]<typename _Elt>(_Elt&& __elem) {\n\t\t  using _ValT = range_value_t<_Cont>;\n\t\t  return ranges::to<_ValT>(std::forward<_Elt>(__elem));\n\t\t}), std::forward<_Args>(__args)...);\n"}}},
                                              "message": {"text": "there are 7 candidates"},
                                              "properties": {"nestingLevel": 1},
                                              "id": 2,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 981,
                                                                              "startColumn": 5,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 981,
                                                                                     "snippet": {"text": "    operator|(_Lhs&& __lhs, _Rhs&& __rhs)\n"}}},
                                              "message": {"text": "candidate 1: 'template<class _Lhs, class _Rhs>  requires (__is_range_adaptor_closure<_Lhs>) && (__is_range_adaptor_closure<_Rhs>) constexpr auto std::ranges::views::__adaptor::operator|(_Lhs&&, _Rhs&&)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 3,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 981,
                                                                              "startColumn": 5,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 981,
                                                                                     "snippet": {"text": "    operator|(_Lhs&& __lhs, _Rhs&& __rhs)\n"}}},
                                              "message": {"text": "template argument deduction/substitution failed:"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 4,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 981,
                                                                              "startColumn": 5,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 981,
                                                                                     "snippet": {"text": "    operator|(_Lhs&& __lhs, _Rhs&& __rhs)\n"}}},
                                              "message": {"text": "constraints not satisfied"},
                                              "properties": {"nestingLevel": 4},
                                              "id": 5,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 963,
                                                                              "startColumn": 30,
                                                                              "endColumn": 80},
                                                                   "contextRegion": {"startLine": 963,
                                                                                     "snippet": {"text": "      = requires (_Tp __t) { __adaptor::__is_range_adaptor_closure_fn(__t, __t); };\n"}}},
                                              "message": {"text": "the required expression 'std::ranges::views::__adaptor::__is_range_adaptor_closure_fn(__t, __t)' is invalid"},
                                              "properties": {"nestingLevel": 5},
                                              "id": 6,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 972,
                                                                              "startColumn": 5,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 972,
                                                                                     "snippet": {"text": "    operator|(_Range&& __r, _Self&& __self)\n"}}},
                                              "message": {"text": "candidate 2: 'template<class _Self, class _Range>  requires (__is_range_adaptor_closure<_Self>) && (__adaptor_invocable<_Self, _Range>) constexpr auto std::ranges::views::__adaptor::operator|(_Range&&, _Self&&)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 7,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 972,
                                                                              "startColumn": 5,
                                                                              "endColumn": 13},
                                                                   "contextRegion": {"startLine": 972,
                                                                                     "snippet": {"text": "    operator|(_Range&& __r, _Self&& __self)\n"}}},
                                              "message": {"text": "substitution of deduced template arguments resulted in errors seen above"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 8,
                                              "relationships": [{"target": 1,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/cstddef"},
                                                                   "region": {"startLine": 141,
                                                                              "startColumn": 3,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 141,
                                                                                     "snippet": {"text": "  operator|(byte __l, byte __r) noexcept\n"}}},
                                              "message": {"text": "candidate 3: 'constexpr std::byte std::operator|(byte, byte)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 9,
                                              "relationships": [{"target": 10,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/cstddef"},
                                                                   "region": {"startLine": 141,
                                                                              "startColumn": 13,
                                                                              "endColumn": 21},
                                                                   "contextRegion": {"startLine": 141,
                                                                                     "snippet": {"text": "  operator|(byte __l, byte __r) noexcept\n"}}},
                                              "message": {"text": "no known conversion for argument 1 from 'std::ranges::ref_view<std::vector<int> >' to 'std::byte'"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 11,
                                              "relationships": [{"target": 10,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/charconv"},
                                                                   "region": {"startLine": 632,
                                                                              "startColumn": 3,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 632,
                                                                                     "snippet": {"text": "  operator|(chars_format __lhs, chars_format __rhs) noexcept\n"}}},
                                              "message": {"text": "candidate 4: 'constexpr std::chars_format std::operator|(chars_format, chars_format)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 12,
                                              "relationships": [{"target": 13,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/charconv"},
                                                                   "region": {"startLine": 632,
                                                                              "startColumn": 13,
                                                                              "endColumn": 31},
                                                                   "contextRegion": {"startLine": 632,
                                                                                     "snippet": {"text": "  operator|(chars_format __lhs, chars_format __rhs) noexcept\n"}}},
                                              "message": {"text": "no known conversion for argument 1 from 'std::ranges::ref_view<std::vector<int> >' to 'std::chars_format'"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 14,
                                              "relationships": [{"target": 13,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                                                                   "region": {"startLine": 91,
                                                                              "startColumn": 3,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 91,
                                                                                     "snippet": {"text": "  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n"}}},
                                              "message": {"text": "candidate 5: 'constexpr std::_Ios_Fmtflags std::operator|(_Ios_Fmtflags, _Ios_Fmtflags)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 15,
                                              "relationships": [{"target": 16,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                                                                   "region": {"startLine": 91,
                                                                              "startColumn": 13,
                                                                              "endColumn": 30},
                                                                   "contextRegion": {"startLine": 91,
                                                                                     "snippet": {"text": "  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) _GLIBCXX_NOTHROW\n"}}},
                                              "message": {"text": "no known conversion for argument 1 from 'std::ranges::ref_view<std::vector<int> >' to 'std::_Ios_Fmtflags'"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 17,
                                              "relationships": [{"target": 16,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                                                                   "region": {"startLine": 150,
                                                                              "startColumn": 3,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 150,
                                                                                     "snippet": {"text": "  operator|(_Ios_Openmode __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n"}}},
                                              "message": {"text": "candidate 6: 'constexpr std::_Ios_Openmode std::operator|(_Ios_Openmode, _Ios_Openmode)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 18,
                                              "relationships": [{"target": 16,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                                                                   "region": {"startLine": 150,
                                                                              "startColumn": 13,
                                                                              "endColumn": 30},
                                                                   "contextRegion": {"startLine": 150,
                                                                                     "snippet": {"text": "  operator|(_Ios_Openmode __a, _Ios_Openmode __b) _GLIBCXX_NOTHROW\n"}}},
                                              "message": {"text": "no known conversion for argument 1 from 'std::ranges::ref_view<std::vector<int> >' to 'std::_Ios_Openmode'"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 19,
                                              "relationships": [{"target": 16,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                                                                   "region": {"startLine": 197,
                                                                              "startColumn": 3,
                                                                              "endColumn": 11},
                                                                   "contextRegion": {"startLine": 197,
                                                                                     "snippet": {"text": "  operator|(_Ios_Iostate __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n"}}},
                                              "message": {"text": "candidate 7: 'constexpr std::_Ios_Iostate std::operator|(_Ios_Iostate, _Ios_Iostate)'"},
                                              "properties": {"nestingLevel": 2},
                                              "id": 20,
                                              "relationships": [{"target": 16,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                                                                   "region": {"startLine": 197,
                                                                              "startColumn": 13,
                                                                              "endColumn": 29},
                                                                   "contextRegion": {"startLine": 197,
                                                                                     "snippet": {"text": "  operator|(_Ios_Iostate __a, _Ios_Iostate __b) _GLIBCXX_NOTHROW\n"}}},
                                              "message": {"text": "no known conversion for argument 1 from 'std::ranges::ref_view<std::vector<int> >' to 'std::_Ios_Iostate'"},
                                              "properties": {"nestingLevel": 3},
                                              "id": 21,
                                              "relationships": [{"target": 16,
                                                                 "kinds": ["isIncludedBy"]}]},
                                             {"physicalLocation": {"artifactLocation": {"uri": "test/main.cpp",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 2},
                                                                   "contextRegion": {"startLine": 2,
                                                                                     "snippet": {"text": "#include <ranges>\n"}}},
                                              "relationships": [{"target": 0,
                                                                 "kinds": ["includes"]},
                                                                {"target": 2,
                                                                 "kinds": ["includes"]},
                                                                {"target": 3,
                                                                 "kinds": ["includes"]},
                                                                {"target": 4,
                                                                 "kinds": ["includes"]},
                                                                {"target": 5,
                                                                 "kinds": ["includes"]},
                                                                {"target": 6,
                                                                 "kinds": ["includes"]},
                                                                {"target": 7,
                                                                 "kinds": ["includes"]},
                                                                {"target": 8,
                                                                 "kinds": ["includes"]},
                                                                {"target": 29,
                                                                 "kinds": ["includes"]}],
                                              "id": 1},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/memory_resource.h"},
                                                                   "region": {"startLine": 40},
                                                                   "contextRegion": {"startLine": 40,
                                                                                     "snippet": {"text": "#include <cstddef>\t\t\t// size_t, max_align_t, byte\n"}}},
                                              "relationships": [{"target": 9,
                                                                 "kinds": ["includes"]},
                                                                {"target": 11,
                                                                 "kinds": ["includes"]},
                                                                {"target": 22,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 10},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/basic_string.h"},
                                                                   "region": {"startLine": 60},
                                                                   "contextRegion": {"startLine": 60,
                                                                                     "snippet": {"text": "# include <charconv>\n"}}},
                                              "relationships": [{"target": 12,
                                                                 "kinds": ["includes"]},
                                                                {"target": 14,
                                                                 "kinds": ["includes"]},
                                                                {"target": 23,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 13},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/streambuf"},
                                                                   "region": {"startLine": 45},
                                                                   "contextRegion": {"startLine": 45,
                                                                                     "snippet": {"text": "#include <bits/ios_base.h>\n"}}},
                                              "relationships": [{"target": 15,
                                                                 "kinds": ["includes"]},
                                                                {"target": 17,
                                                                 "kinds": ["includes"]},
                                                                {"target": 18,
                                                                 "kinds": ["includes"]},
                                                                {"target": 19,
                                                                 "kinds": ["includes"]},
                                                                {"target": 20,
                                                                 "kinds": ["includes"]},
                                                                {"target": 21,
                                                                 "kinds": ["includes"]},
                                                                {"target": 24,
                                                                 "kinds": ["isIncludedBy"]},
                                                                {"target": 28,
                                                                 "kinds": ["includes"]}],
                                              "id": 16},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/map"},
                                                                   "region": {"startLine": 85},
                                                                   "contextRegion": {"startLine": 85,
                                                                                     "snippet": {"text": "#include <bits/memory_resource.h>\n"}}},
                                              "relationships": [{"target": 10,
                                                                 "kinds": ["includes"]},
                                                                {"target": 25,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 22},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/string"},
                                                                   "region": {"startLine": 56},
                                                                   "contextRegion": {"startLine": 56,
                                                                                     "snippet": {"text": "#include <bits/basic_string.h>\n"}}},
                                              "relationships": [{"target": 13,
                                                                 "kinds": ["includes"]},
                                                                {"target": 26,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 23},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/streambuf_iterator.h"},
                                                                   "region": {"startLine": 37},
                                                                   "contextRegion": {"startLine": 37,
                                                                                     "snippet": {"text": "#include <streambuf>\n"}}},
                                              "relationships": [{"target": 16,
                                                                 "kinds": ["includes"]},
                                                                {"target": 27,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 24},
                                             {"physicalLocation": {"artifactLocation": {"uri": "test/main.cpp",
                                                                                        "uriBaseId": "PWD"},
                                                                   "region": {"startLine": 1},
                                                                   "contextRegion": {"startLine": 1,
                                                                                     "snippet": {"text": "#include <map>\n"}}},
                                              "relationships": [{"target": 22,
                                                                 "kinds": ["includes"]}],
                                              "id": 25},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/locale_classes.h"},
                                                                   "region": {"startLine": 42},
                                                                   "contextRegion": {"startLine": 42,
                                                                                     "snippet": {"text": "#include <string>\n"}}},
                                              "relationships": [{"target": 23,
                                                                 "kinds": ["includes"]},
                                                                {"target": 28,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 26},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/iterator"},
                                                                   "region": {"startLine": 68},
                                                                   "contextRegion": {"startLine": 68,
                                                                                     "snippet": {"text": "# include <bits/streambuf_iterator.h>\n"}}},
                                              "relationships": [{"target": 24,
                                                                 "kinds": ["includes"]},
                                                                {"target": 29,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 27},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/bits/ios_base.h"},
                                                                   "region": {"startLine": 43},
                                                                   "contextRegion": {"startLine": 43,
                                                                                     "snippet": {"text": "#include <bits/locale_classes.h>\n"}}},
                                              "relationships": [{"target": 26,
                                                                 "kinds": ["includes"]},
                                                                {"target": 16,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 28},
                                             {"physicalLocation": {"artifactLocation": {"uri": "/usr/include/c++/15.2.1/ranges"},
                                                                   "region": {"startLine": 45},
                                                                   "contextRegion": {"startLine": 45,
                                                                                     "snippet": {"text": "#include <iterator>\n"}}},
                                              "relationships": [{"target": 27,
                                                                 "kinds": ["includes"]},
                                                                {"target": 1,
                                                                 "kinds": ["isIncludedBy"]}],
                                              "id": 29}]}]}]}
